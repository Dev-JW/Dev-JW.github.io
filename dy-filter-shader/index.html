<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>实现抖音特效滤镜 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="本文将通过 GLSL 来模仿抖音中几种特效的实现。 动画 抖音上的特效都是动态的，那么要怎么把动态……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/dy-filter-shader/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-08-13T19:37:01+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/dy-filter-shader/","name":"实现抖音特效滤镜","description":"本文将通过 GLSL 来模仿抖音中几种特效的实现。 动画 抖音上的特效都是动态的，那么要怎么把动态……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="实现抖音特效滤镜"><meta property="og:description" content="本文将通过 GLSL 来模仿抖音中几种特效的实现。 动画 抖音上的特效都是动态的，那么要怎么把动态……"><meta property="og:url" content="https://dev.hjw.best/dy-filter-shader/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">实现抖音特效滤镜</h1><div class=post-meta><time datetime=2020-08-13T19:37:01+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-08-13</time></div><div class="post-body e-content"><p>本文将通过 GLSL 来模仿抖音中几种特效的实现。</p><h3 id=动画><a href=#动画 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>动画</h3><p>抖音上的特效都是动态的，那么要怎么把动态的效果，加到一个静态的图片上呢？</p><p>在 <code>UIKit</code> 中实现动画，我们是通过使用 <code>CoreAnimation</code>来高效、方便地实现动画，而 <code>CoreAnimation</code> 的职责就是尽可能快地组合屏幕上不同的可视内容，<strong>逐帧计算</strong>当前显示的内容。</p><p><strong>逐帧计算</strong></p><p>在 OpenGL ES 中，我们实现动画的方式，就是计算每一帧应该显示的图像，然后在屏幕刷新的时候，重新渲染。</p><p>这个计算过程，我们是放在 Shader 中进行的。</p><p>通过一个表示时间的参数，在重新渲染的时候，传入当前的时间，让 Shader 计算当前动画的进度。</p><p>重新渲染，则依赖 <code>CADisplayLink</code>来实现。</p><h4 id=缩放><a href=#缩放 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>缩放</h4><p><img src=https://w-md.imzsy.design/image-20200818191824078.png alt=image-20200818191824078></p><p><strong>原理</strong></p><p>通过修改顶点坐标和纹理坐标的映射关系来实现</p><p><strong>着色器代码</strong></p><p>缩放的关键点是在于计算振幅</p><ul><li><p><code>duration</code>表示一次缩放周期的时长</p></li><li><p><code>mod(Time, duration)</code>表示传入的时间转换到一个周期内，即 <code>time</code> 的范围是 <code>0~0.6</code></p></li><li><p><code>amplitude</code>表示振幅，这里使用 <code>sin</code> 函数，将振幅范围控制在 <code>1.0~1.3</code> 之间</p><p><img src=https://w-md.imzsy.design/image-20200818192510950.png alt=image-20200818192510950></p></li><li><p>将顶点坐标的 x 和 y 分别乘以振幅，在纹理坐标不变的情况下，就可以达到缩放效果</p></li></ul><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>attribute</span> <span class=k>vec4</span> <span class=n>position</span><span class=p>;</span>
<span class=k>attribute</span> <span class=k>vec2</span> <span class=n>inputTextureCoordinate</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>

<span class=c1>// 时间戳（随着定时器的方法调用及时更新）:从0开始一直递增</span>
<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>const</span> <span class=k>float</span> <span class=n>PI</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 一次动画周期时长</span>
    <span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>0.6</span><span class=p>;</span>
  	<span class=c1>// 最大缩放量</span>
    <span class=k>float</span> <span class=n>maxAmplitude</span> <span class=o>=</span> <span class=mf>0.3</span><span class=p>;</span>
  	<span class=c1>// 表示传入的事件周期，即time的范围被控制在0.0~0.6</span>
  	<span class=c1>// mod(a, b)，求模运算 等价于 a%b，GLSL中不支持%求模</span>
    <span class=k>float</span> <span class=n>time</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span><span class=p>);</span>
    <span class=c1>// amplitude表示振幅，引入PI的目的是为了使用sin函数，将amplitude的范围控制在1.0 ~ 1.3之间，并随着时间变化</span>
    <span class=c1>// 这里可以不用取绝对值，因为角度的范围是【0，π】，不会出现负数的情况</span>
    <span class=k>float</span> <span class=n>amplitude</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>+</span> <span class=n>maxAmplitude</span> <span class=o>*</span> <span class=n>abs</span><span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=n>time</span> <span class=o>*</span> <span class=p>(</span><span class=n>PI</span> <span class=o>/</span> <span class=n>duration</span><span class=p>)));</span>
    <span class=c1>// 放大关键代码：将顶点坐标的x和y分别乘以一个放大系数，即振幅，在纹理坐标不变的情况下，就达到了拉伸的效果</span>
    <span class=c1>// xy放大，zw保持不变</span>
    <span class=n>gl_Position</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>position</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>,</span> <span class=n>position</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>,</span> <span class=n>position</span><span class=p>.</span><span class=n>zw</span><span class=p>);</span>
    <span class=c1>// 纹理坐标传递给textureCoordinate</span>
    <span class=n>textureCoordinate</span> <span class=o>=</span> <span class=n>inputTextureCoordinate</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=灵魂出窍><a href=#灵魂出窍 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>灵魂出窍</h4><p><img src=https://w-md.imzsy.design/image-20200818193932331.png alt=image-20200818193932331></p><p><strong>原理</strong></p><p>两个层的叠加，并且上面的那层随着时间的推移，会逐渐放大且透明度逐渐降低。</p><p><strong>着色器代码</strong></p><p>放大的关键点是 <code>weakX</code> 和 <code>weakY</code> 的计算，</p><p>比如<code>0.5 + (textureCoordinate.x - 0.5) / scale</code>，即将顶点坐标对应的纹理坐标的 <code>x</code> 值到纹理中点的距离，缩小一定的比例</p><p>两层叠加的效果，我们通过得到两个纹理颜色值 <code>weakMask</code> 和 <code>mask</code>，</p><p>根据混合模式中的正常混合公式：<strong>最终色 = 基色 * a% + 混合色 * (1 - a%)</strong></p><blockquote><p>也可以使用 <code>mix</code> 内置函数进行线性混合</p></blockquote><p><strong>关键点分析</strong></p><ul><li><p>计算当前动画进度的百分比</p><p><img src=https://w-md.imzsy.design/image-20200818195244854.png alt=image-20200818195244854></p></li><li><p>计算透明度、缩放因子</p><p><img src=https://w-md.imzsy.design/image-20200818195258991.png alt=image-20200818195258991></p></li><li><p>颜色混合</p><p><img src=https://w-md.imzsy.design/image-20200818195312976.png alt=image-20200818195312976></p></li></ul><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>precision</span> <span class=k>highp</span> <span class=k>float</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>sampler2D</span> <span class=n>inputImageTexture</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>
<span class=c1>// 时间戳</span>
<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 一次动画周期时长</span>
    <span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>0.7</span><span class=p>;</span>
  	<span class=c1>// 最大透明度</span>
    <span class=k>float</span> <span class=n>maxAlpha</span> <span class=o>=</span> <span class=mf>0.4</span><span class=p>;</span>
  	<span class=c1>// 最大缩放值</span>
    <span class=k>float</span> <span class=n>maxScale</span> <span class=o>=</span> <span class=mf>1.8</span><span class=p>;</span>
    <span class=c1>// 当前动画进度(时间戳与时长使用mod取模), 再除以时长 得到[0,1]</span>
    <span class=k>float</span> <span class=n>progress</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span><span class=p>)</span> <span class=o>/</span> <span class=n>duration</span><span class=p>;</span>
    <span class=c1>// 当前透明度[0.4, 0]</span>
    <span class=k>float</span> <span class=n>alpha</span> <span class=o>=</span> <span class=n>maxAlpha</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>progress</span><span class=p>);</span>
    <span class=c1>// 当前缩放因子[1.0, 1.8]</span>
    <span class=k>float</span> <span class=n>scale</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>+</span> <span class=p>(</span><span class=n>maxScale</span> <span class=o>-</span> <span class=mf>1.0</span><span class=p>)</span> <span class=o>*</span> <span class=n>progress</span><span class=p>;</span>
    <span class=c1>// 将顶点坐标对应的纹理坐标的x/y值到中心点的距离，缩小一定的比例</span>
    <span class=k>float</span> <span class=n>weakX</span> <span class=o>=</span> <span class=mf>0.5</span> <span class=o>+</span> <span class=p>(</span><span class=n>textureCoordinate</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>/</span> <span class=n>scale</span><span class=p>;</span>
    <span class=k>float</span> <span class=n>weakY</span> <span class=o>=</span> <span class=mf>0.5</span> <span class=o>+</span> <span class=p>(</span><span class=n>textureCoordinate</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>/</span> <span class=n>scale</span><span class=p>;</span>
    <span class=k>vec2</span> <span class=n>weakTextureCoords</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=n>weakX</span><span class=p>,</span> <span class=n>weakY</span><span class=p>);</span>
    <span class=c1>// 获取当前像素点纹理坐标，放大后的纹理坐标  </span>
    <span class=k>vec4</span> <span class=n>weakMask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>weakTextureCoords</span><span class=p>);</span>
    <span class=c1>// 获取原始像素点纹素</span>
    <span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>textureCoordinate</span><span class=p>);</span>
    <span class=c1>// 颜色混合 内建函数mix / 混合方程式</span>
    <span class=n>gl_FragColor</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>alpha</span><span class=p>)</span> <span class=o>+</span> <span class=n>weakMask</span> <span class=o>*</span> <span class=n>alpha</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=抖动><a href=#抖动 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>抖动</h4><p><img src=https://w-md.imzsy.design/image-20200818200441621.png alt=image-20200818200441621></p><p><strong>原理</strong></p><p>颜色偏移+微弱的放大效果</p><p><strong>着色器代码</strong></p><p>颜色偏移是对三个颜色通道进行分离，并且给红色通道和蓝色通道添加了不同的位置偏移</p><p><img src=https://w-md.imzsy.design/image-20200819114035428.png alt=image-20200819114035428></p><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>precision</span> <span class=k>highp</span> <span class=k>float</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>sampler2D</span> <span class=n>inputImageTexture</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 一次动画周期时长</span>
    <span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>0.7</span><span class=p>;</span>
    <span class=c1>// 最大缩放值</span>
    <span class=k>float</span> <span class=n>maxScale</span> <span class=o>=</span> <span class=mf>1.1</span><span class=p>;</span>
  	<span class=c1>// 颜色偏移的步长</span>
    <span class=k>float</span> <span class=n>offset</span> <span class=o>=</span> <span class=mf>0.02</span><span class=p>;</span>
    <span class=c1>// 当前动画进度</span>
    <span class=k>float</span> <span class=n>progress</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span><span class=p>)</span> <span class=o>/</span> <span class=n>duration</span><span class=p>;</span> <span class=c1>// 0~1</span>
    <span class=c1>// 颜色偏移值[0, 0.02]</span>
    <span class=k>vec2</span> <span class=n>offsetCoords</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=n>offset</span><span class=p>,</span> <span class=n>offset</span><span class=p>)</span> <span class=o>*</span> <span class=n>progress</span><span class=p>;</span>
    <span class=c1>// 缩放因子[1.0, 1.1]</span>
    <span class=k>float</span> <span class=n>scale</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>+</span> <span class=p>(</span><span class=n>maxScale</span> <span class=o>-</span> <span class=mf>1.0</span><span class=p>)</span> <span class=o>*</span> <span class=n>progress</span><span class=p>;</span>
    <span class=c1>// 放大后的纹理坐标 </span>
    <span class=c1>// 向量与向量的加减乘除，结果返回的是向量</span>
  	<span class=c1>// vec2(x, y) + vec2(a, b) = vec2(x + a, y + b);</span>
    <span class=k>vec2</span> <span class=n>ScaleTextureCoords</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>textureCoordinate</span> <span class=o>-</span> <span class=k>vec2</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>))</span> <span class=o>/</span> <span class=n>scale</span><span class=p>;</span>
    
  	<span class=c1>// 计算颜色偏移</span>
    <span class=k>vec4</span> <span class=n>maskR</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>ScaleTextureCoords</span> <span class=o>+</span> <span class=n>offsetCoords</span><span class=p>);</span>
    <span class=k>vec4</span> <span class=n>maskB</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>ScaleTextureCoords</span> <span class=o>-</span> <span class=n>offsetCoords</span><span class=p>);</span>
    <span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>ScaleTextureCoords</span><span class=p>);</span>
    <span class=c1>// 分别提前 3 个偏移后的颜色</span>
    <span class=n>gl_FragColor</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>maskR</span><span class=p>.</span><span class=n>r</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>g</span><span class=p>,</span> <span class=n>maskB</span><span class=p>.</span><span class=n>b</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>a</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h4 id=闪白><a href=#闪白 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>闪白</h4><p><img src=https://w-md.imzsy.design/image-20200818200425164.png alt=image-20200818200425164></p><p><strong>原理</strong></p><p>叠加一个白色层，然后白色层的透明度随着时间不断地变化</p><p><strong>着色器代码</strong></p><p>参考「灵魂出窍」的列子，对两个层实现叠加，这里无非是创建了一个白色层 <code>whiteMask</code>，再根据混合方程式进行混合</p><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>precision</span> <span class=k>highp</span> <span class=k>float</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>sampler2D</span> <span class=n>inputImageTexture</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>const</span> <span class=k>float</span> <span class=n>PI</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>0.6</span><span class=p>;</span>
    
    <span class=k>float</span> <span class=n>time</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span><span class=p>);</span>
    
    <span class=k>vec4</span> <span class=n>whiteMask</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
    <span class=k>float</span> <span class=n>amplitude</span> <span class=o>=</span> <span class=n>abs</span><span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=n>time</span> <span class=o>*</span> <span class=p>(</span><span class=n>PI</span> <span class=o>/</span> <span class=n>duration</span><span class=p>)));</span>
    
    <span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>textureCoordinate</span><span class=p>);</span>
    
    <span class=n>gl_FragColor</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>amplitude</span><span class=p>)</span> <span class=o>+</span> <span class=n>whiteMask</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=毛刺><a href=#毛刺 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>毛刺</h4><p><img src=https://w-md.imzsy.design/image-20200819113031611.png alt=image-20200819113031611></p><p><strong>原理</strong></p><p>撕裂 + 微弱的颜色偏移。</p><p><strong>撕裂</strong></p><p>让每一行像素随机偏移<code>[-1, 1]</code>的距离（这里的 <code>-1 ~ 1</code> 是对于纹理坐标来说的）， 但是如果整个画面都偏移比较大的值，那可能都看不出原来图像的样子。</p><p><strong>设定一个阈值，小于这个阈值才进行偏移，超过这个阈值则乘上一个缩小系数</strong></p><p><strong>着色器代码</strong></p><ul><li><p>像素随机偏移值</p><p><img src=https://w-md.imzsy.design/image-20200819114922227.png alt=image-20200819114922227></p></li><li><p>纹理坐标 X 的偏移</p><p><img src=https://w-md.imzsy.design/image-20200819115012832.png alt=image-20200819115012832></p></li></ul><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>precision</span> <span class=k>highp</span> <span class=k>float</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>sampler2D</span> <span class=n>inputImageTexture</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>const</span> <span class=k>float</span> <span class=n>PI</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>
<span class=c1>// 噪声函数，伪随机函数，本质是一个 Hash 函数</span>
<span class=k>float</span> <span class=n>rand</span><span class=p>(</span><span class=k>float</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// fract(x)返回x的小数部分</span>
    <span class=c1>// 返回 sin(n) * 43758.5453123</span>
    <span class=c1>// sin(n) * 极大值，带小数点，想要随机数算的比较低，乘的数就必须较大</span>
    <span class=c1>// 如果想得到【0，1】范围的小数值，可以将sin * 1</span>
    <span class=c1>// 如果只保留小数部分，乘以一个极大值</span>
    <span class=k>return</span> <span class=n>fract</span><span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>*</span> <span class=mf>43758.5453123</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
  	<span class=c1>// 最大撕裂值</span>
    <span class=k>float</span> <span class=n>maxJitter</span> <span class=o>=</span> <span class=mf>0.06</span><span class=p>;</span>
  	<span class=c1>// 一个动画周期时长</span>
  	<span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>0.3</span><span class=p>;</span>
  	<span class=c1>// 红色颜色最大偏移值</span>
    <span class=k>float</span> <span class=n>colorROffset</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>;</span>
  	<span class=c1>// 蓝色颜色最大偏移值</span>
    <span class=k>float</span> <span class=n>colorBOffset</span> <span class=o>=</span> <span class=o>-</span><span class=mf>0.025</span><span class=p>;</span>
    <span class=c1>// 当前动画进度</span>
    <span class=k>float</span> <span class=n>time</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span> <span class=o>*</span> <span class=mf>2.0</span><span class=p>);</span>
  	<span class=c1>// 当前的振幅</span>
    <span class=k>float</span> <span class=n>amplitude</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=n>time</span> <span class=o>*</span> <span class=p>(</span><span class=n>PI</span> <span class=o>/</span> <span class=n>duration</span><span class=p>)),</span> <span class=mf>0.0</span><span class=p>);</span>
    <span class=c1>// 像素随机偏移范围[-1,1]</span>
    <span class=k>float</span> <span class=n>jitter</span> <span class=o>=</span> <span class=n>rand</span><span class=p>(</span><span class=n>textureCoordinate</span><span class=p>.</span><span class=n>y</span><span class=p>)</span> <span class=o>*</span> <span class=mf>2.0</span> <span class=o>-</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// -1~1</span>
  	<span class=c1>// 判断是否需要偏移，（jitter &lt; 最大撕裂值 * 当前振幅)</span>
    <span class=k>bool</span> <span class=n>needOffset</span> <span class=o>=</span> <span class=n>abs</span><span class=p>(</span><span class=n>jitter</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>maxJitter</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>;</span>
    <span class=c1>// 根据 needOffset 来计算纹理坐标 x</span>
  	<span class=c1>// needOffset = YES，则撕裂大</span>
    <span class=c1>// needOffset = NO，则撕裂小，需要降低撕裂 = *振幅*非常细微的数</span>
    <span class=k>float</span> <span class=n>textureX</span> <span class=o>=</span> <span class=n>textureCoordinate</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=p>(</span><span class=n>needOffset</span> <span class=o>?</span> <span class=n>jitter</span> <span class=o>:</span> <span class=p>(</span><span class=n>jitter</span> <span class=o>*</span> <span class=n>amplitude</span> <span class=o>*</span> <span class=mf>0.006</span><span class=p>));</span>
    <span class=k>vec2</span> <span class=n>textureCoords</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=n>textureX</span><span class=p>,</span> <span class=n>textureCoordinate</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
  	
  	<span class=c1>// 撕裂后的颜色</span>
    <span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>textureCoords</span><span class=p>);</span>
    <span class=c1>// 颜色偏移：分别获取 R、B 偏移后的颜色值</span>
    <span class=k>vec4</span> <span class=n>maskR</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>textureCoords</span> <span class=o>+</span> <span class=k>vec2</span><span class=p>(</span><span class=n>colorROffset</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>));</span>
    <span class=k>vec4</span> <span class=n>maskB</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>textureCoords</span> <span class=o>+</span> <span class=k>vec2</span><span class=p>(</span><span class=n>colorBOffset</span> <span class=o>*</span> <span class=n>amplitude</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>));</span>
    
    <span class=n>gl_FragColor</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>maskR</span><span class=p>.</span><span class=n>r</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>g</span><span class=p>,</span> <span class=n>maskB</span><span class=p>.</span><span class=n>b</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>a</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>像素随机偏移需要用到随机数，可惜 GLSL 中并没有内置的随机函数。</p><p>这个 <code>float rand(float n)</code> 的实现看上去很神奇，它其实是来自 <a href=https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 target=_blank rel=noopener>这里</a> ，江湖人称「噪声函数」。</p><p>它其实是一个伪随机函数，本质上是一个 Hash 函数。但在这里我们可以把它当成随机函数来使用，它的返回值范围是 <code>0 ~ 1</code>。如果你对这个函数想了解更多的话可以看 <a href=https://xiaoiver.github.io/coding/2018/08/01/%E5%99%AA%E5%A3%B0%E7%9A%84%E8%89%BA%E6%9C%AF.html target=_blank rel=noopener>这里</a> 。</p><h4 id=幻觉><a href=#幻觉 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>幻觉</h4><p><strong>原理</strong></p><p><img src=https://w-md.imzsy.design/image-20200819113810451.png alt=image-20200819113810451></p><p>残影+颜色偏移</p><p><strong>残影</strong></p><p>在移动的过程中，每经过一段时间间隔，根据当前的位置去创建一个新层，并且新层的不透明度随着时间逐渐减弱</p><p><strong>颜色偏移</strong></p><p>图片在移动的过程中是蓝色在前，红色在后，即在移动的过程中，每间隔一段时间，遗失了一部分红色通道的值在原来的位置，并且这部分红色通道的值，随着时间偏移，会逐渐恢复</p><p><strong>着色器代码</strong></p><ul><li><p>getMask 函数，计算在某个时刻图片的具体位置。通过它我们可以每经过一段时间，去生成一个新的层。</p><p><img src=https://w-md.imzsy.design/image-20200819115606231.png alt=image-20200819115606231></p></li><li><p>for循环来累加每一层的每个通道乘上自身的透明度的值，算出最终的颜色值 <code>resultMask</code> 。</p><p><img src=https://w-md.imzsy.design/image-20200819115637726.png alt=image-20200819115637726></p></li></ul><div class=highlight><pre class=chroma><code class=language-glsl data-lang=glsl><span class=k>precision</span> <span class=k>highp</span> <span class=k>float</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>sampler2D</span> <span class=n>inputImageTexture</span><span class=p>;</span>
<span class=k>varying</span> <span class=k>vec2</span> <span class=n>textureCoordinate</span><span class=p>;</span>

<span class=k>uniform</span> <span class=k>float</span> <span class=n>Time</span><span class=p>;</span>

<span class=k>const</span> <span class=k>float</span> <span class=n>PI</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>
<span class=c1>// 一次动画周期时长</span>
<span class=k>const</span> <span class=k>float</span> <span class=n>duration</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>

<span class=c1>// 这个函数可以计算出，在某个时刻图片的具体位置，通过它可以每经过一段时间，去生成一个新的mask</span>
<span class=c1>// 转圈产生幻影的单个像素点的颜色值</span>
<span class=k>vec4</span> <span class=n>getMask</span><span class=p>(</span><span class=k>float</span> <span class=n>time</span><span class=p>,</span> <span class=k>vec2</span> <span class=n>textureCoords</span><span class=p>,</span> <span class=k>float</span> <span class=n>padding</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 圆心坐标</span>
    <span class=k>vec2</span> <span class=n>translation</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=n>time</span> <span class=o>*</span> <span class=p>(</span><span class=n>PI</span> <span class=o>*</span> <span class=mf>2.0</span> <span class=o>/</span> <span class=n>duration</span><span class=p>)),</span>
                            <span class=n>cos</span><span class=p>(</span><span class=n>time</span> <span class=o>*</span> <span class=p>(</span><span class=n>PI</span> <span class=o>*</span> <span class=mf>2.0</span> <span class=o>/</span> <span class=n>duration</span><span class=p>)));</span>
  	<span class=c1>// 新的纹理坐标 = 原始纹理坐标 + 偏移量 * 圆周坐标（新的图层与图层之间是有间距的，所以需要偏移）</span>
    <span class=k>vec2</span> <span class=n>translationTextureCoords</span> <span class=o>=</span> <span class=n>textureCoords</span> <span class=o>+</span> <span class=n>padding</span> <span class=o>*</span> <span class=n>translation</span><span class=p>;</span>
    <span class=c1>// 根据新的纹理坐标获取新图层的纹素</span>
  	<span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>inputImageTexture</span><span class=p>,</span> <span class=n>translationTextureCoords</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>mask</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// 这个函数可以计算出，某个时刻创建的层，在当前时刻的透明度</span>
<span class=k>float</span> <span class=n>maskAlphaProgress</span><span class=p>(</span><span class=k>float</span> <span class=n>currentTime</span><span class=p>,</span> <span class=k>float</span> <span class=n>hideTime</span><span class=p>,</span> <span class=k>float</span> <span class=n>startTime</span><span class=p>)</span> <span class=p>{</span>
  	<span class=c1>// mod（时长+持续时间 - 开始时间，时长）得到一个周期内的time</span>
    <span class=k>float</span> <span class=n>time</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>duration</span> <span class=o>+</span> <span class=n>currentTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=p>,</span> <span class=n>duration</span><span class=p>);</span>
    <span class=c1>// 如果小于0.9，返回time，反之，返回0.9</span>
    <span class=k>return</span> <span class=n>min</span><span class=p>(</span><span class=n>time</span><span class=p>,</span> <span class=n>hideTime</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>void</span> <span class=n>main</span> <span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 将传入的时间戳转换到一个周期内，time的范围是【0，2】</span>
    <span class=c1>// 获得时间周期</span>
    <span class=k>float</span> <span class=n>time</span> <span class=o>=</span> <span class=n>mod</span><span class=p>(</span><span class=n>Time</span><span class=p>,</span> <span class=n>duration</span><span class=p>);</span>
    <span class=c1>// 放大后的倍数</span>
    <span class=k>float</span> <span class=n>scale</span> <span class=o>=</span> <span class=mf>1.2</span><span class=p>;</span>
    <span class=c1>// 偏移量 = 0.083</span>
    <span class=k>float</span> <span class=n>padding</span> <span class=o>=</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>scale</span><span class=p>);</span>
    <span class=c1>// 放大后的纹理坐标</span>
    <span class=k>vec2</span> <span class=n>textureCoords</span> <span class=o>=</span> <span class=k>vec2</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>textureCoordinate</span> <span class=o>-</span> <span class=k>vec2</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>))</span> <span class=o>/</span> <span class=n>scale</span><span class=p>;</span>
    <span class=c1>// 新建层的隐藏时间 即新建层什么时候隐藏 </span>
    <span class=k>float</span> <span class=n>hideTime</span> <span class=o>=</span> <span class=mf>0.9</span><span class=p>;</span>
    <span class=c1>// 时间间隔：隔0.2s创建一个新层</span>
    <span class=k>float</span> <span class=n>timeGap</span> <span class=o>=</span> <span class=mf>0.2</span><span class=p>;</span>
    <span class=c1>// 注意：只保留了红色的透明的通道值，因为幻觉效果残留红色</span>
    <span class=c1>// 幻影残留数据</span>
    <span class=k>float</span> <span class=n>maxAlphaR</span> <span class=o>=</span> <span class=mf>0.5</span><span class=p>;</span> <span class=c1>// max R</span>
    <span class=k>float</span> <span class=n>maxAlphaG</span> <span class=o>=</span> <span class=mf>0.05</span><span class=p>;</span> <span class=c1>// max G</span>
    <span class=k>float</span> <span class=n>maxAlphaB</span> <span class=o>=</span> <span class=mf>0.05</span><span class=p>;</span> <span class=c1>// max B</span>
        
  	<span class=c1>// 获取新的图层的坐标，需要传入时间、纹理坐标、偏移量</span>
    <span class=k>vec4</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>getMask</span><span class=p>(</span><span class=n>time</span><span class=p>,</span> <span class=n>textureCoords</span><span class=p>,</span> <span class=n>padding</span><span class=p>);</span>
    <span class=k>float</span> <span class=n>alphaR</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// R</span>
    <span class=k>float</span> <span class=n>alphaG</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// G</span>
    <span class=k>float</span> <span class=n>alphaB</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// B</span>
    
    <span class=c1>// 最终图层颜色：初始化</span>
    <span class=k>vec4</span> <span class=n>resultMask</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=mo>0</span><span class=p>,</span> <span class=mo>0</span><span class=p>,</span> <span class=mo>0</span><span class=p>,</span> <span class=mo>0</span><span class=p>);</span>
    
   	<span class=c1>// 循环：每一层循环都会得到新的图层的颜色，即幻影颜色</span>
    <span class=c1>// 一次循环只是计算一个像素点的纹素，需要在真机运行。模拟器会卡，主要是模拟器上是CPU模拟GPU的</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>float</span> <span class=n>f</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span> <span class=n>f</span> <span class=o>&lt;</span> <span class=n>duration</span><span class=p>;</span> <span class=n>f</span> <span class=o>+=</span> <span class=n>timeGap</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>float</span> <span class=n>tmpTime</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
        <span class=c1>// 获取到【0，2】s内所获取的运动后的纹理坐标</span>
        <span class=c1>// 获得幻影当前时间的颜色值</span>
        <span class=k>vec4</span> <span class=n>tmpMask</span> <span class=o>=</span> <span class=n>getMask</span><span class=p>(</span><span class=n>tmpTime</span><span class=p>,</span> <span class=n>textureCoords</span><span class=p>,</span> <span class=n>padding</span><span class=p>);</span>
      
        <span class=c1>// 某个时刻创建的层，在当前时刻的红绿蓝的透明度</span>
        <span class=c1>// 临时的透明度 = 根据时间推移RGB的透明度发生变化</span>
        <span class=c1>// 获得临时的红绿蓝透明度</span>
        <span class=k>float</span> <span class=n>tmpAlphaR</span> <span class=o>=</span> <span class=n>maxAlphaR</span> <span class=o>-</span> <span class=n>maxAlphaR</span> <span class=o>*</span> <span class=n>maskAlphaProgress</span><span class=p>(</span><span class=n>time</span><span class=p>,</span> <span class=n>hideTime</span><span class=p>,</span> <span class=n>tmpTime</span><span class=p>)</span> <span class=o>/</span> <span class=n>hideTime</span><span class=p>;</span>
        <span class=k>float</span> <span class=n>tmpAlphaG</span> <span class=o>=</span> <span class=n>maxAlphaG</span> <span class=o>-</span> <span class=n>maxAlphaG</span> <span class=o>*</span> <span class=n>maskAlphaProgress</span><span class=p>(</span><span class=n>time</span><span class=p>,</span> <span class=n>hideTime</span><span class=p>,</span> <span class=n>tmpTime</span><span class=p>)</span> <span class=o>/</span> <span class=n>hideTime</span><span class=p>;</span>
        <span class=k>float</span> <span class=n>tmpAlphaB</span> <span class=o>=</span> <span class=n>maxAlphaB</span> <span class=o>-</span> <span class=n>maxAlphaB</span> <span class=o>*</span> <span class=n>maskAlphaProgress</span><span class=p>(</span><span class=n>time</span><span class=p>,</span> <span class=n>hideTime</span><span class=p>,</span> <span class=n>tmpTime</span><span class=p>)</span> <span class=o>/</span> <span class=n>hideTime</span><span class=p>;</span>

        <span class=c1>// 累计每一层临时RGB * RGB的临时透明度</span>
        <span class=c1>// 结果 += 临时颜色 * 透明度，即刚产生的图层的颜色</span>
        <span class=n>resultMask</span> <span class=o>+=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>tmpMask</span><span class=p>.</span><span class=n>r</span> <span class=o>*</span> <span class=n>tmpAlphaR</span><span class=p>,</span>
                           <span class=n>tmpMask</span><span class=p>.</span><span class=n>g</span> <span class=o>*</span> <span class=n>tmpAlphaG</span><span class=p>,</span>
                           <span class=n>tmpMask</span><span class=p>.</span><span class=n>b</span> <span class=o>*</span> <span class=n>tmpAlphaB</span><span class=p>,</span>
                           <span class=mf>1.0</span><span class=p>);</span>
        <span class=c1>// 透明度递减</span>
        <span class=n>alphaR</span> <span class=o>-=</span> <span class=n>tmpAlphaR</span><span class=p>;</span>
        <span class=n>alphaG</span> <span class=o>-=</span> <span class=n>tmpAlphaG</span><span class=p>;</span>
        <span class=n>alphaB</span> <span class=o>-=</span> <span class=n>tmpAlphaB</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 最终颜色 += 原始纹理的RGB * 透明度</span>
    <span class=n>resultMask</span> <span class=o>+=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>mask</span><span class=p>.</span><span class=n>r</span> <span class=o>*</span> <span class=n>alphaR</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>g</span> <span class=o>*</span> <span class=n>alphaG</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>b</span> <span class=o>*</span> <span class=n>alphaB</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>

    <span class=n>gl_FragColor</span> <span class=o>=</span> <span class=n>resultMask</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><blockquote><p><strong>注：</strong> 在 iOS 的模拟器上，只能用 CPU 来模拟 GPU 的功能。所以在模拟器上运行上面的代码时，可能会十分卡顿。尤其是最后这个效果，由于计算量太大，亲测模拟器显示不出来。因此如果要跑代码，最好使用真机运行。</p></blockquote><p>文中着色器<a href=https://github.com/dev-jw/Learning-OpenGL-ES target=_blank rel=noopener>代码获取</a></p><h3 id=参考><a href=#参考 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>参考</h3><p><a href=http://www.lymanli.com/2019/04/05/ios-opengles-filter/ target=_blank rel=noopener>在 iOS 中使用 GLSL 实现抖音特效</a></p><p><a href=https://www.jianshu.com/p/5bb7f2a0da90 target=_blank rel=noopener>当一个 Android 开发玩抖音玩疯了之后(二)</a></p><p><a href=https://www.jianshu.com/p/795193bde5fa target=_blank rel=noopener>动效滤镜</a></p></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a>
<a href=../tags/opengles/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>OpenGLES</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>