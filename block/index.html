<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-Block分析 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="Block在日常开发中的使用，相信每一位iOS开发者都是非常熟悉，那么关于block……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/block/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-11-09T20:12:50+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/block/","name":"iOS底层原理探索-Block分析","description":"Block在日常开发中的使用，相信每一位iOS开发者都是非常熟悉，那么关于block……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-Block分析"><meta property="og:description" content="Block在日常开发中的使用，相信每一位iOS开发者都是非常熟悉，那么关于block……"><meta property="og:url" content="https://dev.hjw.best/block/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-Block分析</h1><div class=post-meta><time datetime=2020-11-09T20:12:50+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-11-09</time></div><div class="post-body e-content"><p><code>Block</code>在日常开发中的使用，相信每一位iOS开发者都是非常熟悉，那么关于<code>block</code>的下面几个问题，是否已经掌握，能够快速给出答案呢</p><ul><li><code>Block</code>的分类有哪些？</li><li>循环引用的产生与解决？</li><li><code>Block</code>本质是什么？</li><li><code>Block</code>是怎么捕获外界变量的？</li><li><code>__block</code>的底层原理是什么？</li></ul><h3 id=block定义与分类><a href=#block定义与分类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>block定义与分类</h3><p><strong>定义</strong></p><p>带有自动变量（局部变量）的匿名函数叫做<code>Block</code>，又叫做<code>匿名函数</code>、<code>代码块</code></p><p>不同语言中的叫法：</p><div class=table-container><table><thead><tr><th>程序语言</th><th>Block的名称</th></tr></thead><tbody><tr><td>C</td><td>Blcok</td></tr><tr><td>Ruby</td><td>Blcok</td></tr><tr><td>JS</td><td>Anonymous function</td></tr><tr><td>Java</td><td>Lambda</td></tr><tr><td>Python</td><td>Lambda</td></tr></tbody></table></div><p><strong>分类</strong></p><p>根据<code>Block</code>存储的内存区域不同，分为：全局<code>Block</code>、栈<code>Block</code>、堆<code>Block</code>三种形式</p><ul><li><p>全局 Block：<code>__NSGlobalBlock__</code>，存储在<strong>已初始化数据(.data)区</strong></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;block&#34;</span><span class=p>);</span>
<span class=p>};</span>
<span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;block:%@&#34;</span><span class=p>,</span> <span class=n>block</span><span class=p>);</span>
  
<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=nl>block</span><span class=p>:</span> <span class=o>&lt;</span><span class=nl>__NSGlobalBlock__</span><span class=p>:</span> <span class=mh>0x10b39f088</span><span class=o>&gt;</span>
</code></pre></div></li><li><p>栈 Block：<code>__NSMallocBlock__</code>，存储在<strong>栈(stack)区</strong></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=c1>//    int a = 0;
</span><span class=c1>//    NSLog(@&#34;%@&#34;, ^{
</span><span class=c1>//        NSLog(@&#34;%d&#34;, a);
</span><span class=c1>//    });
</span><span class=c1>// iOS14之前，输出的是栈 Block
</span><span class=c1>// 经过 iOS14 优化，这一块已经变为堆 block
</span><span class=c1></span>  
<span class=c1>// iOS14之后，栈 block
</span><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=k>__weak</span> <span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%d&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
<span class=p>};</span>
<span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;block: %@&#34;</span><span class=p>,</span> <span class=n>block</span><span class=p>);</span>
  
<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=nl>block</span><span class=p>:</span> <span class=o>&lt;</span><span class=nl>__NSStackBlock__</span><span class=p>:</span> <span class=mh>0x7ffee9324558</span><span class=o>&gt;</span>
</code></pre></div></li><li><p>堆block：<code>__NSMallocBlock__</code>，存储在<strong>堆(heap)区</strong></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%d&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
<span class=p>};</span>
  
<span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;block: %@&#34;</span><span class=p>,</span> <span class=n>block</span><span class=p>);</span>
  
<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=nl>block</span><span class=p>:</span> <span class=o>&lt;</span><span class=nl>__NSMallocBlock__</span><span class=p>:</span> <span class=mh>0x6000038a8ed0</span><span class=o>&gt;</span>
</code></pre></div></li></ul><p>总结：</p><ul><li><p>不捕获外界变量的 block 是全局 Block：<code>__NSGlobalBlock__</code></p></li><li><p>捕获外界变量的 block</p><ul><li><p><strong>弱引用修饰</strong>是栈 block：<code>__NSMallocBlock__</code></p></li><li><p><strong>强引用修饰</strong>是堆 block：<code>__NSMallocBlock__</code></p></li></ul></li></ul><p>除此之外，还有三种系统级别的block类型（能在<a href=https://opensource.apple.com/tarballs/libclosure/ target=_blank rel=noopener>libclosure</a>源码中看到）</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteStackBlock</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteMallocBlock</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteAutoBlock</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteFinalizingBlock</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteGlobalBlock</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>*</span> <span class=n>_NSConcreteWeakBlockVariable</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
</code></pre></div><h3 id=block循环引用><a href=#block循环引用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>block循环引用</h3><p><strong>循环引用的分析</strong></p><p>循环引用经典案例：</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=nb>self</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;block&#34;</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=nb>self</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
<span class=p>};</span>
</code></pre></div><p>编译器会发出警告</p><pre><code>Capturing 'self' strongly in this block is likely to lead to a retain cycle
</code></pre><p>产生循环引用问题的关键所在是什么呢？</p><p>通过代码，可以发现：</p><ul><li><code>self</code>持有<code>block</code></li><li><code>block</code>持有<code>self</code>(self.name)</li></ul><p>这样也就是 <code>self->block->self</code> 的循环引用</p><p>循环引用会导致什么样的后果呢？</p><p>通常，正常释放时：<strong>对象A</strong>发送<code>dealloc</code>信号让<strong>对象B</strong> 进行<code>dealloc</code></p><p><img src=https://w-md.imzsy.design/image-20201116152542511.png alt=image-20201116152542511></p><p>当存在循环引用时：<strong>对象A</strong>与<strong>对象B</strong>相互引用，引用计数不能减为 0，<code>dealloc</code>就不会被调用</p><p><img src=https://w-md.imzsy.design/image-20201116153042577.png alt=image-20201116153042577></p><p><strong>循环引用的解决方法</strong></p><ul><li><p>强弱共舞</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>__weak</span> <span class=nf>typeof</span><span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=n>weakSelf</span> <span class=o>=</span> <span class=nb>self</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;block&#34;</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=n>weakSelf</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
<span class=p>};</span>
</code></pre></div><p>使用<strong>中介者模式</strong> <code>__weak typeof(self) weakSelf = self;</code> 将循环引用改为：<code>weakself -> self -> block -> weakself</code></p><p>看起来还是一个「引用环」，但是 <code>weakSelf -> self</code> 是弱引用——引用计数不处理，使用 <code>Weak表</code>管理，所以在析构时，<code>self</code> 能够调用 <code>dealloc</code></p><blockquote><p>但这并不是最好的解决方案，仍然存在着问题</p></blockquote><p>在 <code>block</code> 内部存在<strong>延时函数</strong></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>__weak</span> <span class=nf>typeof</span><span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=n>weakSelf</span> <span class=o>=</span> <span class=nb>self</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;block&#34;</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>dispatch_after</span><span class=p>(</span><span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span>
                                 <span class=p>(</span><span class=n>int64_t</span><span class=p>)(</span><span class=mf>3.0</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>)),</span>
                   <span class=n>dispatch_get_main_queue</span><span class=p>(),</span>
                   <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=n>weakSelf</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>};</span>
</code></pre></div><p>如果在调用 <code>block</code> 之后，释放了 <code>self</code>，那么 3 秒后 <code>weakSelf</code> 指向的 <code>self</code> 已经变为 nil，那么打印结果也只能是 <code>null</code></p><p>因此，就需要加入<strong>强引用</strong></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>__weak</span> <span class=nf>typeof</span><span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=n>weakSelf</span> <span class=o>=</span> <span class=nb>self</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;block&#34;</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=k>__strong</span> <span class=k>typeof</span><span class=p>(</span><span class=n>weakSelf</span><span class=p>)</span> <span class=n>strongSelf</span> <span class=o>=</span> <span class=n>weakSelf</span><span class=p>;</span>
    <span class=n>dispatch_after</span><span class=p>(</span><span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span>
                                 <span class=p>(</span><span class=n>int64_t</span><span class=p>)(</span><span class=mf>3.0</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>)),</span>
                   <span class=n>dispatch_get_main_queue</span><span class=p>(),</span>
                   <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=n>strongSelf</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>};</span>
</code></pre></div><p>通过再加一层临时的强引用<code>__strong typeof(weakSelf) strongSelf = weakSelf</code>，将引用链改为：<code>strongSelf -> weakself -> self -> block -> strongSelf</code></p><p>看起来仍然是一个循环引用，但实际上<code>strongSelf</code>是临时变量，当 block 作用域结束后就会释放，从而会打破循环引用，进行正常释放</p></li><li><p>引入其他中间者</p><p>既然有「自动置空」，那么也可以「手动置空」</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>__block</span> <span class=n>ViewController</span> <span class=o>*</span><span class=n>vc</span> <span class=o>=</span> <span class=nb>self</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;block&#34;</span><span class=p>;</span>
<span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>dispatch_after</span><span class=p>(</span><span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span>
                                 <span class=p>(</span><span class=n>int64_t</span><span class=p>)(</span><span class=mf>3.0</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>)),</span>
                   <span class=n>dispatch_get_main_queue</span><span class=p>(),</span>
                   <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=n>vc</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
        <span class=n>vc</span> <span class=o>=</span> <span class=nb>nil</span><span class=p>;</span>
    <span class=p>});</span>
<span class=p>};</span>
</code></pre></div><p>这也是通过<strong>中介者模式</strong>打破循环引用的方式——使用 <code>vc</code> 作为中介者代替 <code>self</code></p><p>此时的引用链为：<code>vc -> self -> block -> vc</code>（vc在用完之后，手动置空）</p></li><li><p>不引用</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=nb>self</span><span class=p>.</span><span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>(</span><span class=n>ViewController</span> <span class=o>*</span><span class=n>vc</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>dispatch_after</span><span class=p>(</span><span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span>
                                 <span class=p>(</span><span class=n>int64_t</span><span class=p>)(</span><span class=mf>3.0</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>)),</span>
                   <span class=n>dispatch_get_main_queue</span><span class=p>(),</span>
                   <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%@&#34;</span><span class=p>,</span> <span class=n>vc</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>};</span>
</code></pre></div><p>将使用<code>当前 vc</code>作为参数传入 <code>block</code> 时，就不会出现持有的情况，同时还能使用 <code>self</code> 的属性，避免循环引用</p></li></ul><p><strong>补充说明</strong></p><ul><li><p><code>Masonry</code>中是否存在循环引用？</p><p><code>Masonry</code>使用的 block 是当作参数传递的，即使 block 内部持有 self，设置布局的 view 持有 block，但是 block 不持有 view。</p><p>当 block 执行完后就会释放，self 的引用计数-1，所以 block 也不会持有 self，所以不会产生循环引用</p></li><li><p><code>[UIView animateWithDuration: animations:]</code>中是否存在循环引用？</p><p><code>UIView动画</code>是类方法，不被 self 持有（即 self 持有 view，但 view 没有实例化），所以不会循环引用</p></li></ul><h3 id=block底层分析><a href=#block底层分析 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>block底层分析</h3><p><strong>本质</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&#34;stdio.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
    <span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Block - %d&#34;</span><span class=p>,</span><span class=n>a</span><span class=p>);</span>
    <span class=p>};</span>
    <span class=n>block</span><span class=p>();</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>通过 <code>clang</code> ，使用 <code>clang -rewrite-objc main.c -o main.cpp</code>， 将上面代码编译成 <code>c++</code> 文件，查看底层实现</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
    <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=o>&amp;</span><span class=n>__main_block_impl_0</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>__main_block_func_0</span><span class=p>,</span> 
                                                           <span class=o>&amp;</span><span class=n>__main_block_desc_0_DATA</span><span class=p>,</span> 
                                                           <span class=n>a</span><span class=p>));</span>
    <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>))((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>FuncPtr</span><span class=p>)((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>block声明中，不难发现为<code>__main_block_impl_0</code>类型，这是 C++ 中的构造函数</p><p><code>__main_block_impl_0</code>的定义</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>__main_block_impl_0</span> <span class=p>{</span>
  <span class=k>struct</span> <span class=nc>__block_impl</span> <span class=n>impl</span><span class=p>;</span>
  <span class=k>struct</span> <span class=nc>__main_block_desc_0</span><span class=o>*</span> <span class=n>Desc</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
  <span class=n>__main_block_impl_0</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>__main_block_desc_0</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>_a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>a</span><span class=p>(</span><span class=n>_a</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>impl</span><span class=p>.</span><span class=n>isa</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_NSConcreteStackBlock</span><span class=p>;</span>
    <span class=n>impl</span><span class=p>.</span><span class=n>Flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
    <span class=n>impl</span><span class=p>.</span><span class=n>FuncPtr</span> <span class=o>=</span> <span class=n>fp</span><span class=p>;</span>
    <span class=n>Desc</span> <span class=o>=</span> <span class=n>desc</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>因此，<code>block</code> 的本质是个<code>__main_block_impl_0</code>的结构体对象，这也是可以用<code>%@</code>打印 block 的原因</p><p>构造函数正是将<code>block</code>具体实现<code>__main_block_func_0</code>，作为参数 <code>fp</code> 传递并保存到了 <code>impl</code></p><p><strong>为什么需要Block()</strong></p><p><code>((**void** (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);</code></p><p>函数调用正是调用保存在 <code>impl</code> 中的 <code>FuncPtr</code></p><p>这就是说明了，block 声明只是将 block 实现进行保存，函数实现则需要自行调用</p><p><strong>自动捕获外界变量</strong></p><p>在上面的例子中，变量 a 在底层仍然是 <strong>int</strong>类型，并作为<code>__main_block_impl_0</code>构造函数的参数，并且保存在<code>__main_block_impl_0</code>结构体的成员变量 a 中</p><p>对于block函数实现：<code>__main_block_func_0</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>__main_block_func_0</span><span class=p>(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span> <span class=o>*</span><span class=n>__cself</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>__cself</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>;</span> <span class=c1>// bound by copy
</span><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Block - %d&#34;</span><span class=p>,</span><span class=n>a</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>不难看出：</p><ul><li><code>__cself</code>即<code>__main_block_impl_0</code>的指针，block 本身</li><li><code>int a = __cself->a</code>即 <code>int a = block->a</code></li><li>由于 a 是一个成员变量，所以只是<strong>值拷贝</strong></li></ul><p>由于是值拷贝，不难直接对捕获的外界变量进行操作，如<code>a++</code></p><p><strong>__block 修饰外界变量</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>__block</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
    <span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Block - %d&#34;</span><span class=p>,</span><span class=n>a</span><span class=p>);</span>
    <span class=p>};</span>
    <span class=n>block</span><span class=p>();</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>在底层被编译为：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>__attribute__</span><span class=p>((</span><span class=n>__blocks__</span><span class=p>(</span><span class=n>byref</span><span class=p>)))</span> <span class=n>__Block_byref_a_0</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=mi>0</span><span class=p>,(</span><span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>__Block_byref_a_0</span><span class=p>),</span> <span class=mi>10</span><span class=p>};</span>
    <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=o>&amp;</span><span class=n>__main_block_impl_0</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>__main_block_func_0</span><span class=p>,</span> 
                                                           <span class=o>&amp;</span><span class=n>__main_block_desc_0_DATA</span><span class=p>,</span> 
                                                           <span class=p>(</span><span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> 
                                                           <span class=mi>570425344</span><span class=p>));</span>
    <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>))((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>FuncPtr</span><span class=p>)((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>此时的<code>__main_block_impl_0</code>结构体为：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>__main_block_impl_0</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>__block_impl</span> <span class=n>impl</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>__main_block_desc_0</span><span class=o>*</span> <span class=n>Desc</span><span class=p>;</span>
    <span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span> <span class=c1>// by ref
</span><span class=c1></span>    <span class=n>__main_block_impl_0</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>__main_block_desc_0</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=n>_a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>a</span><span class=p>(</span><span class=n>_a</span><span class=o>-&gt;</span><span class=n>__forwarding</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>impl</span><span class=p>.</span><span class=n>isa</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_NSConcreteStackBlock</span><span class=p>;</span>
        <span class=n>impl</span><span class=p>.</span><span class=n>Flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
        <span class=n>impl</span><span class=p>.</span><span class=n>FuncPtr</span> <span class=o>=</span> <span class=n>fp</span><span class=p>;</span>
        <span class=n>Desc</span> <span class=o>=</span> <span class=n>desc</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>而函数实现<code>__main_block_func_0</code>为：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>__main_block_func_0</span><span class=p>(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span> <span class=o>*</span><span class=n>__cself</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>__cself</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>;</span> <span class=c1>// bound by ref
</span><span class=c1></span>    
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Block - %d&#34;</span><span class=p>,(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>__forwarding</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div><p><code>__Block_byref_a_0</code>结构体：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>__Block_byref_a_0</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>__isa</span><span class=p>;</span>
    <span class=n>__Block_byref_a_0</span> <span class=o>*</span><span class=n>__forwarding</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>__flags</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>__size</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p><code>__block</code>修饰的变量，通过编译在底层会生成<code>__Block_byref_a_0</code>的结构体，且将结构体的指针地址作为<code>__main_block_impl_0</code>构造函数的参数，被保存到<code>__main_block_impl_0</code>结构体中，这正是指针拷贝</p><h3 id=block底层源码分析><a href=#block底层源码分析 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>block底层源码分析</h3><p>借助汇编调用堆栈，不难发现运行时的 block 会进入<code>objc_retainBlock</code>，进而走到<code>_Block_copy</code>函数</p><blockquote><p>借助<a href=https://opensource.apple.com/source/libclosure/libclosure-74/ target=_blank rel=noopener>libclosure-74</a>源码，配置一份可编译调试的源码，方便探究 <code>Block</code></p></blockquote><p>Block结构体<code>Block_layout</code>（等同于 <code>clang</code> 编译出来的<code>__Block_byref_a_0</code>）</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cp>#define BLOCK_DESCRIPTOR_1 1
</span><span class=cp></span><span class=k>struct</span> <span class=nc>Block_descriptor_1</span> <span class=p>{</span>
    <span class=n>uintptr_t</span> <span class=n>reserved</span><span class=p>;</span>
    <span class=n>uintptr_t</span> <span class=n>size</span><span class=p>;</span>
<span class=p>};</span>

<span class=cp>#define BLOCK_DESCRIPTOR_2 1
</span><span class=cp></span><span class=k>struct</span> <span class=nc>Block_descriptor_2</span> <span class=p>{</span>
    <span class=c1>// requires BLOCK_HAS_COPY_DISPOSE
</span><span class=c1></span>    <span class=n>BlockCopyFunction</span> <span class=n>copy</span><span class=p>;</span>
    <span class=n>BlockDisposeFunction</span> <span class=n>dispose</span><span class=p>;</span>
<span class=p>};</span>

<span class=cp>#define BLOCK_DESCRIPTOR_3 1
</span><span class=cp></span><span class=k>struct</span> <span class=nc>Block_descriptor_3</span> <span class=p>{</span>
    <span class=c1>// requires BLOCK_HAS_SIGNATURE
</span><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>signature</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>layout</span><span class=p>;</span>     <span class=c1>// contents depend on BLOCK_HAS_EXTENDED_LAYOUT
</span><span class=c1></span><span class=p>};</span>

<span class=c1>// Block 结构体
</span><span class=c1></span><span class=k>struct</span> <span class=nc>Block_layout</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>isa</span><span class=p>;</span>
    <span class=k>volatile</span> <span class=kt>int32_t</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// contains ref count
</span><span class=c1></span>    <span class=kt>int32_t</span> <span class=n>reserved</span><span class=p>;</span>
    <span class=n>BlockInvokeFunction</span> <span class=n>invoke</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>Block_descriptor_1</span> <span class=o>*</span><span class=n>descriptor</span><span class=p>;</span>
    <span class=c1>// imported variables
</span><span class=c1></span><span class=p>};</span>
</code></pre></div><p>其中<code>Block_layout</code>是基础 block 结构</p><ul><li><p><code>isa</code>：表明 block 的类型</p></li><li><p><code>flags</code>：标识符，记录了一些信息， 类似 isa 结构中的位域</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>enum</span> <span class=p>{</span>
    <span class=n>BLOCK_DEALLOCATING</span> <span class=o>=</span>      <span class=p>(</span><span class=mh>0x0001</span><span class=p>),</span>  <span class=c1>// runtime
</span><span class=c1></span>    <span class=n>BLOCK_REFCOUNT_MASK</span> <span class=o>=</span>     <span class=p>(</span><span class=mh>0xfffe</span><span class=p>),</span>  <span class=c1>// runtime
</span><span class=c1></span>    <span class=n>BLOCK_NEEDS_FREE</span> <span class=o>=</span>        <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span><span class=p>),</span> <span class=c1>// runtime
</span><span class=c1></span>    <span class=n>BLOCK_HAS_COPY_DISPOSE</span> <span class=o>=</span>  <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>25</span><span class=p>),</span> <span class=c1>// compiler
</span><span class=c1></span>    <span class=n>BLOCK_HAS_CTOR</span> <span class=o>=</span>          <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>26</span><span class=p>),</span> <span class=c1>// compiler: helpers have C++ code
</span><span class=c1></span>    <span class=n>BLOCK_IS_GC</span> <span class=o>=</span>             <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>27</span><span class=p>),</span> <span class=c1>// runtime
</span><span class=c1></span>    <span class=n>BLOCK_IS_GLOBAL</span> <span class=o>=</span>         <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>28</span><span class=p>),</span> <span class=c1>// compiler
</span><span class=c1></span>    <span class=n>BLOCK_USE_STRET</span> <span class=o>=</span>         <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>29</span><span class=p>),</span> <span class=c1>// compiler: undefined if !BLOCK_HAS_SIGNATURE
</span><span class=c1></span>    <span class=n>BLOCK_HAS_SIGNATURE</span>  <span class=o>=</span>    <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>30</span><span class=p>),</span> <span class=c1>// compiler
</span><span class=c1></span>    <span class=n>BLOCK_HAS_EXTENDED_LAYOUT</span><span class=o>=</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>31</span><span class=p>)</span>  <span class=c1>// compiler
</span><span class=c1></span><span class=p>};</span>
  
<span class=o>-</span> <span class=err>第</span><span class=mi>1</span><span class=err>位：释放标记，一般常用</span><span class=n>BLOCK_NEEDS_FREE做位与操作</span><span class=err>，一同传入</span><span class=n>flags</span><span class=err>，告知该</span><span class=n>block可释放</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>16</span><span class=err>位：存储引用计数的值，是一个可选参数</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>24</span><span class=err>位：低</span><span class=mi>16</span><span class=err>位是否有效的标志，程序根据它来决定是否增加或减少引用计数位的值</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>25</span><span class=err>位：是否拥有拷贝辅助函数；决定</span> <span class=n>Block_descriptor_2</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>26</span><span class=err>位：是否拥有</span><span class=n>block析构函数</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>27</span><span class=err>位：标志是否有垃圾回收</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>28</span><span class=err>位：标志是否是全局</span><span class=n>block</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>29</span><span class=err>位：与</span><span class=n>BLOCK_USE_START相对</span><span class=err>，判断当前</span><span class=n>block是否拥有一个签名</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>30</span><span class=err>位：标志是否有签名</span>
<span class=o>-</span> <span class=err>第</span><span class=mi>31</span><span class=err>位：标志是否有拓展，决定</span> <span class=n>Block_descriptor_3</span>
</code></pre></div></li><li><p><code>invoke</code>：是一个函数指针，指向 block 的执行代码</p></li><li><p><code>descriptor</code>：block 的附加信息，比如保留变量数、block 的大小、进行 <code>copy</code> 会 <code>dispose</code> 的辅助函数指针</p><ul><li><code>Block_descriptor_1</code>是必定存在的信息</li><li>而部分block则拥有<code>Block_descriptor_2</code>和<code>Block_descriptor_3</code>结构</li></ul></li></ul><p>对于部分 block 拥有<code>Block_descriptor_2</code>和<code>Block_descriptor_3</code>结构，是根据其构造函数所体现的</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// copy 和 dispose 函数
</span><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=nc>Block_descriptor_2</span> <span class=o>*</span> <span class=nf>_Block_descriptor_2</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=n>aBlock</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_HAS_COPY_DISPOSE</span><span class=p>))</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>desc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>descriptor</span><span class=p>;</span>
    <span class=n>desc</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Block_descriptor_1</span><span class=p>);</span>
    <span class=k>return</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_descriptor_2</span> <span class=o>*</span><span class=p>)</span><span class=n>desc</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// 签名相关
</span><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=nc>Block_descriptor_3</span> <span class=o>*</span> <span class=nf>_Block_descriptor_3</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=n>aBlock</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_HAS_SIGNATURE</span><span class=p>))</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>desc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>descriptor</span><span class=p>;</span>
    <span class=n>desc</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Block_descriptor_1</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_HAS_COPY_DISPOSE</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>desc</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Block_descriptor_2</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_descriptor_3</span> <span class=o>*</span><span class=p>)</span><span class=n>desc</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>如果<code>aBlock->flags & BLOCK_HAS_COPY_DISPOSE</code>条件满足，那么存在<code>Block_descriptor_2</code>，<code>Block_descriptor_2</code>可以通过<code>Block_descriptor_1</code>内存偏移得到</p><p>同样的，<code>aBlock->flags & BLOCK_HAS_SIGNATURE</code>条件满足，那么存在<code>Block_descriptor_3</code>，<code>Block_descriptor_3</code>则可以根据<code>Block_descriptor_1</code>和<code>Block_descriptor_2</code>内存偏移得到</p><p>因此，block 的内存布局应该长这样：</p><p><img src=https://w-md.imzsy.design/image-20201117191449285.png alt=image-20201117191449285></p><p><strong>block签名</strong></p><p>在<code>Block_descriptor_3</code>中，有<code>signature</code>成员变量，在<code>_Block_copy</code>加入断点，打印一下全局 Block</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>&lt;__NSGlobalBlock__: 0x100004030&gt;
 signature: <span class=s2>&#34;v8@?0&#34;</span>
 invoke   : 0x100003ef0 <span class=o>(</span>/Users/zsy/Library/Developer/Xcode/DerivedData/Blocks-apixiageymqzowcvafsoicordsqh/Build/Products/Debug/BlockDemo<span class=sb>`</span>__main_block_invoke<span class=o>)</span>
</code></pre></div><p>这里的<code>signature: "v8@?0"</code>便是 block 的签名</p><p>通过<code>[NSMethodSignature signatureWithObjCTypes:"v8@?0"]</code>打印</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>&lt;NSMethodSignature: 0x3b5569f7a14d3061&gt;
    number of <span class=nv>arguments</span> <span class=o>=</span> <span class=m>1</span>
    frame <span class=nv>size</span> <span class=o>=</span> <span class=m>224</span>
    is special struct <span class=k>return</span>? NO
    <span class=c1># 无返回值</span>
    <span class=k>return</span> value: -------- -------- -------- --------
        <span class=nb>type</span> encoding <span class=o>(</span>v<span class=o>)</span> <span class=s1>&#39;v&#39;</span>
        flags <span class=o>{}</span>
        modifiers <span class=o>{}</span>
        frame <span class=o>{</span><span class=nv>offset</span> <span class=o>=</span> 0, offset <span class=nv>adjust</span> <span class=o>=</span> 0, <span class=nv>size</span> <span class=o>=</span> 0, size <span class=nv>adjust</span> <span class=o>=</span> 0<span class=o>}</span>
        memory <span class=o>{</span><span class=nv>offset</span> <span class=o>=</span> 0, <span class=nv>size</span> <span class=o>=</span> 0<span class=o>}</span>
    <span class=c1># 参数</span>
    argument 0: -------- -------- -------- --------
        <span class=c1># encoding = (@),类型是 @?</span>
        <span class=nb>type</span> encoding <span class=o>(</span>@<span class=o>)</span> <span class=s1>&#39;@?&#39;</span>
        flags <span class=o>{</span>isObject, isBlock<span class=o>}</span>
        modifiers <span class=o>{}</span>
        frame <span class=o>{</span><span class=nv>offset</span> <span class=o>=</span> 0, offset <span class=nv>adjust</span> <span class=o>=</span> 0, <span class=nv>size</span> <span class=o>=</span> 8, size <span class=nv>adjust</span> <span class=o>=</span> 0<span class=o>}</span>
        <span class=c1># 所在偏移位置是8字节</span>
        memory <span class=o>{</span><span class=nv>offset</span> <span class=o>=</span> 0, <span class=nv>size</span> <span class=o>=</span> 8<span class=o>}</span>
</code></pre></div><p>block的签名信息类似方法的签名，因此可以更加签名，对 block 进行 Hook</p><h3 id=__block的原理三次拷贝><a href=#__block的原理三次拷贝 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>__block的原理（三次拷贝）</h3><h4 id=第一次拷贝栈block---堆block><a href=#第一次拷贝栈block---堆block class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>第一次拷贝：栈block -> 堆block</h4><p>通过<code>_Block_copy</code>函数，打印 block 结果如下</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell><span class=c1>#_Block_copy 调用前</span>
&lt;__NSStackBlock__: 0x7ffeefbff478&gt;
 signature: <span class=s2>&#34;v8@?0&#34;</span>
 invoke   : 0x100003ef0 <span class=o>(</span>/Users/zsy/Library/Developer/Xcode/DerivedData/Blocks-apixiageymqzowcvafsoicordsqh/Build/Products/Debug/BlockDemo<span class=sb>`</span>__main_block_invoke<span class=o>)</span>

<span class=c1>#_Block_copy 调用后</span>
&lt;__NSMallocBlock__: 0x100705560&gt;
 signature: <span class=s2>&#34;v8@?0&#34;</span>
 invoke   : 0x100003ef0 <span class=o>(</span>/Users/zsy/Library/Developer/Xcode/DerivedData/Blocks-apixiageymqzowcvafsoicordsqh/Build/Products/Debug/BlockDemo<span class=sb>`</span>__main_block_invoke<span class=o>)</span>
</code></pre></div><p>是的，函数<code>_Block_copy</code>正是将<code>栈 Block</code>拷贝到<code>堆 Block</code>的关键所在，具体的函数实现如下：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.
</span><span class=c1>// block的拷贝操作: 栈Block -&gt; 堆Block
</span><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=nf>_Block_copy</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=n>aBlock</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>arg</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    
    <span class=c1>// The following would be better done as a switch statement
</span><span class=c1></span>    <span class=n>aBlock</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_NEEDS_FREE</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// latches on high
</span><span class=c1></span>        <span class=n>latching_incr_int</span><span class=p>(</span><span class=o>&amp;</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>aBlock</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_IS_GLOBAL</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>aBlock</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// Its a stack block.  Make a copy.
</span><span class=c1></span>        <span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=n>result</span> <span class=o>=</span>
            <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_layout</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>descriptor</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>result</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>memmove</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>aBlock</span><span class=p>,</span> <span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>descriptor</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span> <span class=c1>// bitcopy first
</span><span class=c1></span><span class=cp>#if __has_feature(ptrauth_calls)
</span><span class=cp></span>        <span class=c1>// Resign the invoke pointer as it uses address authentication.
</span><span class=c1></span>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>invoke</span> <span class=o>=</span> <span class=n>aBlock</span><span class=o>-&gt;</span><span class=n>invoke</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span>        <span class=c1>// reset refcount
</span><span class=c1></span>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=n>BLOCK_REFCOUNT_MASK</span><span class=o>|</span><span class=n>BLOCK_DEALLOCATING</span><span class=p>);</span>    <span class=c1>// XXX not needed
</span><span class=c1></span>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>BLOCK_NEEDS_FREE</span> <span class=o>|</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// logical refcount 1
</span><span class=c1></span>        <span class=n>_Block_call_copy_helper</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>aBlock</span><span class=p>);</span>
        <span class=c1>// Set isa last so memory analysis tools see a fully-initialized object.
</span><span class=c1></span>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>isa</span> <span class=o>=</span> <span class=n>_NSConcreteMallocBlock</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>整个流程分为：</p><ol><li>通过 <code>flags</code>标识位<code>BLOCK_NEEDS_FREE</code>——存储引用计数的值是否有效<ul><li>当栈 block 进入函数时，<code>aBlock->flags & BLOCK_NEEDS_FREE</code> 为 0，因此，拷贝为堆 block时，会重新设置引用计数</li><li>当堆 block 进入函数时，通过函数<code>latching_incr_int</code>，改变引用计数，并返回 block</li></ul></li><li>判断是否是全局 Block——如果是，直接返回</li><li>栈 block -> 堆 block<ul><li>通过 <code>malloc</code> 在堆区申请开辟内存空间</li><li>通过 <code>memove</code> 将数据从栈区拷贝到堆区</li><li>设置 <code>invoke</code></li><li>重置引用计数</li><li>将 block 的 <code>isa</code> 标记为<code>_NSConcreteMallocBlock</code></li></ul></li></ol><h4 id=第二次拷贝捕获外界变量的操作><a href=#第二次拷贝捕获外界变量的操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>第二次拷贝：捕获外界变量的操作</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>__main_block_copy_0</span><span class=p>(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=n>src</span><span class=p>)</span> <span class=p>{</span><span class=n>_Block_object_assign</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>dst</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=mi>8</span><span class=cm>/*BLOCK_FIELD_IS_BYREF*/</span><span class=p>);}</span>

<span class=k>static</span> <span class=kt>void</span> <span class=nf>__main_block_dispose_0</span><span class=p>(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=n>src</span><span class=p>)</span> <span class=p>{</span><span class=n>_Block_object_dispose</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=mi>8</span><span class=cm>/*BLOCK_FIELD_IS_BYREF*/</span><span class=p>);}</span>

<span class=k>static</span> <span class=k>struct</span> <span class=nc>__main_block_desc_0</span> <span class=p>{</span>
  <span class=n>size_t</span> <span class=n>reserved</span><span class=p>;</span>
  <span class=n>size_t</span> <span class=n>Block_size</span><span class=p>;</span>
  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>copy</span><span class=p>)(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=p>);</span>
  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>dispose</span><span class=p>)(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=o>*</span><span class=p>);</span>
<span class=p>}</span> <span class=n>__main_block_desc_0_DATA</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>__main_block_impl_0</span><span class=p>),</span> <span class=n>__main_block_copy_0</span><span class=p>,</span> <span class=n>__main_block_dispose_0</span><span class=p>};</span>
</code></pre></div><p>在**__block捕获外部变量**时，在底层<code>__main_block_impl_0</code>构造函数中，还会传递<code>main_block_desc_0_DATA</code></p><p>而<code>__main_block_desc_0_DATA</code>内部会传递<code>__main_block_copy_0</code>函数、<code>__main_block_dispose_0</code>函数</p><ul><li><code>__main_block_copy_0</code>函数会调用<code>_Block_object_assign</code></li><li><code>__main_block_dispose_0</code>函数会调用<code>_Block_object_dispose</code></li></ul><p><strong>_Block_object_assign</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/); 传递的参数
</span><span class=c1></span><span class=kt>void</span> <span class=nf>_Block_object_assign</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>destArg</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>const</span> <span class=kt>void</span> <span class=o>**</span><span class=n>dest</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>**</span><span class=p>)</span><span class=n>destArg</span><span class=p>;</span>
    <span class=k>switch</span> <span class=p>(</span><span class=n>os_assumes</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_ALL_COPY_DISPOSE_FLAGS</span><span class=p>))</span> <span class=p>{</span>
      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_OBJECT</span><span class=p>:</span>
        <span class=cm>/*******
</span><span class=cm>        id object = ...;
</span><span class=cm>        [^{ object; } copy];
</span><span class=cm>        ********/</span>

        <span class=n>_Block_retain_object</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
        <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>object</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>

      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_BLOCK</span><span class=p>:</span>
        <span class=cm>/*******
</span><span class=cm>        void (^object)(void) = ...;
</span><span class=cm>        [^{ object; } copy];
</span><span class=cm>        ********/</span>

        <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>_Block_copy</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
    
      <span class=k>case</span> <span class=n>BLOCK_FIELD_IS_BYREF</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_BYREF</span><span class=p>:</span>
        <span class=cm>/*******
</span><span class=cm>         // copy the onstack __block container to the heap
</span><span class=cm>         // Note this __weak is old GC-weak/MRC-unretained.
</span><span class=cm>         // ARC-style __weak is handled by the copy helper directly.
</span><span class=cm>         __block ... x;
</span><span class=cm>         __weak __block ... x;
</span><span class=cm>         [^{ x; } copy];
</span><span class=cm>         ********/</span>

        <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>_Block_byref_copy</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
        
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_OBJECT</span><span class=p>:</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_BLOCK</span><span class=p>:</span>
        <span class=cm>/*******
</span><span class=cm>         // copy the actual field held in the __block container
</span><span class=cm>         // Note this is MRC unretained __block only. 
</span><span class=cm>         // ARC retained __block is handled by the copy helper directly.
</span><span class=cm>         __block id object;
</span><span class=cm>         __block void (^object)(void);
</span><span class=cm>         [^{ object; } copy];
</span><span class=cm>         ********/</span>

        <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>object</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>

      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=n>BLOCK_FIELD_IS_OBJECT</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=n>BLOCK_FIELD_IS_BLOCK</span>  <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
        <span class=cm>/*******
</span><span class=cm>         // copy the actual field held in the __block container
</span><span class=cm>         // Note this __weak is old GC-weak/MRC-unretained.
</span><span class=cm>         // ARC-style __weak is handled by the copy helper directly.
</span><span class=cm>         __weak __block id object;
</span><span class=cm>         __weak __block void (^object)(void);
</span><span class=cm>         [^{ object; } copy];
</span><span class=cm>         ********/</span>

        <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>object</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>

      <span class=k>default</span><span class=o>:</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>根据<code>flags & BLOCK_ALL_COPY_DISPOSE_FLAGS</code>进到不同分支来处理捕获到的变量</p><div class=table-container><table><thead><tr><th>枚举值</th><th style=text-align:center>数值</th><th>含义</th></tr></thead><tbody><tr><td>BLOCK_FIELD_IS_OBJECT</td><td style=text-align:center>3</td><td>对象</td></tr><tr><td>BLOCK_FIELD_IS_BLOCK</td><td style=text-align:center>7</td><td>block变量</td></tr><tr><td>BLOCK_FIELD_IS_BYREF</td><td style=text-align:center>8</td><td>__block修饰的结构体</td></tr><tr><td>BLOCK_FIELD_IS_WEAK</td><td style=text-align:center>16</td><td>__weak修饰的变量</td></tr><tr><td>BLOCK_BYREF_CALLER</td><td style=text-align:center>128</td><td>处理block_byref内部对象内存的时候 会加的一个额外的标记，配合上面的枚举一起使用</td></tr></tbody></table></div><p>根据源码不难看出：</p><ul><li><code>BLOCK_FIELD_IS_OBJECT</code>：交给系统 ARC 处理，并拷贝对象指针，即引用计数+1</li><li><code>BLOCK_FIELD_IS_BLOCK</code>：调用<code>_Block_copy</code>函数，将 block 从栈区拷贝到堆区</li><li><code>BLOCK_FIELD_IS_BYREF</code>：调用<code>_Block_byref_copy</code>函数，进行内存拷贝、引用计数的处理</li></ul><p><strong>_Block_byref_copy</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=nf>_Block_byref_copy</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    
    <span class=c1>//强转为Block_byref结构体类型，保存一份
</span><span class=c1></span>    <span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=n>src</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>((</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>forwarding</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_REFCOUNT_MASK</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// src points to stack 申请内存
</span><span class=c1></span>        <span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=n>copy</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span>
        <span class=n>copy</span><span class=o>-&gt;</span><span class=n>isa</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=c1>// byref value 4 is logical refcount of 2: one for caller, one for stack
</span><span class=c1></span>        <span class=n>copy</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|</span> <span class=n>BLOCK_BYREF_NEEDS_FREE</span> <span class=o>|</span> <span class=mi>4</span><span class=p>;</span>
        <span class=c1>//block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力
</span><span class=c1></span>        <span class=c1>//copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力
</span><span class=c1></span>        <span class=n>copy</span><span class=o>-&gt;</span><span class=n>forwarding</span> <span class=o>=</span> <span class=n>copy</span><span class=p>;</span> <span class=c1>// patch heap copy to point to itself
</span><span class=c1></span>        <span class=n>src</span><span class=o>-&gt;</span><span class=n>forwarding</span> <span class=o>=</span> <span class=n>copy</span><span class=p>;</span>  <span class=c1>// patch stack to point to heap copy
</span><span class=c1></span>        <span class=n>copy</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span>
        <span class=c1>//如果有copy能力
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_BYREF_HAS_COPY_DISPOSE</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// Trust copy helper to copy everything of interest
</span><span class=c1></span>            <span class=c1>// If more than one field shows up in a byref block this is wrong XXX
</span><span class=c1></span>            <span class=c1>//Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用
</span><span class=c1></span>            <span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=n>src2</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=p>)(</span><span class=n>src</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
            <span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=n>copy2</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=p>)(</span><span class=n>copy</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
            <span class=n>copy2</span><span class=o>-&gt;</span><span class=n>byref_keep</span> <span class=o>=</span> <span class=n>src2</span><span class=o>-&gt;</span><span class=n>byref_keep</span><span class=p>;</span>
            <span class=n>copy2</span><span class=o>-&gt;</span><span class=n>byref_destroy</span> <span class=o>=</span> <span class=n>src2</span><span class=o>-&gt;</span><span class=n>byref_destroy</span><span class=p>;</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_BYREF_LAYOUT_EXTENDED</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>struct</span> <span class=nc>Block_byref_3</span> <span class=o>*</span><span class=n>src3</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref_3</span> <span class=o>*</span><span class=p>)(</span><span class=n>src2</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
                <span class=k>struct</span> <span class=nc>Block_byref_3</span> <span class=o>*</span><span class=n>copy3</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref_3</span><span class=o>*</span><span class=p>)(</span><span class=n>copy2</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
                <span class=n>copy3</span><span class=o>-&gt;</span><span class=n>layout</span> <span class=o>=</span> <span class=n>src3</span><span class=o>-&gt;</span><span class=n>layout</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=c1>//等价于 __Block_byref_id_object_copy
</span><span class=c1></span>            <span class=p>(</span><span class=o>*</span><span class=n>src2</span><span class=o>-&gt;</span><span class=n>byref_keep</span><span class=p>)(</span><span class=n>copy</span><span class=p>,</span> <span class=n>src</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// Bitwise copy.
</span><span class=c1></span>            <span class=c1>// This copy includes Block_byref_3, if any.
</span><span class=c1></span>            <span class=n>memmove</span><span class=p>(</span><span class=n>copy</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>src</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>src</span><span class=p>));</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// already copied to heap
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>forwarding</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_BYREF_NEEDS_FREE</span><span class=p>)</span> <span class=o>==</span> <span class=n>BLOCK_BYREF_NEEDS_FREE</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>latching_incr_int</span><span class=p>(</span><span class=o>&amp;</span><span class=n>src</span><span class=o>-&gt;</span><span class=n>forwarding</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=k>return</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>forwarding</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>整个过程：</p><ul><li>将传入的对象，强转为<code>Block_byref</code>结构体</li><li>判断是否将对象拷贝到堆区<ul><li>如果已经拷贝过了，则处理引用计数</li><li>如果没有拷贝，则需要申请内存<code>Block_byref *copy</code>，并且让<code>copy->forwarding</code>和<code>src->forwarding</code>都指向同一个对象，在也是为什么<code>__block</code>修饰的对象具备修改能力的原因</li></ul></li></ul><p><strong>Block_byref结构体的内存布局</strong></p><p><img src=https://w-md.imzsy.design/image-20201117210815025.png alt=image-20201117210815025></p><h4 id=第三次拷贝拷贝对象><a href=#第三次拷贝拷贝对象 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>第三次拷贝：拷贝对象</h4><p>在<code>_Block_byref_copy</code>函数中，将<code>Block_byref</code>对象从栈拷贝到堆时，如果对象的<code>flags</code>具有<code>BLOCK_BYREF_HAS_COPY_DISPOSE</code>标识时，即<code>__block</code>修饰的对象内部还存在对象，那么需要对内部的对象也进行拷贝</p><p><code>(*src2->byref_keep)(copy, src)</code>就是对象拷贝</p><p><code>byref_keep</code>的定义</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>Block_byref</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>isa</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=n>forwarding</span><span class=p>;</span>
    <span class=k>volatile</span> <span class=kt>int32_t</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// contains ref count
</span><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>;</span>
<span class=p>};</span>

<span class=c1>// __Block 修饰的结构体 byref_keep 和 byref_destroy 函数 - 来处理里面持有对象的保持和销毁
</span><span class=c1></span><span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=p>{</span>
    <span class=c1>// requires BLOCK_BYREF_HAS_COPY_DISPOSE
</span><span class=c1></span>    <span class=n>BlockByrefKeepFunction</span> <span class=n>byref_keep</span><span class=p>;</span>
    <span class=n>BlockByrefDestroyFunction</span> <span class=n>byref_destroy</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>Block_byref_3</span> <span class=p>{</span>
    <span class=c1>// requires BLOCK_BYREF_LAYOUT_EXTENDED
</span><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>layout</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>重新 <code>clang</code> 对下面的代码编译看一看</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=cp>#import &lt;Foundation/Foundation.h&gt;
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=k>__block</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=p>[</span><span class=n>NSString</span> <span class=nl>stringWithFormat</span><span class=p>:</span><span class=s>@&#34;test&#34;</span><span class=p>];</span>
    <span class=kt>void</span><span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>name</span> <span class=o>=</span> <span class=s>@&#34;name&#34;</span><span class=p>;</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;Block: %@&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
    <span class=p>};</span>
    <span class=n>block</span><span class=p>();</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>编译结果：</p><ul><li>编译后的<code>Block_byref</code>结构体，多了<code>__Block_byref_id_object_copy_131</code>和<code>__Block_byref_id_object_dispose_131</code></li><li><code>__Block_byref_name_0</code>结构体，多了<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code></li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>__attribute__</span><span class=p>((</span><span class=n>__blocks__</span><span class=p>(</span><span class=n>byref</span><span class=p>)))</span> <span class=n>__Block_byref_name_0</span> <span class=n>name</span> <span class=o>=</span> <span class=p>{</span>
        <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=mi>0</span><span class=p>,</span>
        <span class=p>(</span><span class=n>__Block_byref_name_0</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span>
        <span class=mi>33554432</span><span class=p>,</span>
        <span class=k>sizeof</span><span class=p>(</span><span class=n>__Block_byref_name_0</span><span class=p>),</span>
        <span class=n>__Block_byref_id_object_copy_131</span><span class=p>,</span>
        <span class=n>__Block_byref_id_object_dispose_131</span><span class=p>,</span>
        <span class=p>((</span><span class=n>NSString</span> <span class=o>*</span> <span class=n>_Nonnull</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>id</span><span class=p>,</span> <span class=n>SEL</span><span class=p>,</span> <span class=n>NSString</span> <span class=o>*</span> <span class=n>_Nonnull</span><span class=p>,</span> <span class=p>...))(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>objc_msgSend</span><span class=p>)((</span><span class=n>id</span><span class=p>)</span><span class=n>objc_getClass</span><span class=p>(</span><span class=s>&#34;NSString&#34;</span><span class=p>),</span> <span class=n>sel_registerName</span><span class=p>(</span><span class=s>&#34;stringWithFormat:&#34;</span><span class=p>),</span> <span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>__NSConstantStringImpl__var_folders_qs_68kbrd0j4790ypksky9f_kgr0000gn_T_main_1106ed_mi_0</span><span class=p>)};</span>

    <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=o>&amp;</span><span class=n>__main_block_impl_0</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>__main_block_func_0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>__main_block_desc_0_DATA</span><span class=p>,</span> <span class=p>(</span><span class=n>__Block_byref_name_0</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=mi>570425344</span><span class=p>));</span>

    <span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>))((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>FuncPtr</span><span class=p>)((</span><span class=n>__block_impl</span> <span class=o>*</span><span class=p>)</span><span class=n>block</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>struct</span> <span class=nc>__Block_byref_name_0</span> <span class=p>{</span>
  <span class=kt>void</span> <span class=o>*</span><span class=n>__isa</span><span class=p>;</span>
<span class=n>__Block_byref_name_0</span> <span class=o>*</span><span class=n>__forwarding</span><span class=p>;</span>
 <span class=kt>int</span> <span class=n>__flags</span><span class=p>;</span>
 <span class=kt>int</span> <span class=n>__size</span><span class=p>;</span>
 <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>__Block_byref_id_object_copy</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span><span class=p>);</span>
 <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>__Block_byref_id_object_dispose</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>);</span>
 <span class=n>NSString</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>static</span> <span class=kt>void</span> <span class=nf>__Block_byref_id_object_copy_131</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>)</span> <span class=p>{</span>
 <span class=n>_Block_object_assign</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dst</span> <span class=o>+</span> <span class=mi>40</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>src</span> <span class=o>+</span> <span class=mi>40</span><span class=p>),</span> <span class=mi>131</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>void</span> <span class=nf>__Block_byref_id_object_dispose_131</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>)</span> <span class=p>{</span>
 <span class=n>_Block_object_dispose</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>src</span> <span class=o>+</span> <span class=mi>40</span><span class=p>),</span> <span class=mi>131</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>没错，这里的<code>__Block_byref_id_object_copy_131</code>正是<code>byref_keep</code></p><p>第三次拷贝正是调用<code>__Block_byref_id_object_copy_131</code>方法，而本质是调用<code>_Block_object_assign</code>，<code>(char*)dst + 40</code>其实是通过内存平移，传入成员变量 <code>name</code></p><p><strong>总结</strong></p><p>通过<code>libclosure-74</code>可编译源码断点调试，关键方法的执行顺序：<code>_Block_copy -> _Block_byref_copy -> *src2->byref_keep (即_Block_object_assign)</code></p><p>这就是<code>__block的三次拷贝</code></p><ul><li>第一次拷贝：通过<code>_Block_copy</code>函数，将对象从栈区拷贝到堆区</li><li>第二次拷贝：通过<code>_Block_byref_copy</code>函数，将对象拷贝为<code>Block_byref</code>结构体</li><li>第三次拷贝：调用对象的<code>byref_keep</code>函数，实际是调用<code>_Block_object_assign</code>函数，对<code>__block</code>修饰的<code>当前变量</code>拷贝</li></ul><p><strong>_Block_object_dispose</strong></p><p><code>_Block_object_dispose</code>和<code>_Block_object_assign</code>非常类似，主要是负责 block 的释放操作</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point
</span><span class=c1>// to help dispose of the contents 当Blocks或Block_byrefs持有对象时，其销毁助手例程将调用此入口点以帮助处置内容
</span><span class=c1></span><span class=kt>void</span> <span class=nf>_Block_object_dispose</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>switch</span> <span class=p>(</span><span class=n>os_assumes</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_ALL_COPY_DISPOSE_FLAGS</span><span class=p>))</span> <span class=p>{</span>
      <span class=k>case</span> <span class=n>BLOCK_FIELD_IS_BYREF</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_BYREF</span><span class=p>:</span><span class=c1>//__block修饰的变量，即bref类型的
</span><span class=c1></span>        <span class=c1>// get rid of the __block data structure held in a Block
</span><span class=c1></span>        <span class=n>_Block_byref_release</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_BLOCK</span><span class=p>:</span><span class=c1>//block类型的变量
</span><span class=c1></span>        <span class=n>_Block_release</span><span class=p>(</span><span class=n>object</span><span class=p>)</span> <span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=k>case</span> <span class=nl>BLOCK_FIELD_IS_OBJECT</span><span class=p>:</span><span class=c1>//普通对象
</span><span class=c1></span>        <span class=n>_Block_release_object</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_OBJECT</span><span class=p>:</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_BLOCK</span><span class=p>:</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=n>BLOCK_FIELD_IS_OBJECT</span> <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
      <span class=k>case</span> <span class=n>BLOCK_BYREF_CALLER</span> <span class=o>|</span> <span class=n>BLOCK_FIELD_IS_BLOCK</span>  <span class=o>|</span> <span class=nl>BLOCK_FIELD_IS_WEAK</span><span class=p>:</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=k>default</span><span class=o>:</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>void</span> <span class=nf>_Block_byref_release</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=n>byref</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>

    <span class=c1>// dereference the forwarding pointer since the compiler isn&#39;t doing this anymore (ever?)
</span><span class=c1></span>    <span class=n>byref</span> <span class=o>=</span> <span class=n>byref</span><span class=o>-&gt;</span><span class=n>forwarding</span><span class=p>;</span>
    
    <span class=k>if</span> <span class=p>(</span><span class=n>byref</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_BYREF_NEEDS_FREE</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int32_t</span> <span class=n>refcount</span> <span class=o>=</span> <span class=n>byref</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_REFCOUNT_MASK</span><span class=p>;</span>
        <span class=n>os_assert</span><span class=p>(</span><span class=n>refcount</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>latching_decr_int_should_deallocate</span><span class=p>(</span><span class=o>&amp;</span><span class=n>byref</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>))</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>byref</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>BLOCK_BYREF_HAS_COPY_DISPOSE</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=n>byref2</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>Block_byref_2</span> <span class=o>*</span><span class=p>)(</span><span class=n>byref</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
                <span class=p>(</span><span class=o>*</span><span class=n>byref2</span><span class=o>-&gt;</span><span class=n>byref_destroy</span><span class=p>)(</span><span class=n>byref</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=n>free</span><span class=p>(</span><span class=n>byref</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>通过源码，不难得出下面的结论</p><ul><li>如果是释放对象就什么也不做（自动释放）</li><li>如果是<code>__block</code>修饰，就将指向指回原来的区域并使用<code>free</code>释放</li></ul><blockquote><p>参考资料：</p><p><a href=https://opensource.apple.com/source/libclosure/libclosure-74/ target=_blank rel=noopener>libclosure-74</a></p><p><a href=https://github.com/dev-jw/objc_debug/tree/master/libclosure-74 target=_blank rel=noopener>可编译调试源码</a></p></blockquote></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>