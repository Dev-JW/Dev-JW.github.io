<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-类的加载 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="在『iOS底层原理探索-dyld加载流程』中，介绍了 App 启动时刻的一些操作。 那么关于类……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/class-load/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-10-13T14:21:19+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/class-load/","name":"iOS底层原理探索-类的加载","description":"在『iOS底层原理探索-dyld加载流程』中，介绍了 App 启动时刻的一些操作。 那么关于类……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-类的加载"><meta property="og:description" content="在『iOS底层原理探索-dyld加载流程』中，介绍了 App 启动时刻的一些操作。 那么关于类……"><meta property="og:url" content="https://dev.hjw.best/class-load/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-类的加载</h1><div class=post-meta><time datetime=2020-10-13T14:21:19+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-10-13</time></div><div class="post-body e-content"><p>在『<a href=../dyld-load>iOS底层原理探索-dyld加载流程</a>』中，介绍了 App 启动时刻的一些操作。</p><p>那么关于类的加载具体是在什么时候呢？同样的，以下几个问题会帮助对本文的理解：</p><ul><li><code>_objc_init</code>具体做了什么</li><li><code>readClass</code>具体做了什么</li><li><code>realizeClassWithoutSwift</code>具体做了什么</li><li>类的加载过程——非懒加载</li><li>类的加载过程——懒加载</li></ul><h3 id=_objc_init><a href=#_objc_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>_objc_init</h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* _objc_init
</span><span class=cm>* Bootstrap initialization. Registers our image notifier with dyld.
</span><span class=cm>* Called by libSystem BEFORE library initialization time
</span><span class=cm>**********************************************************************/</span>

<span class=kt>void</span> <span class=nf>_objc_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=kt>bool</span> <span class=n>initialized</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>initialized</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
    <span class=n>initialized</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    
    <span class=c1>// fixme defer initialization until an objc-using image is found?
</span><span class=c1></span>    <span class=n>environ_init</span><span class=p>();</span>
    <span class=n>tls_init</span><span class=p>();</span>
    <span class=n>static_init</span><span class=p>();</span>
    <span class=n>runtime_init</span><span class=p>();</span>
    <span class=n>exception_init</span><span class=p>();</span>
    <span class=n>cache_init</span><span class=p>();</span>
    <span class=n>_imp_implementationWithBlock_init</span><span class=p>();</span>

    <span class=n>_dyld_objc_notify_register</span><span class=p>(</span><span class=o>&amp;</span><span class=n>map_images</span><span class=p>,</span> <span class=n>load_images</span><span class=p>,</span> <span class=n>unmap_image</span><span class=p>);</span>

<span class=cp>#if __OBJC2__
</span><span class=cp></span>    <span class=n>didCallDyldNotifyRegister</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span><span class=p>}</span>
</code></pre></div><p>先看<strong>源码</strong>，逐行分析</p><h4 id=environ_init><a href=#environ_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>environ_init()</h4><p>这个函数会读取影响运行时的环境变量，如果需要，还可以打印环境变量帮助。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>PrintHelp</span>  <span class=o>||</span>  <span class=n>PrintOptions</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>PrintHelp</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;Objective-C runtime debugging. Set variable=YES to enable.&#34;</span><span class=p>);</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;OBJC_HELP: describe available environment variables&#34;</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>PrintOptions</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;OBJC_HELP is set&#34;</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;OBJC_PRINT_OPTIONS: list which options are set&#34;</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>PrintOptions</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;OBJC_PRINT_OPTIONS is set&#34;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Settings</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Settings</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>const</span> <span class=n>option_t</span> <span class=o>*</span><span class=n>opt</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>Settings</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>            
        <span class=k>if</span> <span class=p>(</span><span class=n>PrintHelp</span><span class=p>)</span> <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;%s: %s&#34;</span><span class=p>,</span> <span class=n>opt</span><span class=o>-&gt;</span><span class=n>env</span><span class=p>,</span> <span class=n>opt</span><span class=o>-&gt;</span><span class=n>help</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>PrintOptions</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=n>opt</span><span class=o>-&gt;</span><span class=n>var</span><span class=p>)</span> <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;%s is set&#34;</span><span class=p>,</span> <span class=n>opt</span><span class=o>-&gt;</span><span class=n>env</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>这里列了所有的<a href=https://w-md.imzsy.design/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B1%87%E6%80%BB.pdf target=_blank rel=noopener>环境变量</a>，当然也可以通过终端输入<code>export OBJC_HELP=1</code>查看</p><p>常用的环境变量如：</p><ul><li><p><code>OBJC_PRINT_LOAD_METHODS</code>：打印所有的<code>+load</code>方法</p></li><li><p><code>OBJC_DISABLE_NONPOINTER_ISA</code>：控制 <code>isa</code> 优化开关</p></li></ul><h4 id=tls_init><a href=#tls_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>tls_init()</h4><p>这个函数主要是本地线程池的初始化，关于线程 key 的绑定</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>tls_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
<span class=cp>#if SUPPORT_DIRECT_THREAD_KEYS </span><span class=c1>// 本地线程池
</span><span class=c1></span>    <span class=n>pthread_key_init_np</span><span class=p>(</span><span class=n>TLS_DIRECT_KEY</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>_objc_pthread_destroyspecific</span><span class=p>);</span> <span class=c1>// 初始init
</span><span class=c1></span><span class=cp>#else
</span><span class=cp></span>    <span class=n>_objc_pthread_key</span> <span class=o>=</span> <span class=n>tls_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_objc_pthread_destroyspecific</span><span class=p>);</span> <span class=c1>// 析构
</span><span class=c1></span><span class=cp>#endif
</span><span class=cp></span><span class=p>}</span>
</code></pre></div><h4 id=static_init><a href=#static_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>static_init()</h4><p>通过函数注释可知，主要是运行 <strong>C++ 静态构造函数</strong>（只会运行系统级别的构造函数）</p><p>在 Dyld 调用我们的静态构造函数之前，<code>libc</code>调用<code>_objc_init()</code>方法，也就说<strong>系统的C++构造函数 优先于 自定义的C++构造函数</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* static_init
</span><span class=cm>* Run C++ static constructor functions.
</span><span class=cm>* libc calls _objc_init() before dyld would call our static constructors, 
</span><span class=cm>* so we have to do it ourselves.
</span><span class=cm>**********************************************************************/</span>
<span class=k>static</span> <span class=kt>void</span> <span class=nf>static_init</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>size_t</span> <span class=n>count</span><span class=p>;</span>
    <span class=k>auto</span> <span class=n>inits</span> <span class=o>=</span> <span class=n>getLibobjcInitializers</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_mh_dylib_header</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>inits</span><span class=p>[</span><span class=n>i</span><span class=p>]();</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h4 id=runtime_init><a href=#runtime_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>runtime_init()</h4><p>运行时的初始化，主要分为两个操作：</p><ul><li>开辟存储分类的表</li><li>开辟存储类的表</li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>runtime_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>objc</span><span class=o>::</span><span class=n>unattachedCategories</span><span class=p>.</span><span class=n>init</span><span class=p>(</span><span class=mi>32</span><span class=p>);</span>
    <span class=n>objc</span><span class=o>::</span><span class=n>allocatedClasses</span><span class=p>.</span><span class=n>init</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><h4 id=exception_init><a href=#exception_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>exception_init()</h4><p>初始化 <code>libobjc</code> 的异常处理系统，注册异常处理的回调，从而监控异常的处理</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* exception_init
</span><span class=cm>* Initialize libobjc&#39;s exception handling system.
</span><span class=cm>* Called by map_images().
</span><span class=cm>**********************************************************************/</span>
<span class=kt>void</span> <span class=nf>exception_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>old_terminate</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>set_terminate</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_objc_terminate</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>当产生 <code>crash</code> 时，会来到<code>_objc_terminate</code>方法，走到 <code>uncaught_handler</code> 抛出异常</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* _objc_terminate
</span><span class=cm>* Custom std::terminate handler.
</span><span class=cm>*
</span><span class=cm>* The uncaught exception callback is implemented as a std::terminate handler. 
</span><span class=cm>* 1. Check if there&#39;s an active exception
</span><span class=cm>* 2. If so, check if it&#39;s an Objective-C exception
</span><span class=cm>* 3. If so, call our registered callback with the object.
</span><span class=cm>* 4. Finally, call the previous terminate handler.
</span><span class=cm>**********************************************************************/</span>
<span class=k>static</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>old_terminate</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
<span class=k>static</span> <span class=kt>void</span> <span class=nf>_objc_terminate</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>PrintExceptions</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;EXCEPTIONS: terminating&#34;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=n>__cxa_current_exception_type</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// No current exception.
</span><span class=c1></span>        <span class=p>(</span><span class=o>*</span><span class=n>old_terminate</span><span class=p>)();</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// There is a current exception. Check if it&#39;s an objc exception.
</span><span class=c1></span>        <span class=err>@</span><span class=k>try</span> <span class=p>{</span>
            <span class=n>__cxa_rethrow</span><span class=p>();</span>
        <span class=p>}</span> <span class=err>@</span><span class=k>catch</span> <span class=p>(</span><span class=n>id</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// It&#39;s an objc object. Call Foundation&#39;s handler, if any.
</span><span class=c1></span>            <span class=p>(</span><span class=o>*</span><span class=n>uncaught_handler</span><span class=p>)((</span><span class=n>id</span><span class=p>)</span><span class=n>e</span><span class=p>);</span>
            <span class=p>(</span><span class=o>*</span><span class=n>old_terminate</span><span class=p>)();</span>
        <span class=p>}</span> <span class=err>@</span><span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span>
            <span class=c1>// It&#39;s not an objc object. Continue to C++ terminate.
</span><span class=c1></span>            <span class=p>(</span><span class=o>*</span><span class=n>old_terminate</span><span class=p>)();</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>在底层<code>objc_setExceptionMatcher</code>函数会将传入的 <code>fn</code> 赋值给<code>uncaught_handler</code>，经过封装在上层调用的是<code>NSSetUncaughtExceptionHandler</code>方法，</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* objc_setExceptionMatcher
</span><span class=cm>* Set a handler for matching Objective-C exceptions. 
</span><span class=cm>* Returns the previous handler. 
</span><span class=cm>**********************************************************************/</span>
<span class=n>objc_exception_matcher</span>
<span class=nf>objc_setExceptionMatcher</span><span class=p>(</span><span class=n>objc_exception_matcher</span> <span class=n>fn</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>objc_exception_matcher</span> <span class=n>result</span> <span class=o>=</span> <span class=n>exception_matcher</span><span class=p>;</span>
    <span class=n>exception_matcher</span> <span class=o>=</span> <span class=n>fn</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><strong>关于 Crash</strong></p><p>造成 Crash 的主要原因就是收到未处理的信号，而这个信号来源于三个地方：</p><ul><li>kernel内核</li><li>其他进行</li><li>App本身</li></ul><p>相应的，crash 也分为了 3 类</p><ul><li>Mach异常：底层内核级异常。用户态的开发者可以直接通过 Mach API 设置 Thread、task、host 的异常端口，捕获 Mach 异常</li><li>Unix异常：BSD信号，如果开发者没有捕获 Mach 异常，则会被 host 层的方法 ux_exception() 将异常转换为对应的 UNIX 信号，并通过 threadsignal() 将信号投递到出错线程。通过方法 <code>signal(x, fn)</code> 捕获</li><li>NSException应用异常：未被不捕获的 Objective-C 异常，导致程序向自身发送了 <code>SIGABRT</code> 信号而崩溃，可以通过 <code>try-catch</code> 或者<code>NSSetUncaughtExceptionHandler</code>捕获</li></ul><p><strong>Crash拦截</strong></p><p>在日常开发中，会针对 Crash 进行拦截处理，其本质就是通过<code>NSSetUncaughtExceptionHandler</code>注册异常捕获函数<code>fn</code>。</p><p>当发送异常时，<code>fn</code>函数就会被调用，在函数中，收集崩溃日志、线程保活等操作</p><blockquote><p><a href=https://github.com/dev-jw/CrashDemo/blob/master/CrashDemo/UncaughtExceptionHandler.m target=_blank rel=noopener>Crash拦截Demo</a></p></blockquote><h4 id=cache_init><a href=#cache_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>cache_init()</h4><p>缓存初始化</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>cache_init</span><span class=p>()</span>
<span class=p>{</span>
<span class=cp>#if HAVE_TASK_RESTARTABLE_RANGES
</span><span class=cp></span>    <span class=n>mach_msg_type_number_t</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>kern_return_t</span> <span class=n>kr</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>objc_restartableRanges</span><span class=p>[</span><span class=n>count</span><span class=p>].</span><span class=n>location</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>kr</span> <span class=o>=</span> <span class=n>task_restartable_ranges_register</span><span class=p>(</span><span class=n>mach_task_self</span><span class=p>(),</span>
                                          <span class=n>objc_restartableRanges</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>kr</span> <span class=o>==</span> <span class=n>KERN_SUCCESS</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
    <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;task_restartable_ranges_register failed (result 0x%x: %s)&#34;</span><span class=p>,</span>
                <span class=n>kr</span><span class=p>,</span> <span class=n>mach_error_string</span><span class=p>(</span><span class=n>kr</span><span class=p>));</span>
<span class=cp>#endif </span><span class=c1>// HAVE_TASK_RESTARTABLE_RANGES
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h4 id=_imp_implementationwithblock_init><a href=#_imp_implementationwithblock_init class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>_imp_implementationWithBlock_init()</h4><p>启动回调机制，通常不会做什么，因为一切都是懒初始化的，但是对于某些进程，我们需要急切地加载<code>libobjc-trampolines.dylib</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>_imp_implementationWithBlock_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
<span class=cp>#if TARGET_OS_OSX
</span><span class=cp></span>    <span class=c1>// Eagerly load libobjc-trampolines.dylib in certain processes. Some
</span><span class=c1></span>    <span class=c1>// programs (most notably QtWebEngineProcess used by older versions of
</span><span class=c1></span>    <span class=c1>// embedded Chromium) enable a highly restrictive sandbox profile which
</span><span class=c1></span>    <span class=c1>// blocks access to that dylib. If anything calls
</span><span class=c1></span>    <span class=c1>// imp_implementationWithBlock (as AppKit has started doing) then we&#39;ll
</span><span class=c1></span>    <span class=c1>// crash trying to load it. Loading it here sets it up before the sandbox
</span><span class=c1></span>    <span class=c1>// profile is enabled and blocks it.
</span><span class=c1></span>    <span class=c1>//
</span><span class=c1></span>    <span class=c1>// This fixes EA Origin (rdar://problem/50813789)
</span><span class=c1></span>    <span class=c1>// and Steam (rdar://problem/55286131)
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>__progname</span> <span class=o>&amp;&amp;</span>
        <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>__progname</span><span class=p>,</span> <span class=s>&#34;QtWebEngineProcess&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span>
         <span class=n>strcmp</span><span class=p>(</span><span class=n>__progname</span><span class=p>,</span> <span class=s>&#34;Steam Helper&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>Trampolines</span><span class=p>.</span><span class=n>Initialize</span><span class=p>();</span>
    <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span><span class=p>}</span>
</code></pre></div><h4 id=_dyld_objc_notify_register><a href=#_dyld_objc_notify_register class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>_dyld_objc_notify_register</h4><p><code>_dyld_objc_notify_register</code>函数声明</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>//
</span><span class=c1>// Note: only for use by objc runtime
</span><span class=c1>// Register handlers to be called when objc images are mapped, unmapped, and initialized.
</span><span class=c1>// Dyld will call back the &#34;mapped&#34; function with an array of images that contain an objc-image-info section.
</span><span class=c1>// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to
</span><span class=c1>// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),
</span><span class=c1>// dyld will call the &#34;mapped&#34; function with already loaded objc images.  During any later dlopen() call,
</span><span class=c1>// dyld will also call the &#34;mapped&#34; function.  Dyld will call the &#34;init&#34; function when dyld would be called
</span><span class=c1>// initializers in that image.  This is when objc calls any +load methods in that image.
</span><span class=c1>//
</span><span class=c1></span><span class=kt>void</span> <span class=nf>_dyld_objc_notify_register</span><span class=p>(</span><span class=n>_dyld_objc_notify_mapped</span>    <span class=n>mapped</span><span class=p>,</span>
                                <span class=n>_dyld_objc_notify_init</span>      <span class=n>init</span><span class=p>,</span>
                                <span class=n>_dyld_objc_notify_unmapped</span>  <span class=n>unmapped</span><span class=p>);</span>
</code></pre></div><p>从注释中，不难得出：</p><ul><li>仅供<code>objc运行时</code>使用</li><li>注册处理程序，以便在映射、取消映射和初始化 objc 镜像时调用</li><li><code>dyld</code>将会通过一个包含objc-image-info的镜像文件的数组回调<code>mapped</code>函数</li></ul><p>三个参数含义如下：</p><ul><li><code>map_images</code>：dyld 将 image 加载内存时，会触发该函数</li><li><code>load_images</code>：dyld 初始化 image 会触发该函数</li><li><code>unmap_image</code>：dyld 将 image 移除时，会触发该函数</li></ul><p>而这个三个参数，会在<code>registerObjCNotifiers</code>函数中，分别地保存到<code>sNotifyObjCMapped</code>、<code>sNotifyObjCInit</code>、<code>sNotifyObjCUnmapped</code></p><p>得到以下等价关系：</p><ul><li><code>sNotifyObjCMapped</code> == <code>mapped</code> == <code>map_images</code></li><li><code>sNotifyObjCInit</code> == <code>init</code> == <code>load_images</code></li><li><code>sNotifyObjCUnmapped</code> == <code>unmapped</code> == <code>unmap_image</code></li></ul><p><strong>调用时机</strong></p><p>在上一篇中，分析了 <code>load_images</code> 的调用时机，再来看一下 <code>map_images</code> 的调用时机</p><p>在 dyld 源码中搜索<code>sNotifyObjCMapped</code>，发现是在<code>notifyBatchPartial</code>函数中调用的</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>notifyBatchPartial</span><span class=p>(</span><span class=n>dyld_image_states</span> <span class=n>state</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>orLater</span><span class=p>,</span> <span class=n>dyld_image_state_change_handler</span> <span class=n>onlyHandler</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>preflightOnly</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>onlyObjCMappedNotification</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>dyld_image_state_change_handler</span><span class=o>&gt;*</span> <span class=n>handlers</span> <span class=o>=</span> <span class=n>stateToHandlers</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>sBatchHandlers</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>handlers</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>||</span> <span class=p>((</span><span class=n>state</span> <span class=o>==</span> <span class=n>dyld_image_state_bound</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>sNotifyObjCMapped</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>))</span> <span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>imageCount</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
            <span class=p>...</span>
            <span class=k>if</span> <span class=p>(</span> <span class=n>objcImageCount</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
                    <span class=n>dyld3</span><span class=o>::</span><span class=n>ScopedTimer</span> <span class=n>timer</span><span class=p>(</span><span class=n>DBG_DYLD_TIMING_OBJC_MAP</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
                    <span class=kt>uint64_t</span> <span class=n>t0</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
                    <span class=c1>// 调用sNotifyObjCMapped
</span><span class=c1></span>                    <span class=p>(</span><span class=o>*</span><span class=n>sNotifyObjCMapped</span><span class=p>)(</span><span class=n>objcImageCount</span><span class=p>,</span> <span class=n>paths</span><span class=p>,</span> <span class=n>mhs</span><span class=p>);</span>
                    <span class=kt>uint64_t</span> <span class=n>t1</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
                    <span class=n>ImageLoader</span><span class=o>::</span><span class=n>fgTotalObjCSetupTime</span> <span class=o>+=</span> <span class=p>(</span><span class=n>t1</span><span class=o>-</span><span class=n>t0</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
      <span class=p>...</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p><code>notifyBatchPartial</code>又是在<code>registerObjCNotifiers</code>中被调用的</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>registerObjCNotifiers</span><span class=p>(</span><span class=n>_dyld_objc_notify_mapped</span> <span class=n>mapped</span><span class=p>,</span> <span class=n>_dyld_objc_notify_init</span> <span class=n>init</span><span class=p>,</span> <span class=n>_dyld_objc_notify_unmapped</span> <span class=n>unmapped</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// record functions to call
</span><span class=c1></span>	<span class=n>sNotifyObjCMapped</span>	<span class=o>=</span> <span class=n>mapped</span><span class=p>;</span>
	<span class=n>sNotifyObjCInit</span>		<span class=o>=</span> <span class=n>init</span><span class=p>;</span>
	<span class=n>sNotifyObjCUnmapped</span> <span class=o>=</span> <span class=n>unmapped</span><span class=p>;</span>

	<span class=c1>// call &#39;mapped&#39; function with all images mapped so far
</span><span class=c1></span>	<span class=k>try</span> <span class=p>{</span>
		<span class=n>notifyBatchPartial</span><span class=p>(</span><span class=n>dyld_image_state_bound</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
	<span class=p>}</span>
	<span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>// ignore request to abort during registration
</span><span class=c1></span>	<span class=p>}</span>

	<span class=c1>// &lt;rdar://problem/32209809&gt; call &#39;init&#39; function on all images already init&#39;ed (below libSystem)
</span><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ImageLoader</span><span class=o>*&gt;::</span><span class=n>iterator</span> <span class=n>it</span><span class=o>=</span><span class=n>sAllImages</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>sAllImages</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>it</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=o>*</span><span class=n>it</span><span class=p>;</span>
		<span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>getState</span><span class=p>()</span> <span class=o>==</span> <span class=n>dyld_image_state_initialized</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>notifyObjC</span><span class=p>()</span> <span class=p>)</span> <span class=p>{</span>
			<span class=n>dyld3</span><span class=o>::</span><span class=n>ScopedTimer</span> <span class=n>timer</span><span class=p>(</span><span class=n>DBG_DYLD_TIMING_OBJC_INIT</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>machHeader</span><span class=p>(),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
			<span class=p>(</span><span class=o>*</span><span class=n>sNotifyObjCInit</span><span class=p>)(</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>getRealPath</span><span class=p>(),</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>machHeader</span><span class=p>());</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>因此，<code>map_images</code> 是先于 <code>load_images</code> 执行</p><h4 id=dyld与objc关联><a href=#dyld与objc关联 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyld与Objc关联</h4><p>综合<strong>dyld的加载流程</strong>，dyld 与 Objc 的关联流程图</p><p><img src=https://w-md.imzsy.design/dyld&objc.png alt=dyld&objc></p><h3 id=map_images><a href=#map_images class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>map_images</h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* map_images
</span><span class=cm>* Process the given images which are being mapped in by dyld.
</span><span class=cm>* Calls ABI-agnostic code after taking ABI-specific locks.
</span><span class=cm>*
</span><span class=cm>* Locking: write-locks runtimeLock
</span><span class=cm>**********************************************************************/</span>
<span class=kt>void</span>
<span class=nf>map_images</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>count</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>paths</span><span class=p>[],</span>
           <span class=k>const</span> <span class=k>struct</span> <span class=nc>mach_header</span> <span class=o>*</span> <span class=k>const</span> <span class=n>mhdrs</span><span class=p>[])</span>
<span class=p>{</span>
    <span class=n>mutex_locker_t</span> <span class=n>lock</span><span class=p>(</span><span class=n>runtimeLock</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>map_images_nolock</span><span class=p>(</span><span class=n>count</span><span class=p>,</span> <span class=n>paths</span><span class=p>,</span> <span class=n>mhdrs</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p><code>map_images</code> 调用 <code>map_images_nolock</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>map_images_nolock</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>mhCount</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>mhPaths</span><span class=p>[],</span>
                  <span class=k>const</span> <span class=k>struct</span> <span class=nc>mach_header</span> <span class=o>*</span> <span class=k>const</span> <span class=n>mhdrs</span><span class=p>[])</span>
<span class=p>{</span>
    <span class=c1>//...省略
</span><span class=c1></span>
    <span class=c1>// Find all images with Objective-C metadata.查找所有带有Objective-C元数据的映像
</span><span class=c1></span>    <span class=n>hCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=c1>// Count classes. Size various table based on the total.计算类的个数
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>totalClasses</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>unoptimizedTotalClasses</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>//代码块：作用域，进行局部处理，即局部处理一些事件
</span><span class=c1></span>    <span class=p>{</span>
        <span class=c1>//...省略
</span><span class=c1></span>    <span class=p>}</span>
    
    <span class=c1>//...省略
</span><span class=c1></span>
    <span class=k>if</span> <span class=p>(</span><span class=n>hCount</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>//加载镜像文件
</span><span class=c1></span>        <span class=n>_read_images</span><span class=p>(</span><span class=n>hList</span><span class=p>,</span> <span class=n>hCount</span><span class=p>,</span> <span class=n>totalClasses</span><span class=p>,</span> <span class=n>unoptimizedTotalClasses</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>firstTime</span> <span class=o>=</span> <span class=n>NO</span><span class=p>;</span>
    
    <span class=c1>// Call image load funcs after everything is set up.一切设置完成后，调用镜像加载功能。
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>func</span> <span class=p>:</span> <span class=n>loadImageFuncs</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>mhCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>func</span><span class=p>(</span><span class=n>mhdrs</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>该函数是在镜像加载到内存时触发调用的，其主要作用是<code>Mach-O</code>文件中<strong>类信息</strong>加载到内存中，核心逻辑都在<code>_read_images</code>函数</p><h4 id=_read_images><a href=#_read_images class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>_read_images</h4><p>通过源码，该函数主要分为以下几个操作：</p><ul><li>创建表</li><li>修复预编译阶段的@selector的混乱问题</li><li>类的重映射</li><li>修复重映射</li><li>修复一些消息</li><li>当类里面有协议时：readProtocol 读取协议</li><li>修复没有被加载的协议</li><li>分类处理</li><li>类的加载处理</li><li>没有被处理的类，优化那些被侵犯的类</li></ul><h5 id=创建表><a href=#创建表 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>创建表</h5><p>在<code>doneOnce</code>流程中通过<code>NXCreateMapTable</code> 创建表，存放类信息，即创建一张类的<code>哈希表``gdb_objc_realized_classes</code>，其目的是为了类查找方便、快捷</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>doneOnce</span><span class=p>)</span> <span class=p>{</span>
     
    <span class=c1>//...省略
</span><span class=c1></span>    
    <span class=c1>// namedClasses
</span><span class=c1></span>    <span class=c1>// Preoptimized classes don&#39;t go in this table.
</span><span class=c1></span>    <span class=c1>// 4/3 is NXMapTable&#39;s load factor
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>namedClassesSize</span> <span class=o>=</span> 
        <span class=p>(</span><span class=n>isPreoptimized</span><span class=p>()</span> <span class=o>?</span> <span class=nl>unoptimizedTotalClasses</span> <span class=p>:</span> <span class=n>totalClasses</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>
    <span class=c1>// 创建表（哈希表key-value），目的是查找快
</span><span class=c1></span>    <span class=n>gdb_objc_realized_classes</span> <span class=o>=</span>
        <span class=n>NXCreateMapTable</span><span class=p>(</span><span class=n>NXStrValueMapPrototype</span><span class=p>,</span> <span class=n>namedClassesSize</span><span class=p>);</span>

    <span class=n>ts</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;IMAGE TIMES: first time tasks&#34;</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><ul><li><code>gdb_objc_realized_classes</code>存储不在共享缓存且已命名的所有类，其容量是类数量的4/3</li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// This is a misnomer: gdb_objc_realized_classes is actually a list of 
</span><span class=c1>// named classes not in the dyld shared cache, whether realized or not.
</span><span class=c1></span><span class=n>NXMapTable</span> <span class=o>*</span><span class=n>gdb_objc_realized_classes</span><span class=p>;</span>  <span class=c1>// exported for debuggers in objc-gdb.h
</span></code></pre></div><h5 id=修复预编译阶段的selector的混乱问题><a href=#修复预编译阶段的selector的混乱问题 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>修复预编译阶段的@selector的混乱问题</h5><p>主要是通过通过<code>_getObjc2SelectorRefs</code>拿到<code>Mach-O</code>中的静态段<code>__objc_selrefs</code>，遍历列表调用<code>sel_registerNameNoLock</code>将<code>SEL</code>添加到<code>namedSelectors</code>哈希表中</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Fix up @selector references 修复@selector引用
</span><span class=c1>//sel 不是简单的字符串，而是带地址的字符串
</span><span class=c1></span><span class=k>static</span> <span class=n>size_t</span> <span class=n>UnfixedSelectors</span><span class=p>;</span>
<span class=p>{</span>
    <span class=n>mutex_locker_t</span> <span class=nf>lock</span><span class=p>(</span><span class=n>selLock</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>hi</span><span class=o>-&gt;</span><span class=n>hasPreoptimizedSelectors</span><span class=p>())</span> <span class=k>continue</span><span class=p>;</span>

        <span class=kt>bool</span> <span class=n>isBundle</span> <span class=o>=</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>isBundle</span><span class=p>();</span>
        <span class=c1>//通过_getObjc2SelectorRefs拿到Mach-O中的静态段__objc_selrefs
</span><span class=c1></span>        <span class=n>SEL</span> <span class=o>*</span><span class=n>sels</span> <span class=o>=</span> <span class=n>_getObjc2SelectorRefs</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
        <span class=n>UnfixedSelectors</span> <span class=o>+=</span> <span class=n>count</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//列表遍历
</span><span class=c1></span>            <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=n>sel_cname</span><span class=p>(</span><span class=n>sels</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
            <span class=c1>//注册sel操作，即将sel添加到
</span><span class=c1></span>            <span class=n>SEL</span> <span class=n>sel</span> <span class=o>=</span> <span class=n>sel_registerNameNoLock</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>isBundle</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>sels</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>sel</span><span class=p>)</span> <span class=p>{</span><span class=c1>//当sel与sels[i]地址不一致时，需要调整为一致的
</span><span class=c1></span>                <span class=n>sels</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>sel</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ul><li><p><code>_getObjc2SelectorRefs</code>：表示获取<code>Mach-O</code>中的静态段<code>__objc_selrefs</code>，还有其他的 Section 获取方法</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cp>#define GETSECT(name, type, sectname)                                   \
</span><span class=cp>    type *name(const headerType *mhdr, size_t *outCount) {              \
</span><span class=cp>        return getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \
</span><span class=cp>    }                                                                   \
</span><span class=cp>    type *name(const header_info *hi, size_t *outCount) {               \
</span><span class=cp>        return getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \
</span><span class=cp>    }
</span><span class=cp></span><span class=c1>//      function name                 content type     section name
</span><span class=c1></span><span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2SelectorRefs</span><span class=p>,</span>        <span class=n>SEL</span><span class=p>,</span>             <span class=s>&#34;__objc_selrefs&#34;</span><span class=p>);</span> 
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2MessageRefs</span><span class=p>,</span>         <span class=n>message_ref_t</span><span class=p>,</span>   <span class=s>&#34;__objc_msgrefs&#34;</span><span class=p>);</span> 
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2ClassRefs</span><span class=p>,</span>           <span class=n>Class</span><span class=p>,</span>           <span class=s>&#34;__objc_classrefs&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2SuperRefs</span><span class=p>,</span>           <span class=n>Class</span><span class=p>,</span>           <span class=s>&#34;__objc_superrefs&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2ClassList</span><span class=p>,</span>           <span class=n>classref_t</span> <span class=k>const</span><span class=p>,</span>      <span class=s>&#34;__objc_classlist&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2NonlazyClassList</span><span class=p>,</span>    <span class=n>classref_t</span> <span class=k>const</span><span class=p>,</span>      <span class=s>&#34;__objc_nlclslist&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2CategoryList</span><span class=p>,</span>        <span class=n>category_t</span> <span class=o>*</span> <span class=k>const</span><span class=p>,</span>    <span class=s>&#34;__objc_catlist&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2CategoryList2</span><span class=p>,</span>       <span class=n>category_t</span> <span class=o>*</span> <span class=k>const</span><span class=p>,</span>    <span class=s>&#34;__objc_catlist2&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2NonlazyCategoryList</span><span class=p>,</span> <span class=n>category_t</span> <span class=o>*</span> <span class=k>const</span><span class=p>,</span>    <span class=s>&#34;__objc_nlcatlist&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2ProtocolList</span><span class=p>,</span>        <span class=n>protocol_t</span> <span class=o>*</span> <span class=k>const</span><span class=p>,</span>    <span class=s>&#34;__objc_protolist&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>_getObjc2ProtocolRefs</span><span class=p>,</span>        <span class=n>protocol_t</span> <span class=o>*</span><span class=p>,</span>    <span class=s>&#34;__objc_protorefs&#34;</span><span class=p>);</span>
<span class=n>GETSECT</span><span class=p>(</span><span class=n>getLibobjcInitializers</span><span class=p>,</span>       <span class=n>UnsignedInitializer</span><span class=p>,</span> <span class=s>&#34;__objc_init_func&#34;</span><span class=p>);</span>
</code></pre></div></li><li><p><code>sel_registerNameNoLock</code>：将 <code>sel</code> 插入 <code>namedSelectors</code> 哈希表中</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>SEL</span> <span class=nf>sel_registerNameNoLock</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>copy</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>__sel_registerName</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>copy</span><span class=p>);</span>  <span class=c1>// NO lock, maybe copy
</span><span class=c1></span><span class=p>}</span>
  
<span class=k>static</span> <span class=n>SEL</span> <span class=nf>__sel_registerName</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>shouldLock</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>copy</span><span class=p>)</span> 
<span class=p>{</span>
    <span class=n>SEL</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  
    <span class=k>if</span> <span class=p>(</span><span class=n>shouldLock</span><span class=p>)</span> <span class=n>selLock</span><span class=p>.</span><span class=n>assertUnlocked</span><span class=p>();</span>
    <span class=k>else</span> <span class=n>selLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
  
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>name</span><span class=p>)</span> <span class=k>return</span> <span class=p>(</span><span class=n>SEL</span><span class=p>)</span><span class=mi>0</span><span class=p>;</span>
  
    <span class=n>result</span> <span class=o>=</span> <span class=n>search_builtins</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>)</span> <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
      
    <span class=n>conditional_mutex_locker_t</span> <span class=n>lock</span><span class=p>(</span><span class=n>selLock</span><span class=p>,</span> <span class=n>shouldLock</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>namedSelectors</span><span class=p>.</span><span class=n>get</span><span class=p>().</span><span class=n>insert</span><span class=p>(</span><span class=n>name</span><span class=p>);</span><span class=c1>//sel插入表
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>second</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// No match. Insert.
</span><span class=c1></span>        <span class=o>*</span><span class=n>it</span><span class=p>.</span><span class=n>first</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>sel_alloc</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>copy</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>SEL</span><span class=p>)</span><span class=o>*</span><span class=n>it</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li></ul><h5 id=类的重映射><a href=#类的重映射 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类的重映射</h5><p>从Mach-O中取出所有类，遍历处理</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Discover classes. Fix up unresolved future classes. Mark bundle classes.
</span><span class=c1></span><span class=kt>bool</span> <span class=n>hasDyldRoots</span> <span class=o>=</span> <span class=n>dyld_shared_cache_some_image_overridden</span><span class=p>();</span>
<span class=c1>//读取类：readClass
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=n>mustReadClasses</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=n>hasDyldRoots</span><span class=p>))</span> <span class=p>{</span>
        <span class=c1>// Image is sufficiently optimized that we need not call readClass()
</span><span class=c1></span>        <span class=k>continue</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>//从编译后的类列表中取出所有类，即从Mach-O中获取静态段__objc_classlist，是一个classref_t类型的指针
</span><span class=c1></span>    <span class=n>classref_t</span> <span class=k>const</span> <span class=o>*</span><span class=n>classlist</span> <span class=o>=</span> <span class=n>_getObjc2ClassList</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>

    <span class=kt>bool</span> <span class=n>headerIsBundle</span> <span class=o>=</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>isBundle</span><span class=p>();</span>
    <span class=kt>bool</span> <span class=n>headerIsPreoptimized</span> <span class=o>=</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>hasPreoptimizedClasses</span><span class=p>();</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=p>(</span><span class=n>Class</span><span class=p>)</span><span class=n>classlist</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=c1>//此时获取的cls只是一个地址
</span><span class=c1></span>        <span class=n>Class</span> <span class=n>newCls</span> <span class=o>=</span> <span class=n>readClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>headerIsBundle</span><span class=p>,</span> <span class=n>headerIsPreoptimized</span><span class=p>);</span> <span class=c1>//读取类，经过这步后，cls获取的值才是一个名字
</span><span class=c1></span>        <span class=c1>//经过调试，并未执行if里面的流程
</span><span class=c1></span>        <span class=c1>//初始化所有懒加载的类需要的内存空间，但是懒加载类的数据现在是没有加载到的，连类都没有初始化
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>newCls</span> <span class=o>!=</span> <span class=n>cls</span>  <span class=o>&amp;&amp;</span>  <span class=n>newCls</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// Class was moved but not deleted. Currently this occurs 
</span><span class=c1></span>            <span class=c1>// only when the new class resolved a future class.
</span><span class=c1></span>            <span class=c1>// Non-lazily realize the class below.
</span><span class=c1></span>            <span class=c1>//将懒加载的类添加到数组中
</span><span class=c1></span>            <span class=n>resolvedFutureClasses</span> <span class=o>=</span> <span class=p>(</span><span class=n>Class</span> <span class=o>*</span><span class=p>)</span>
                <span class=n>realloc</span><span class=p>(</span><span class=n>resolvedFutureClasses</span><span class=p>,</span> 
                        <span class=p>(</span><span class=n>resolvedFutureClassCount</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Class</span><span class=p>));</span>
            <span class=n>resolvedFutureClasses</span><span class=p>[</span><span class=n>resolvedFutureClassCount</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>newCls</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=n>ts</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;IMAGE TIMES: discover classes&#34;</span><span class=p>);</span>
</code></pre></div><p>关于 <code>readClass</code> 函数, 下面会详细分析</p><h5 id=修复重映射><a href=#修复重映射 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>修复重映射</h5><p>将未映射 Class 和 Super Class 重映射，</p><ul><li>调用<code>_getObjc2ClassRefs</code>获取类的引用</li><li>调用<code>_getObjc2SuperRefs</code>获取父类的引用</li><li>通过<code>remapClassRef</code>进行重映射，被</li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Fix up remapped classes 修正重新映射的类
</span><span class=c1>// Class list and nonlazy class list remain unremapped.类列表和非惰性类列表保持未映射
</span><span class=c1>// Class refs and super refs are remapped for message dispatching.类引用和超级引用将重新映射以进行消息分发
</span><span class=c1>//经过调试，并未执行if里面的流程
</span><span class=c1>//将未映射的Class 和 Super Class重映射，被remap的类都是懒加载的类
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>noClassesRemapped</span><span class=p>())</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Class</span> <span class=o>*</span><span class=n>classrefs</span> <span class=o>=</span> <span class=n>_getObjc2ClassRefs</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span><span class=c1>//Mach-O的静态段 __objc_classrefs
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>remapClassRef</span><span class=p>(</span><span class=o>&amp;</span><span class=n>classrefs</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
        <span class=c1>// fixme why doesn&#39;t test future1 catch the absence of this?
</span><span class=c1></span>        <span class=n>classrefs</span> <span class=o>=</span> <span class=n>_getObjc2SuperRefs</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span><span class=c1>//Mach_O中的静态段 __objc_superrefs
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>remapClassRef</span><span class=p>(</span><span class=o>&amp;</span><span class=n>classrefs</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h5 id=修复一些消息><a href=#修复一些消息 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>修复一些消息</h5><p>通过<code>_getObjc2MessageRefs</code>获取到静态段<code>__objc_selrefs</code>，<code>fixupMessageRef</code>遍历将函数指针进行注册，并fix为新的函数指针</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cp>#if SUPPORT_FIXUP
</span><span class=cp></span>    <span class=c1>// Fix up old objc_msgSend_fixup call sites
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// _getObjc2MessageRefs 获取Mach-O的静态段 __objc_msgrefs
</span><span class=c1></span>        <span class=n>message_ref_t</span> <span class=o>*</span><span class=n>refs</span> <span class=o>=</span> <span class=n>_getObjc2MessageRefs</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>PrintVtables</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;VTABLES: repairing %zu unsupported vtable dispatch &#34;</span>
                         <span class=s>&#34;call sites in %s&#34;</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>fname</span><span class=p>());</span>
        <span class=p>}</span>
        <span class=c1>//经过调试，并未执行for里面的流程
</span><span class=c1></span>        <span class=c1>//遍历将函数指针进行注册，并fix为新的函数指针
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>fixupMessageRef</span><span class=p>(</span><span class=n>refs</span><span class=o>+</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=n>ts</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;IMAGE TIMES: fix up objc_msgSend_fixup&#34;</span><span class=p>);</span>
<span class=cp>#endif
</span></code></pre></div><h5 id=当类里面有协议时readprotocol-读取协议><a href=#当类里面有协议时readprotocol-读取协议 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>当类里面有协议时：readProtocol 读取协议</h5><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Discover protocols. Fix up protocol refs. 发现协议。修正协议参考
</span><span class=c1>//遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>extern</span> <span class=n>objc_class</span> <span class=n>OBJC_CLASS_</span><span class=err>$</span><span class=n>_Protocol</span><span class=p>;</span>
    <span class=c1>//cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类
</span><span class=c1></span>    <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=p>(</span><span class=n>Class</span><span class=p>)</span><span class=o>&amp;</span><span class=n>OBJC_CLASS_</span><span class=err>$</span><span class=n>_Protocol</span><span class=p>;</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=c1>//获取protocol哈希表 -- protocol_map
</span><span class=c1></span>    <span class=n>NXMapTable</span> <span class=o>*</span><span class=n>protocol_map</span> <span class=o>=</span> <span class=n>protocols</span><span class=p>();</span>
    <span class=kt>bool</span> <span class=n>isPreoptimized</span> <span class=o>=</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>hasPreoptimizedProtocols</span><span class=p>();</span>

    <span class=c1>// Skip reading protocols if this is an image from the shared cache
</span><span class=c1></span>    <span class=c1>// and we support roots
</span><span class=c1></span>    <span class=c1>// Note, after launch we do need to walk the protocol as the protocol
</span><span class=c1></span>    <span class=c1>// in the shared cache is marked with isCanonical() and that may not
</span><span class=c1></span>    <span class=c1>// be true if some non-shared cache binary was chosen as the canonical
</span><span class=c1></span>    <span class=c1>// definition
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>launchTime</span> <span class=o>&amp;&amp;</span> <span class=n>isPreoptimized</span> <span class=o>&amp;&amp;</span> <span class=n>cacheSupportsProtocolRoots</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>PrintProtocols</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;PROTOCOLS: Skipping reading protocols in image: %s&#34;</span><span class=p>,</span>
                         <span class=n>hi</span><span class=o>-&gt;</span><span class=n>fname</span><span class=p>());</span>
        <span class=p>}</span>
        <span class=k>continue</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>bool</span> <span class=n>isBundle</span> <span class=o>=</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>isBundle</span><span class=p>();</span>
    <span class=c1>//通过_getObjc2ProtocolList 获取到Mach-O中的静态段__objc_protolist协议列表，
</span><span class=c1></span>    <span class=c1>//即从编译器中读取并初始化protocol
</span><span class=c1></span>    <span class=n>protocol_t</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span><span class=n>protolist</span> <span class=o>=</span> <span class=n>_getObjc2ProtocolList</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>//通过添加protocol到protocol_map哈希表中
</span><span class=c1></span>        <span class=n>readProtocol</span><span class=p>(</span><span class=n>protolist</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>cls</span><span class=p>,</span> <span class=n>protocol_map</span><span class=p>,</span> 
                     <span class=n>isPreoptimized</span><span class=p>,</span> <span class=n>isBundle</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ul><li><p>通过<code>protocols()</code>创建<code>protocol_map</code>哈希表</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* protocols
</span><span class=cm>* Returns the protocol name =&gt; protocol map for protocols.
</span><span class=cm>* Locking: runtimeLock must read- or write-locked by the caller
</span><span class=cm>**********************************************************************/</span>
<span class=k>static</span> <span class=n>NXMapTable</span> <span class=o>*</span><span class=nf>protocols</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=n>NXMapTable</span> <span class=o>*</span><span class=n>protocol_map</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
      
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
  
    <span class=n>INIT_ONCE_PTR</span><span class=p>(</span><span class=n>protocol_map</span><span class=p>,</span> 
                  <span class=n>NXCreateMapTable</span><span class=p>(</span><span class=n>NXStrValueMapPrototype</span><span class=p>,</span> <span class=mi>16</span><span class=p>),</span> 
                  <span class=n>NXFreeMapTable</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>);</span>
  
    <span class=k>return</span> <span class=n>protocol_map</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li><li><p>通过<code>_getObjc2ProtocolList</code>获取到Mach-O中的静态段<code>__objc_protolist</code>协议列表</p></li><li><p>循环遍历协议列表，通过<code>readProtocol</code>方法将协议添加到<code>protocol_map</code>哈希表中</p></li></ul><h5 id=修复没有被加载的协议><a href=#修复没有被加载的协议 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>修复没有被加载的协议</h5><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Fix up @protocol references
</span><span class=c1>// Preoptimized images may have the right 
</span><span class=c1>// answer already but we don&#39;t know for sure.
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// At launch time, we know preoptimized image refs are pointing at the
</span><span class=c1></span>    <span class=c1>// shared cache definition of a protocol.  We can skip the check on
</span><span class=c1></span>    <span class=c1>// launch, but have to visit @protocol refs for shared cache images
</span><span class=c1></span>    <span class=c1>// loaded later.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>launchTime</span> <span class=o>&amp;&amp;</span> <span class=n>cacheSupportsProtocolRoots</span> <span class=o>&amp;&amp;</span> <span class=n>hi</span><span class=o>-&gt;</span><span class=n>isPreoptimized</span><span class=p>())</span>
        <span class=k>continue</span><span class=p>;</span>
    <span class=c1>//_getObjc2ProtocolRefs 获取到Mach-O的静态段 __objc_protorefs
</span><span class=c1></span>    <span class=n>protocol_t</span> <span class=o>**</span><span class=n>protolist</span> <span class=o>=</span> <span class=n>_getObjc2ProtocolRefs</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span><span class=c1>//遍历
</span><span class=c1></span>        <span class=c1>//比较当前协议和协议列表中的同一个内存地址的协议是否相同，如果不同则替换
</span><span class=c1></span>        <span class=n>remapProtocolRef</span><span class=p>(</span><span class=o>&amp;</span><span class=n>protolist</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span><span class=c1>//经过代码调试，并未执行
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ul><li><p>通过 <code>_getObjc2ProtocolRefs</code> 获取到Mach-O的静态段 <code>__objc_protorefs</code></p><blockquote><p><em>上面的_getObjc2ProtocolList</em>并不是同一个东西</p></blockquote></li><li><p>遍历通过<code>remapProtocolRef</code>修复协议，<code>remapProtocolRef</code>比较<code>当前协议和协议列表中的同一个内存地址的协议是否相同</code>，如果<code>不同则替换</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cm>/***********************************************************************
</span><span class=cm>* remapProtocolRef
</span><span class=cm>* Fix up a protocol ref, in case the protocol referenced has been reallocated.
</span><span class=cm>* Locking: runtimeLock must be read- or write-locked by the caller
</span><span class=cm>**********************************************************************/</span>
<span class=k>static</span> <span class=n>size_t</span> <span class=n>UnfixedProtocolReferences</span><span class=p>;</span>
<span class=k>static</span> <span class=kt>void</span> <span class=nf>remapProtocolRef</span><span class=p>(</span><span class=n>protocol_t</span> <span class=o>**</span><span class=n>protoref</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
    <span class=c1>//获取协议列表中统一内存地址的协议
</span><span class=c1></span>    <span class=n>protocol_t</span> <span class=o>*</span><span class=n>newproto</span> <span class=o>=</span> <span class=n>remapProtocol</span><span class=p>((</span><span class=n>protocol_ref_t</span><span class=p>)</span><span class=o>*</span><span class=n>protoref</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>protoref</span> <span class=o>!=</span> <span class=n>newproto</span><span class=p>)</span> <span class=p>{</span><span class=c1>//如果当前协议 与 同一内存地址协议不同，则替换
</span><span class=c1></span>        <span class=o>*</span><span class=n>protoref</span> <span class=o>=</span> <span class=n>newproto</span><span class=p>;</span>
        <span class=n>UnfixedProtocolReferences</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li></ul><h5 id=分类处理><a href=#分类处理 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>分类处理</h5><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Discover categories. Only do this after the initial category
</span><span class=c1>// attachment has been done. For categories present at startup,
</span><span class=c1>// discovery is deferred until the first load_images call after
</span><span class=c1>// the call to _dyld_objc_notify_register completes. rdar://problem/53119145
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>didInitialAttachCategories</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>load_categories_nolock</span><span class=p>(</span><span class=n>hi</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>通过注释可知：需要在分类初始化并将数据加载到类后才执行，对于运行时出现的分类，将分类的发现推迟到对<code>_dyld_objc_notify_register</code>的调用完成后的<code>第一个load_images</code>调用为止</p><h5 id=类的加载处理><a href=#类的加载处理 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类的加载处理</h5><p>首先，苹果官方对于非懒加载类的定义是</p><blockquote><p>NonlazyClass is all about a class implementing or not a +load method.</p></blockquote><p>即实现<code>+load</code>方法的类是非懒加载类，否则就是懒加载类</p><p>所以，这里的类正是<code>非懒加载类</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Realize non-lazy classes (for +load methods and static instances) 
</span><span class=c1>// 实现非懒加载的类，对于load方法和静态实例变量
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>EACH_HEADER</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//通过_getObjc2NonlazyClassList获取Mach-O的静态段__objc_nlclslist非懒加载类表
</span><span class=c1></span>    <span class=n>classref_t</span> <span class=k>const</span> <span class=o>*</span><span class=n>classlist</span> <span class=o>=</span> 
        <span class=n>_getObjc2NonlazyClassList</span><span class=p>(</span><span class=n>hi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=n>remapClass</span><span class=p>(</span><span class=n>classlist</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        
        <span class=cm>/** 为探索自己定义的类，辅助代码
</span><span class=cm>         const char *mangledName  = cls-&gt;mangledName();
</span><span class=cm>         const char *PersonName = &#34;Person&#34;;
</span><span class=cm>
</span><span class=cm>         if (strcmp(mangledName, PersonName) == 0) {
</span><span class=cm>             auto kc_ro = (const class_ro_t *)cls-&gt;data();
</span><span class=cm>             printf(&#34;_getObjc2NonlazyClassList: 这个是我要研究的 %s \n&#34;, PersonName);
</span><span class=cm>         }
</span><span class=cm>         **/</span>
      
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

        <span class=n>addClassTableEntry</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span><span class=c1>//插入表，但是前面已经插入过了，所以不会重新插入
</span><span class=c1></span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isSwiftStable</span><span class=p>())</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>swiftMetadataInitializer</span><span class=p>())</span> <span class=p>{</span>
                <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;Swift class %s with a metadata initializer &#34;</span>
                            <span class=s>&#34;is not allowed to be non-lazy&#34;</span><span class=p>,</span>
                            <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
            <span class=p>}</span>
            <span class=c1>// fixme also disallow relocatable classes
</span><span class=c1></span>            <span class=c1>// We can&#39;t disallow all Swift classes because of
</span><span class=c1></span>            <span class=c1>// classes like Swift.__EmptyArrayStorage
</span><span class=c1></span>        <span class=p>}</span>
        <span class=c1>//实现当前的类，因为前面readClass读取到内存的仅仅只有地址+名称，类的data数据并没有加载出来
</span><span class=c1></span>        <span class=c1>//实现所有非懒加载的类(实例化类对象的一些信息，例如rw)
</span><span class=c1></span>        <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>非懒加载类的加载流程：</p><ul><li><code>_getObjc2NonlazyClassList</code>获取Mach-O的静态段<code>__objc_nlclslist</code>非懒加载类表</li><li><code>addClassTableEntry</code>再加载一遍——如果已添加就不会添加进去，确保整个结构都被添加</li><li><code>realizeClassWithoutSwift</code>实现当前的类，加载类的<code>data</code>数据，在<strong>类的重映射</strong>中<code>readClass</code>只加载<code>地址+类名</code></li></ul><h5 id=没有被处理的类优化那些被侵犯的类><a href=#没有被处理的类优化那些被侵犯的类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>没有被处理的类，优化那些被侵犯的类</h5><p>主要是实现没有被处理的类，优化被侵犯的类</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Realize newly-resolved future classes, in case CF manipulates them
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>resolvedFutureClasses</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>resolvedFutureClassCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=n>resolvedFutureClasses</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isSwiftStable</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;Swift class is not allowed to be future&#34;</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=c1>//实现类
</span><span class=c1></span>        <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
        <span class=n>cls</span><span class=o>-&gt;</span><span class=n>setInstancesRequireRawIsaRecursively</span><span class=p>(</span><span class=nb>false</span><span class=cm>/*inherited*/</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=n>free</span><span class=p>(</span><span class=n>resolvedFutureClasses</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>ts</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;IMAGE TIMES: realize future classes&#34;</span><span class=p>);</span>

<span class=k>if</span> <span class=p>(</span><span class=n>DebugNonFragileIvars</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//实现所有类
</span><span class=c1></span>    <span class=n>realizeAllClasses</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><h3 id=readclass><a href=#readclass class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>readClass</h3><p>在执行<code>readClass</code>之前，<code>cls</code>只是一个地址，而经过该函数，<code>cls</code>则成为了一个类的名称，那么 <code>realClass</code> 具体是做了什么</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Class</span> <span class=nf>readClass</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>headerIsBundle</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>headerIsPreoptimized</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>mangledName</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>mangledName</span><span class=p>();</span>
    <span class=c1>// 当前类的父类中存在丢失的 weak-linked 类
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>missingWeakSuperclass</span><span class=p>(</span><span class=n>cls</span><span class=p>))</span> <span class=p>{</span>
        <span class=c1>// No superclass (probably weak-linked). 
</span><span class=c1></span>        <span class=c1>// Disavow any knowledge of this subclass.
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>PrintConnecting</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;CLASS: IGNORING class &#39;%s&#39; with &#34;</span>
                         <span class=s>&#34;missing weak-linked superclass&#34;</span><span class=p>,</span> 
                         <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
        <span class=p>}</span>
        <span class=n>addRemappedClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
        <span class=n>cls</span><span class=o>-&gt;</span><span class=n>superclass</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>nil</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=n>cls</span><span class=o>-&gt;</span><span class=n>fixupBackwardDeployingStableSwift</span><span class=p>();</span>

    <span class=n>Class</span> <span class=n>replacing</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Class</span> <span class=n>newCls</span> <span class=o>=</span> <span class=n>popFutureNamedClass</span><span class=p>(</span><span class=n>mangledName</span><span class=p>))</span> <span class=p>{</span>
        <span class=c1>// This name was previously allocated as a future class.
</span><span class=c1></span>        <span class=c1>// Copy objc_class to future class&#39;s struct.
</span><span class=c1></span>        <span class=c1>// Preserve future&#39;s rw data block.
</span><span class=c1></span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>newCls</span><span class=o>-&gt;</span><span class=n>isAnySwift</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;Can&#39;t complete future class request for &#39;%s&#39; &#34;</span>
                        <span class=s>&#34;because the real class is too big.&#34;</span><span class=p>,</span> 
                        <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
        <span class=p>}</span>
        
        <span class=n>class_rw_t</span> <span class=o>*</span><span class=n>rw</span> <span class=o>=</span> <span class=n>newCls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>();</span>
        <span class=k>const</span> <span class=n>class_ro_t</span> <span class=o>*</span><span class=n>old_ro</span> <span class=o>=</span> <span class=n>rw</span><span class=o>-&gt;</span><span class=n>ro</span><span class=p>();</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>newCls</span><span class=p>,</span> <span class=n>cls</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>objc_class</span><span class=p>));</span>
        <span class=n>rw</span><span class=o>-&gt;</span><span class=n>set_ro</span><span class=p>((</span><span class=n>class_ro_t</span> <span class=o>*</span><span class=p>)</span><span class=n>newCls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>());</span>
        <span class=n>newCls</span><span class=o>-&gt;</span><span class=n>setData</span><span class=p>(</span><span class=n>rw</span><span class=p>);</span>
        <span class=n>freeIfMutable</span><span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>old_ro</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
        <span class=n>free</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>old_ro</span><span class=p>);</span>
        
        <span class=n>addRemappedClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>newCls</span><span class=p>);</span>
        
        <span class=n>replacing</span> <span class=o>=</span> <span class=n>cls</span><span class=p>;</span>
        <span class=n>cls</span> <span class=o>=</span> <span class=n>newCls</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=k>if</span> <span class=p>(</span><span class=n>headerIsPreoptimized</span>  <span class=o>&amp;&amp;</span>  <span class=o>!</span><span class=n>replacing</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// class list built in shared cache
</span><span class=c1></span>        <span class=c1>// fixme strict assert doesn&#39;t work because of duplicates
</span><span class=c1></span>        <span class=c1>// ASSERT(cls == getClass(name));
</span><span class=c1></span>        <span class=n>ASSERT</span><span class=p>(</span><span class=n>getClassExceptSomeSwift</span><span class=p>(</span><span class=n>mangledName</span><span class=p>));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>addNamedClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>mangledName</span><span class=p>,</span> <span class=n>replacing</span><span class=p>);</span>
        <span class=n>addClassTableEntry</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// for future reference: shared cache never contains MH_BUNDLEs
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>headerIsBundle</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>RO_FROM_BUNDLE</span><span class=p>;</span>
        <span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>RO_FROM_BUNDLE</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=k>return</span> <span class=n>cls</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><ul><li><p>当前类的父类中存在丢失的 <code>weak-linked</code> 类，则返回 <code>nil</code></p></li><li><p>通常情况下，是不会进入<code>popFutureNamedClass(mangledName)</code>判断，这是专门针对未来的待处理的类的特殊操作</p></li><li><p><code>addNamedClass</code>：将当前类添加到已创建的<code>gdb_objc_realized_classes</code>哈希表（存储类）</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>addNamedClass</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=n>Class</span> <span class=n>replacing</span> <span class=o>=</span> <span class=n>nil</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
    <span class=n>Class</span> <span class=n>old</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>old</span> <span class=o>=</span> <span class=n>getClassExceptSomeSwift</span><span class=p>(</span><span class=n>name</span><span class=p>))</span>  <span class=o>&amp;&amp;</span>  <span class=n>old</span> <span class=o>!=</span> <span class=n>replacing</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>inform_duplicate</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>old</span><span class=p>,</span> <span class=n>cls</span><span class=p>);</span>
  
        <span class=c1>// getMaybeUnrealizedNonMetaClass uses name lookups.
</span><span class=c1></span>        <span class=c1>// Classes not found by name lookup must be in the
</span><span class=c1></span>        <span class=c1>// secondary meta-&gt;nonmeta table.
</span><span class=c1></span>        <span class=n>addNonMetaClass</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>NXMapInsert</span><span class=p>(</span><span class=n>gdb_objc_realized_classes</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>cls</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>RO_META</span><span class=p>));</span>
  
    <span class=c1>// wrong: constructed classes are already realized when they get here
</span><span class=c1></span>    <span class=c1>// ASSERT(!cls-&gt;isRealized());
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></li><li><p><code>addClassTableEntry</code>：当前类已经初始化，所以要添加到<code>allocatedClasses</code>哈希表（runtime_init函数中初始化）</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span>
<span class=nf>addClassTableEntry</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>addMeta</span> <span class=o>=</span> <span class=nb>true</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
  
    <span class=c1>// This class is allowed to be a known class via the shared cache or via
</span><span class=c1></span>    <span class=c1>// data segments, but it is not allowed to be in the dynamic table already.
</span><span class=c1></span>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>set</span> <span class=o>=</span> <span class=n>objc</span><span class=o>::</span><span class=n>allocatedClasses</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
  
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>set</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>cls</span><span class=p>)</span> <span class=o>==</span> <span class=n>set</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
  
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>isKnownClass</span><span class=p>(</span><span class=n>cls</span><span class=p>))</span>
        <span class=n>set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>addMeta</span><span class=p>)</span>
        <span class=n>addClassTableEntry</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>(),</span> <span class=nb>false</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></li></ul><p>通过 <code>readClass</code> 函数，将 Mach-O 中的类读取到内存中，也就是插入相应的哈希表，但是只保存两个信息：地址和名词，并没有读取并加载<code>data</code>数据</p><h3 id=realizeclasswithoutswift><a href=#realizeclasswithoutswift class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>realizeClassWithoutSwift</h3><p>这个函数是类加载<code>data</code>数据的核心所在，主要包含几个操作：</p><ul><li>读取<code>data</code>数据，设置<code>ro、rw</code></li><li>递归调用<code>realizeClassWithoutSwift</code>完善<code>类的继承链</code></li><li>调用<code>methodizeClass</code>，完善类信息（方法、分类的方法、属性列表、协议列表）</li></ul><h4 id=读取data数据><a href=#读取data数据 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>读取data数据</h4><p>读取类的<code>data</code>数据，并强转为<code>ro</code>，然后初始化<code>rw</code>，将<code>ro</code>拷贝一份到<code>rw</code>中的<code>ro</code></p><blockquote><p>关于 <code>ro</code> 和 <code>rw</code> 结构，可以在<a href=../Class-structure>『iOS底层原理探索-类的结构分析』</a>查看</p></blockquote><ul><li><code>ro</code>表示readOnly，是在编译时就已经确定了内存</li><li><code>rw</code>表示<code>readWrite</code>，由于其动态性，可能会往类中添加属性、方法、添加协议</li></ul><blockquote><p>在<strong>WWDC 2020</strong>中对内存优化的说明：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2020%2F10163%2F" target=_blank rel=noopener>Advancements in the Objective-C runtime - WWDC 2020 - Videos - Apple Developer</a></p><p>由于 <code>rw</code> 是存储运行时产生的数据，但并不是所有的类都会在运行时修改。因此，在<code>class_rw_t</code> 加入 <code>class_rw_ext_t</code>结构，当需要时，才会分配内存</p><p>所以，<code>rw</code>属于<code>dirty memory</code>，<code>ro</code>属于<code>clean memory</code></p></blockquote><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// fixme verify class is not in an un-dlopened part of the shared cache?
</span><span class=c1>// ro -- clean memory，在编译时就已经确定了内存
</span><span class=c1></span><span class=k>auto</span> <span class=n>ro</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>class_ro_t</span> <span class=o>*</span><span class=p>)</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>();</span> <span class=c1>//读取类结构的bits属性
</span><span class=c1></span><span class=k>auto</span> <span class=n>isMeta</span> <span class=o>=</span> <span class=n>ro</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>RO_META</span><span class=p>;</span> <span class=c1>//判断元类
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ro</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>RO_FUTURE</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This was a future class. rw data is already allocated.
</span><span class=c1></span>    <span class=n>rw</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>();</span> <span class=c1>//dirty memory 进行赋值
</span><span class=c1></span>    <span class=n>ro</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>ro</span><span class=p>();</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=o>!</span><span class=n>isMeta</span><span class=p>);</span>
    <span class=n>cls</span><span class=o>-&gt;</span><span class=n>changeInfo</span><span class=p>(</span><span class=n>RW_REALIZED</span><span class=o>|</span><span class=n>RW_REALIZING</span><span class=p>,</span> <span class=n>RW_FUTURE</span><span class=p>);</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span> 
    <span class=c1>// 此时将数据读取进来了，也赋值完毕了
</span><span class=c1></span>    <span class=c1>// Normal class. Allocate writeable class data.
</span><span class=c1></span>    <span class=n>rw</span> <span class=o>=</span> <span class=n>objc</span><span class=o>::</span><span class=n>zalloc</span><span class=o>&lt;</span><span class=n>class_rw_t</span><span class=o>&gt;</span><span class=p>();</span> <span class=c1>// 申请开辟zalloc -- rw
</span><span class=c1></span>    <span class=n>rw</span><span class=o>-&gt;</span><span class=n>set_ro</span><span class=p>(</span><span class=n>ro</span><span class=p>);</span><span class=c1>// rw中的ro设置为临时变量ro
</span><span class=c1></span>    <span class=n>rw</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>RW_REALIZED</span><span class=o>|</span><span class=n>RW_REALIZING</span><span class=o>|</span><span class=n>isMeta</span><span class=p>;</span>
    <span class=n>cls</span><span class=o>-&gt;</span><span class=n>setData</span><span class=p>(</span><span class=n>rw</span><span class=p>);</span><span class=c1>// 将cls的data赋值为rw形式
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h4 id=递归调用realizeclasswithoutswift><a href=#递归调用realizeclasswithoutswift class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>递归调用realizeClassWithoutSwift</h4><p>递归调用<code>realizeClassWithoutSwift</code>完善类的继承链，并处理当前类、父类、元类</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=p>)</span> <span class=k>return</span> <span class=n>nil</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>())</span> <span class=k>return</span> <span class=n>cls</span><span class=p>;</span>
<span class=p>...</span>
<span class=n>supercls</span> <span class=o>=</span> <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>remapClass</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>superclass</span><span class=p>));</span>
<span class=n>metacls</span> <span class=o>=</span> <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>remapClass</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>()));</span>
<span class=p>...</span>
<span class=c1>// Update superclass and metaclass in case of remapping
</span><span class=c1></span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>superclass</span> <span class=o>=</span> <span class=n>supercls</span><span class=p>;</span>
<span class=n>cls</span><span class=o>-&gt;</span><span class=n>initClassIsa</span><span class=p>(</span><span class=n>metacls</span><span class=p>);</span>
<span class=p>...</span>
<span class=c1>// Connect this class to its superclass&#39;s subclass lists
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>supercls</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>addSubclass</span><span class=p>(</span><span class=n>supercls</span><span class=p>,</span> <span class=n>cls</span><span class=p>);</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>addRootClass</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><ul><li><p><code>realizeClassWithoutSwift</code>递归调用，当 isa 找到根元类之后，根元类的 isa 是指向自己，并不会返回 nil</p><ul><li>如果类不存在，则返回 nil</li><li>如果类已经实现，则直接返回</li></ul></li><li><p>如果有父类，调用<code>addSubclass</code>将当前类添加为父类的子类</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>addSubclass</span><span class=p>(</span><span class=n>Class</span> <span class=n>supercls</span><span class=p>,</span> <span class=n>Class</span> <span class=n>subcls</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
  
    <span class=k>if</span> <span class=p>(</span><span class=n>supercls</span>  <span class=o>&amp;&amp;</span>  <span class=n>subcls</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>supercls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>subcls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>
  
        <span class=n>objc_debug_realized_class_generation_count</span><span class=o>++</span><span class=p>;</span>
          
        <span class=n>subcls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>nextSiblingClass</span> <span class=o>=</span> <span class=n>supercls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>firstSubclass</span><span class=p>;</span>
        <span class=n>supercls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>firstSubclass</span> <span class=o>=</span> <span class=n>subcls</span><span class=p>;</span>
          
        <span class=p>...</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li></ul><h4 id=调用methodizeclass><a href=#调用methodizeclass class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>调用methodizeClass</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>methodizeClass</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>Class</span> <span class=n>previously</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>

    <span class=kt>bool</span> <span class=n>isMeta</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>isMetaClass</span><span class=p>();</span>
    <span class=k>auto</span> <span class=n>rw</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>();</span> <span class=c1>// 初始化一个rw
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>ro</span> <span class=o>=</span> <span class=n>rw</span><span class=o>-&gt;</span><span class=n>ro</span><span class=p>();</span>
    <span class=k>auto</span> <span class=n>rwe</span> <span class=o>=</span> <span class=n>rw</span><span class=o>-&gt;</span><span class=n>ext</span><span class=p>();</span>
    
    <span class=p>...</span>

    <span class=c1>// Install methods and properties that the class implements itself.
</span><span class=c1></span>    <span class=c1>// 添加方法
</span><span class=c1></span>    <span class=n>method_list_t</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=n>ro</span><span class=o>-&gt;</span><span class=n>baseMethods</span><span class=p>();</span><span class=c1>//获取ro的baseMethods
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>prepareMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>YES</span><span class=p>,</span> <span class=n>isBundleClass</span><span class=p>(</span><span class=n>cls</span><span class=p>));</span><span class=c1>//methods进行排序
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>rwe</span><span class=p>)</span> <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>methods</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=o>&amp;</span><span class=n>list</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span><span class=c1>//对rwe进行处理
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// 加入属性
</span><span class=c1></span>    <span class=n>property_list_t</span> <span class=o>*</span><span class=n>proplist</span> <span class=o>=</span> <span class=n>ro</span><span class=o>-&gt;</span><span class=n>baseProperties</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>rwe</span> <span class=o>&amp;&amp;</span> <span class=n>proplist</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>properties</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proplist</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// 加入协议
</span><span class=c1></span>    <span class=n>protocol_list_t</span> <span class=o>*</span><span class=n>protolist</span> <span class=o>=</span> <span class=n>ro</span><span class=o>-&gt;</span><span class=n>baseProtocols</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>rwe</span> <span class=o>&amp;&amp;</span> <span class=n>protolist</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>protocols</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=o>&amp;</span><span class=n>protolist</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Root classes get bonus method implementations if they don&#39;t have 
</span><span class=c1></span>    <span class=c1>// them already. These apply before category replacements.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRootMetaclass</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// root metaclass
</span><span class=c1></span>        <span class=n>addMethod</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=n>initialize</span><span class=p>),</span> <span class=p>(</span><span class=n>IMP</span><span class=p>)</span><span class=o>&amp;</span><span class=n>objc_noop_imp</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=n>NO</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Attach categories.
</span><span class=c1></span>    <span class=c1>// 加入分类中的方法
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>previously</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>isMeta</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>objc</span><span class=o>::</span><span class=n>unattachedCategories</span><span class=p>.</span><span class=n>attachToClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>previously</span><span class=p>,</span>
                                                     <span class=n>ATTACH_METACLASS</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// When a class relocates, categories with class methods
</span><span class=c1></span>            <span class=c1>// may be registered on the class itself rather than on
</span><span class=c1></span>            <span class=c1>// the metaclass. Tell attachToClass to look for those.
</span><span class=c1></span>            <span class=n>objc</span><span class=o>::</span><span class=n>unattachedCategories</span><span class=p>.</span><span class=n>attachToClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>previously</span><span class=p>,</span>
                                                     <span class=n>ATTACH_CLASS_AND_METACLASS</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>objc</span><span class=o>::</span><span class=n>unattachedCategories</span><span class=p>.</span><span class=n>attachToClass</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>cls</span><span class=p>,</span>
                                             <span class=n>isMeta</span> <span class=o>?</span> <span class=nl>ATTACH_METACLASS</span> <span class=p>:</span> <span class=n>ATTACH_CLASS</span><span class=p>);</span>
    <span class=p>....</span>
<span class=p>}</span>
</code></pre></div><p>根据源码，<code>methodizeClass</code>主要是从<code>ro</code>中读取<code>方法列表（包括分类）、属性列表、协议列表</code>赋值给<code>rw</code></p><p>下面以添加方法列表为例</p><ul><li>获取 <code>ro</code> 的 <code>baseMethodList</code>，即方法列表</li><li>调用<code>prepareMethodLists</code>对方法列表进行排序</li><li>调用<code>rwe</code>中<code>methods</code>的<code>attachLists</code>插入方法</li></ul><p><strong>方法排序</strong></p><blockquote><p>在慢速查找流程中，方法的查找是根据二分查找算法，即<code>SEL-IMP</code>存储是有序的</p><p>具体查找过程可在<a href=../message>『iOS底层原理探索-消息查找』</a>查看</p></blockquote><p><code>prepareMethodLists</code>正是将从 <code>ro</code> 中读取到的方法列表进行排序，排序的关键函数是<code>fixupMethodList</code>，根据函数实现，不难发现排序的依据：<code>selector address</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> 
<span class=nf>prepareMethodLists</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>method_list_t</span> <span class=o>**</span><span class=n>addedLists</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addedCount</span><span class=p>,</span>
                   <span class=kt>bool</span> <span class=n>baseMethods</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>methodsFromBundle</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>

    <span class=c1>// Add method lists to array.
</span><span class=c1></span>    <span class=c1>// Reallocate un-fixed method lists.
</span><span class=c1></span>    <span class=c1>// The new methods are PREPENDED to the method list array.
</span><span class=c1></span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>addedCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>method_list_t</span> <span class=o>*</span><span class=n>mlist</span> <span class=o>=</span> <span class=n>addedLists</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>mlist</span><span class=p>);</span>

        <span class=c1>// Fixup selectors if necessary
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isFixedUp</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>fixupMethodList</span><span class=p>(</span><span class=n>mlist</span><span class=p>,</span> <span class=n>methodsFromBundle</span><span class=p>,</span> <span class=nb>true</span><span class=cm>/*sort*/</span><span class=p>);</span><span class=c1>//排序
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>
    
    <span class=p>...</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>void</span> 
<span class=nf>fixupMethodList</span><span class=p>(</span><span class=n>method_list_t</span> <span class=o>*</span><span class=n>mlist</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>bundleCopy</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>sort</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isFixedUp</span><span class=p>());</span>

    <span class=c1>// fixme lock less in attachMethodLists ?
</span><span class=c1></span>    <span class=c1>// dyld3 may have already uniqued, but not sorted, the list
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isUniqued</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>mutex_locker_t</span> <span class=n>lock</span><span class=p>(</span><span class=n>selLock</span><span class=p>);</span>
    
        <span class=c1>// Unique selectors in list.
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>meth</span> <span class=p>:</span> <span class=o>*</span><span class=n>mlist</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=n>sel_cname</span><span class=p>(</span><span class=n>meth</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
            <span class=n>meth</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>sel_registerNameNoLock</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>bundleCopy</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Sort by selector address.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sort</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>method_t</span><span class=o>::</span><span class=n>SortBySELAddress</span> <span class=n>sorter</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>stable_sort</span><span class=p>(</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>(),</span> <span class=n>mlist</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>(),</span> <span class=n>sorter</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=c1>// Mark method list as uniqued and sorted
</span><span class=c1></span>    <span class=n>mlist</span><span class=o>-&gt;</span><span class=n>setFixedUp</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p><strong>attachLists</strong></p><p>方法、属性、协议都是直接通过<code>attachLists</code>插入的，这是因为这三者的数据结构都是类似的，都是二维数组</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>method_list_t</span> <span class=o>:</span> <span class=n>entsize_list_tt</span><span class=o>&lt;</span><span class=n>method_t</span><span class=p>,</span> <span class=n>method_list_t</span><span class=p>,</span> <span class=mh>0x3</span><span class=o>&gt;</span> 

<span class=k>struct</span> <span class=nc>property_list_t</span> <span class=o>:</span> <span class=n>entsize_list_tt</span><span class=o>&lt;</span><span class=n>property_t</span><span class=p>,</span> <span class=n>property_list_t</span><span class=p>,</span> <span class=mi>0</span><span class=o>&gt;</span> 

<span class=k>struct</span> <span class=nc>protocol_list_t</span> <span class=p>{</span>
    <span class=c1>// count is pointer-sized by accident.
</span><span class=c1></span>    <span class=n>uintptr_t</span> <span class=n>count</span><span class=p>;</span>
    <span class=n>protocol_ref_t</span> <span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=c1>// variable-size
</span><span class=c1></span>
    <span class=n>size_t</span> <span class=nf>byteSize</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
        <span class=k>return</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)</span> <span class=o>+</span> <span class=n>count</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=p>}</span>

    <span class=n>protocol_list_t</span> <span class=o>*</span><span class=nf>duplicate</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>protocol_list_t</span> <span class=o>*</span><span class=p>)</span><span class=n>memdup</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>byteSize</span><span class=p>());</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p>再来看一下具体插入操作</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>attachLists</span><span class=p>(</span><span class=n>List</span><span class=o>*</span> <span class=k>const</span> <span class=o>*</span> <span class=n>addedLists</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>addedCount</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>addedCount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>hasArray</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// many lists -&gt; many lists
</span><span class=c1></span>        <span class=c1>//计算数组中旧lists的大小
</span><span class=c1></span>        <span class=kt>uint32_t</span> <span class=n>oldCount</span> <span class=o>=</span> <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
        <span class=c1>//计算新的容量大小 = 旧数据大小+新数据大小
</span><span class=c1></span>        <span class=kt>uint32_t</span> <span class=n>newCount</span> <span class=o>=</span> <span class=n>oldCount</span> <span class=o>+</span> <span class=n>addedCount</span><span class=p>;</span>
        <span class=c1>//根据新的容量大小，开辟一个数组，类型是 array_t，通过array()获取
</span><span class=c1></span>        <span class=n>setArray</span><span class=p>((</span><span class=n>array_t</span> <span class=o>*</span><span class=p>)</span><span class=n>realloc</span><span class=p>(</span><span class=n>array</span><span class=p>(),</span> <span class=n>array_t</span><span class=o>::</span><span class=n>byteSize</span><span class=p>(</span><span class=n>newCount</span><span class=p>)));</span>
        <span class=c1>//设置数组大小
</span><span class=c1></span>        <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=n>newCount</span><span class=p>;</span>
        <span class=c1>//旧的数据从 addedCount 数组下标开始 存放旧的lists，大小为 旧数据大小 * 单个旧list大小
</span><span class=c1></span>        <span class=n>memmove</span><span class=p>(</span><span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span> <span class=o>+</span> <span class=n>addedCount</span><span class=p>,</span> <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>,</span> 
                <span class=n>oldCount</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
        <span class=c1>//新数据从数组 首位置开始存储，存放新的lists，大小为 新数据大小 * 单个list大小
</span><span class=c1></span>        <span class=n>memcpy</span><span class=p>(</span>
               <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>,</span> <span class=n>addedLists</span><span class=p>,</span> 
               <span class=n>addedCount</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list</span>  <span class=o>&amp;&amp;</span>  <span class=n>addedCount</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 0 lists -&gt; 1 list
</span><span class=c1></span>        <span class=n>list</span> <span class=o>=</span> <span class=n>addedLists</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=c1>//将list加入mlists的第一个元素，此时的list是一个一维数组
</span><span class=c1></span>    <span class=p>}</span> 
    <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 1 list -&gt; many lists 有了一个list，有往里加很多list
</span><span class=c1></span>        <span class=c1>//获取旧的list
</span><span class=c1></span>        <span class=n>List</span><span class=o>*</span> <span class=n>oldList</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
        <span class=kt>uint32_t</span> <span class=n>oldCount</span> <span class=o>=</span> <span class=n>oldList</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
        <span class=c1>//计算容量和 = 旧list个数+新lists的个数
</span><span class=c1></span>        <span class=kt>uint32_t</span> <span class=n>newCount</span> <span class=o>=</span> <span class=n>oldCount</span> <span class=o>+</span> <span class=n>addedCount</span><span class=p>;</span>
        <span class=c1>//开辟一个容量和大小的集合，类型是 array_t，即创建一个数组，放到array中，通过array()获取
</span><span class=c1></span>        <span class=n>setArray</span><span class=p>((</span><span class=n>array_t</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>array_t</span><span class=o>::</span><span class=n>byteSize</span><span class=p>(</span><span class=n>newCount</span><span class=p>)));</span>
        <span class=c1>//设置数组的大小
</span><span class=c1></span>        <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=n>newCount</span><span class=p>;</span>
        <span class=c1>//判断old是否存在，old肯定是存在的，将旧的list放入到数组的末尾
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>oldList</span><span class=p>)</span> <span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>[</span><span class=n>addedCount</span><span class=p>]</span> <span class=o>=</span> <span class=n>oldList</span><span class=p>;</span>
        <span class=c1>// memcpy（开始位置，放什么，放多大） 是内存平移，从数组起始位置存入新的list
</span><span class=c1></span>        <span class=c1>//其中array()-&gt;lists 表示首位元素位置
</span><span class=c1></span>        <span class=n>memcpy</span><span class=p>(</span><span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>,</span> <span class=n>addedLists</span><span class=p>,</span> 
               <span class=n>addedCount</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>lists</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>不难看出，分为三种情况：</p><ul><li>（多对多）：如果当前调用<code>attachLists</code>的<code>list_array_tt</code>二维数组中有多个一维数组<ul><li>计算原来的容量，即<code>oldCount</code></li><li>计算新的容量 = <code>oldCount</code> + <code>addedCount</code></li><li><code>realloc</code>对容器进行重新分配大小</li><li>通过<code>memmove</code>将原来的数据移动至容器的末尾</li><li>将新的数据<code>memcpy</code>拷贝到容器的起始位置</li></ul></li><li>（零多一）：如果调用<code>attachLists</code>的<code>list_array_tt</code>二维数组为空且新增大小数目为 1<ul><li>直接赋值<code>attachLists</code>的第一个<code>list</code></li></ul></li><li>（一对多）：如果当前调用<code>attachLists</code>的<code>list_array_tt</code>二维数组只有一个一维数组<ul><li>获取旧的list</li><li>计算新的容量 = <code>oldCount</code> + <code>addedCount</code></li><li><code>malloc</code>开辟新的内存，大小为新的容量和</li><li>直接将<code>旧lists</code>赋值到<code>新array()</code>最后一个位置</li><li>把新的数据<code>memcpy</code>拷贝到容器的起始位置</li></ul></li></ul><blockquote><p><code>memmove</code>和<code>memcpy</code>的区别在于：</p><ul><li>在不知道需要平移的内存大小时，需要<code>memmove</code>进行内存平移，保证安全</li><li><code>memcpy</code>从原内存地址的起始位置开始拷贝若干个字节到目标内存地址中，速度快</li></ul></blockquote><p><strong>关于 <code>rwe</code> 的说明</strong></p><p>首先，在<code>realizeClassWithoutSwift</code>中通过<code>rw->set_ro(ro)</code>为 <code>rwe</code> 的 <code>ro</code>赋值，因此 <code>rwe</code> 是已经存在的</p><p>所以，在执行<code>attachLists</code>时</p><ul><li>此时的 <code>rwe</code> 的 <code>methods</code> 没有数据，也就是 <code>0 对 1</code> 流程</li><li>当<code>加入一个分类</code>时，此时 <code>rwe</code> 中的 <code>methods</code> 只有一个 <code>list</code>，也就是 <code>1 对多</code> 流程</li><li>再<code>加入一个分类</code>时，此时 <code>rwe</code> 中的 <code>methods</code> 有两个 <code>list</code>，也就是 <code>多对多</code> 流程</li></ul><h4 id=懒加载类><a href=#懒加载类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>懒加载类</h4><p>上面的加载过程，主要是非懒加载的类，那么对于懒加载呢，也就是<code>+load</code>没有实现的类</p><p>既然是懒加载，那么只有在使用时才会加入到内存中，而调用懒加载类，也就是向其发生消息，回顾之前<code>lookUpImpOrForward</code>函数</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>IMP</span> <span class=nf>lookUpImpOrForward</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>SEL</span> <span class=n>sel</span><span class=p>,</span> <span class=n>id</span> <span class=n>inst</span><span class=p>,</span> 
                       <span class=kt>bool</span> <span class=n>initialize</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>cache</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>resolver</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>cls</span> <span class=o>=</span> <span class=n>realizeClassMaybeSwiftAndLeaveLocked</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>runtimeLock</span><span class=p>);</span>
        <span class=c1>// runtimeLock may have been dropped but is now locked again
</span><span class=c1></span>    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>Class</span>
<span class=nf>realizeClassMaybeSwiftAndLeaveLocked</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>mutex_t</span><span class=o>&amp;</span> <span class=n>lock</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>realizeClassMaybeSwiftMaybeRelock</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>lock</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>Class</span>
<span class=nf>realizeClassMaybeSwiftMaybeRelock</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>mutex_t</span><span class=o>&amp;</span> <span class=n>lock</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>leaveLocked</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>lock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isSwiftStable_ButAllowLegacyForNow</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// Non-Swift class. Realize it now with the lock still held.
</span><span class=c1></span>        <span class=c1>// fixme wrong in the future for objc subclasses of swift classes
</span><span class=c1></span>        <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>leaveLocked</span><span class=p>)</span> <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// Swift class. We need to drop locks and call the Swift
</span><span class=c1></span>        <span class=c1>// runtime to initialize it.
</span><span class=c1></span>        <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
        <span class=n>cls</span> <span class=o>=</span> <span class=n>realizeSwiftClass</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>    <span class=c1>// callback must have provoked realization
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>leaveLocked</span><span class=p>)</span> <span class=n>lock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>cls</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>对于懒加载类，会在首次发送消息时，整个函数调用栈为：<code>lookUpImpOrForward</code> -> <code>realizeClassMaybeSwiftAndLeaveLocked</code> -> <code>realizeClassMaybeSwiftMaybeRelock</code> -> <code>realizeClassWithoutSwift</code></p><p>没错，最终也是会来到<code>realizeClassWithoutSwift</code>进行类的加载</p><h3 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>总结</h3><p><strong>非懒加载类</strong></p><p>从 <strong>dyld 加载</strong>到**_objc_init()**，完善了类加载的前期准备工作，而进入 <code>realizeClassWithoutSwift</code> 才去进行类的加载</p><p>在<code>_read_images</code>函数中，两个关键函数<code>readClass</code>和<code>realizeClassWithoutSwift</code></p><ul><li><code>readClass</code>：读取类，将类的地址与名称，进行重映射</li><li><code>realizeClassWithoutSwift</code>：完善类信息，将类的方法、属性、协议等数据加载到内存中<ul><li><code>methodizeClass</code>：对类的方法列表排序，并加载到内存</li><li><code>attachCategories</code>：分类的数据加载，再后续篇章中分析</li></ul></li></ul><p><strong>懒加载类</strong></p><p>类的加载推迟到第一次发生消息的时候，最终也是调用<code>realizeClassWithoutSwift</code></p></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>