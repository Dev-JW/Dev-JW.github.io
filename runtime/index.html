<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-关联对象 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="分类有一个局限：无法添加实例变量，但是可以通过关联对象的形式去实现 本文将对关联对象进……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/runtime/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-10-20T14:35:29+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/runtime/","name":"iOS底层原理探索-关联对象","description":"分类有一个局限：无法添加实例变量，但是可以通过关联对象的形式去实现 本文将对关联对象进……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-关联对象"><meta property="og:description" content="分类有一个局限：无法添加实例变量，但是可以通过关联对象的形式去实现 本文将对关联对象进……"><meta property="og:url" content="https://dev.hjw.best/runtime/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-关联对象</h1><div class=post-meta><time datetime=2020-10-20T14:35:29+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-10-20</time></div><div class="post-body e-content"><blockquote><p>分类有一个局限：无法添加实例变量，但是可以通过关联对象的形式去实现</p></blockquote><p>本文将对关联对象进行解析，包括两方面的内容：</p><ul><li>使用关联对象为已经存在的类添加属性</li><li>关联对象在底层的实现</li></ul><h3 id=属性><a href=#属性 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>属性</h3><p>当我们在类中声明一个属性时，编译器会自动帮我们生成<strong>实例变量</strong>和 <code>setter、getter</code> 方法</p><p>当存在非常多的属性时，编译器的工作量岂不是非常大，显然不是这样的</p><p>苹果在底层采用<strong>通用原则</strong>的设计模式，为所有的属性提供了同一个入口</p><ul><li><code>setter</code>方法根据修饰符不同调用不同方法，但是最后都会调用`reallySetProperty``</li><li><code>getter</code>方法会调用<code>objc_getProperty</code></li></ul><p><code>reallySetProperty</code>实现，在内部是通过<code>self+内存偏移量</code>得到<code>slot</code>，并根据不同的修饰符将 <code>newValue</code>赋值给 <code>slot</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>reallySetProperty</span><span class=p>(</span><span class=n>id</span> <span class=n>self</span><span class=p>,</span> <span class=n>SEL</span> <span class=n>_cmd</span><span class=p>,</span> <span class=n>id</span> <span class=n>newValue</span><span class=p>,</span> <span class=n>ptrdiff_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>atomic</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>copy</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>mutableCopy</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>object_setClass</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>newValue</span><span class=p>);</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>id</span> <span class=n>oldValue</span><span class=p>;</span>
    <span class=n>id</span> <span class=o>*</span><span class=n>slot</span> <span class=o>=</span> <span class=p>(</span><span class=n>id</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>self</span> <span class=o>+</span> <span class=n>offset</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>copy</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>newValue</span> <span class=o>=</span> <span class=p>[</span><span class=n>newValue</span> <span class=nl>copyWithZone</span><span class=p>:</span><span class=n>nil</span><span class=p>];</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>mutableCopy</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>newValue</span> <span class=o>=</span> <span class=p>[</span><span class=n>newValue</span> <span class=nl>mutableCopyWithZone</span><span class=p>:</span><span class=n>nil</span><span class=p>];</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>slot</span> <span class=o>==</span> <span class=n>newValue</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
        <span class=n>newValue</span> <span class=o>=</span> <span class=n>objc_retain</span><span class=p>(</span><span class=n>newValue</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>atomic</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>oldValue</span> <span class=o>=</span> <span class=o>*</span><span class=n>slot</span><span class=p>;</span>
        <span class=o>*</span><span class=n>slot</span> <span class=o>=</span> <span class=n>newValue</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>spinlock_t</span><span class=o>&amp;</span> <span class=n>slotlock</span> <span class=o>=</span> <span class=n>PropertyLocks</span><span class=p>[</span><span class=n>slot</span><span class=p>];</span>
        <span class=n>slotlock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
        <span class=n>oldValue</span> <span class=o>=</span> <span class=o>*</span><span class=n>slot</span><span class=p>;</span>
        <span class=o>*</span><span class=n>slot</span> <span class=o>=</span> <span class=n>newValue</span><span class=p>;</span>        
        <span class=n>slotlock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=n>objc_release</span><span class=p>(</span><span class=n>oldValue</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p><code>objc_getProperty</code>实现，根据<code>self+内存偏移量</code>得到<code>slot</code>——即<code>value</code>，并将 <code>value</code> 返回</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>id</span> <span class=nf>objc_getProperty</span><span class=p>(</span><span class=n>id</span> <span class=n>self</span><span class=p>,</span> <span class=n>SEL</span> <span class=n>_cmd</span><span class=p>,</span> <span class=n>ptrdiff_t</span> <span class=n>offset</span><span class=p>,</span> <span class=n>BOOL</span> <span class=n>atomic</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>object_getClass</span><span class=p>(</span><span class=n>self</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Retain release world
</span><span class=c1></span>    <span class=n>id</span> <span class=o>*</span><span class=n>slot</span> <span class=o>=</span> <span class=p>(</span><span class=n>id</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>self</span> <span class=o>+</span> <span class=n>offset</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>atomic</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=n>slot</span><span class=p>;</span>
        
    <span class=c1>// Atomic retain release world
</span><span class=c1></span>    <span class=n>spinlock_t</span><span class=o>&amp;</span> <span class=n>slotlock</span> <span class=o>=</span> <span class=n>PropertyLocks</span><span class=p>[</span><span class=n>slot</span><span class=p>];</span>
    <span class=n>slotlock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
    <span class=n>id</span> <span class=n>value</span> <span class=o>=</span> <span class=n>objc_retain</span><span class=p>(</span><span class=o>*</span><span class=n>slot</span><span class=p>);</span>
    <span class=n>slotlock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
    
    <span class=c1>// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
</span><span class=c1></span>    <span class=k>return</span> <span class=n>objc_autoreleaseReturnValue</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>至于哪里调用<code>reallySetProperty</code></p><p>通过堆栈可以发现<code>objc_setProperty_nonatomic_copy</code>会调用，此时的修饰符为<code>nonatomic，copy</code></p><p>而<code>objc_setProperty_nonatomic_copy</code>调用则是在<code>llvm</code>中</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// 声明
</span><span class=c1></span><span class=n>llvm</span><span class=o>::</span><span class=n>FunctionCallee</span> <span class=n>GetOptimizedPropertySetFunction</span><span class=p>(</span><span class=kt>bool</span> <span class=n>atomic</span><span class=p>,</span>
                                                     <span class=kt>bool</span> <span class=n>copy</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>ObjCTypes</span><span class=p>.</span><span class=n>getOptimizedSetPropertyFn</span><span class=p>(</span><span class=n>atomic</span><span class=p>,</span> <span class=n>copy</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>llvm</span><span class=o>::</span><span class=n>FunctionCallee</span> <span class=n>getOptimizedSetPropertyFn</span><span class=p>(</span><span class=kt>bool</span> <span class=n>atomic</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>copy</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>CodeGen</span><span class=o>::</span><span class=n>CodeGenTypes</span> <span class=o>&amp;</span><span class=n>Types</span> <span class=o>=</span> <span class=n>CGM</span><span class=p>.</span><span class=n>getTypes</span><span class=p>();</span>
  <span class=n>ASTContext</span> <span class=o>&amp;</span><span class=n>Ctx</span> <span class=o>=</span> <span class=n>CGM</span><span class=p>.</span><span class=n>getContext</span><span class=p>();</span>
  
  <span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>CanQualType</span><span class=p>,</span><span class=mi>4</span><span class=o>&gt;</span> <span class=n>Params</span><span class=p>;</span>
  <span class=n>CanQualType</span> <span class=n>IdType</span> <span class=o>=</span> <span class=n>Ctx</span><span class=p>.</span><span class=n>getCanonicalParamType</span><span class=p>(</span><span class=n>Ctx</span><span class=p>.</span><span class=n>getObjCIdType</span><span class=p>());</span>
  <span class=n>CanQualType</span> <span class=n>SelType</span> <span class=o>=</span> <span class=n>Ctx</span><span class=p>.</span><span class=n>getCanonicalParamType</span><span class=p>(</span><span class=n>Ctx</span><span class=p>.</span><span class=n>getObjCSelType</span><span class=p>());</span>
  <span class=n>Params</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>IdType</span><span class=p>);</span>
  <span class=n>Params</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>SelType</span><span class=p>);</span>
  <span class=n>Params</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>IdType</span><span class=p>);</span>
  <span class=n>Params</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>Ctx</span><span class=p>.</span><span class=n>getPointerDiffType</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getCanonicalTypeUnqualified</span><span class=p>());</span>
  <span class=n>llvm</span><span class=o>::</span><span class=n>FunctionType</span> <span class=o>*</span><span class=n>FTy</span> <span class=o>=</span>
      <span class=n>Types</span><span class=p>.</span><span class=n>GetFunctionType</span><span class=p>(</span>
        <span class=n>Types</span><span class=p>.</span><span class=n>arrangeBuiltinFunctionDeclaration</span><span class=p>(</span><span class=n>Ctx</span><span class=p>.</span><span class=n>VoidTy</span><span class=p>,</span> <span class=n>Params</span><span class=p>));</span>
  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>atomic</span> <span class=o>&amp;&amp;</span> <span class=n>copy</span><span class=p>)</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;objc_setProperty_atomic_copy&#34;</span><span class=p>;</span>
  <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>atomic</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>copy</span><span class=p>)</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;objc_setProperty_atomic&#34;</span><span class=p>;</span>
  <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>atomic</span> <span class=o>&amp;&amp;</span> <span class=n>copy</span><span class=p>)</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;objc_setProperty_nonatomic_copy&#34;</span><span class=p>;</span>
  <span class=k>else</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;objc_setProperty_nonatomic&#34;</span><span class=p>;</span>

  <span class=k>return</span> <span class=n>CGM</span><span class=p>.</span><span class=n>CreateRuntimeFunction</span><span class=p>(</span><span class=n>FTy</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
<span class=p>}</span>

<span class=c1>// 调用
</span><span class=c1></span><span class=n>llvm</span><span class=o>::</span><span class=n>FunctionCallee</span> <span class=n>setOptimizedPropertyFn</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
<span class=n>llvm</span><span class=o>::</span><span class=n>FunctionCallee</span> <span class=n>setPropertyFn</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>UseOptimizedSetter</span><span class=p>(</span><span class=n>CGM</span><span class=p>))</span> <span class=p>{</span>
  <span class=c1>// 10.8 and iOS 6.0 code and GC is off
</span><span class=c1></span>  <span class=n>setOptimizedPropertyFn</span> <span class=o>=</span>
      <span class=n>CGM</span><span class=p>.</span><span class=n>getObjCRuntime</span><span class=p>().</span><span class=n>GetOptimizedPropertySetFunction</span><span class=p>(</span>
          <span class=n>strategy</span><span class=p>.</span><span class=n>isAtomic</span><span class=p>(),</span> <span class=n>strategy</span><span class=p>.</span><span class=n>isCopy</span><span class=p>());</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>setOptimizedPropertyFn</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>CGM</span><span class=p>.</span><span class=n>ErrorUnsupported</span><span class=p>(</span><span class=n>propImpl</span><span class=p>,</span> <span class=s>&#34;Obj-C optimized setter - NYI&#34;</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
<span class=k>else</span> <span class=p>{</span>
  <span class=n>setPropertyFn</span> <span class=o>=</span> <span class=n>CGM</span><span class=p>.</span><span class=n>getObjCRuntime</span><span class=p>().</span><span class=n>GetPropertySetFunction</span><span class=p>();</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>setPropertyFn</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>CGM</span><span class=p>.</span><span class=n>ErrorUnsupported</span><span class=p>(</span><span class=n>propImpl</span><span class=p>,</span> <span class=s>&#34;Obj-C setter requiring atomic copy&#34;</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=关联对象的应用><a href=#关联对象的应用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>关联对象的应用</h3><p><strong>关联对象的使用</strong>相信已经成为每个 iOS 开发者必备的技能，但是这里还是需要对其介绍</p><h4 id=property><a href=#property class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>@property</h4><p><code>@property</code>可以说是一个 Objective-C 编程中的『宏』，它有<a href=https://zh.wikipedia.org/zh/%E5%85%83%E7%BC%96%E7%A8%8B target=_blank rel=noopener>元编程</a>的思想</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@interface</span> <span class=nc>Person</span> : <span class=nc>NSObject</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>strong</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>

<span class=k>@end</span>
</code></pre></div><p>在类中声明一个<code>name</code>属性时，编译器会自动帮我们做三件事：</p><ul><li>生成实例变量<code>_name</code></li><li>生成 <code>getter</code> 方法 <code>- (NSString *)name</code></li><li>生成 <code>setter</code> 方法 <code>- (void)setName:</code></li></ul><p>既然在类中使用<code>@property</code>声明一个属性，那么在分类中为什么不可以</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@interface</span> <span class=nc>NSObject</span> <span class=nl>(Test)</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>strong</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>test_name</span><span class=p>;</span>

<span class=k>@end</span>
 
<span class=k>@implementation</span> <span class=nc>NSObject</span> <span class=nl>(Test)</span>

<span class=k>@end</span>
</code></pre></div><p>编译，就报这样的警告：<code>test_name</code>属性的存取方法需要手动去实现，或者使用<code>@dynamic</code>在运行时实现这些方法</p><pre><code>Property 'test_name' requires method 'setTest_name:' to be defined - use @dynamic or provide a method implementation in this category

Property 'test_name' requires method 'test_name' to be defined - use @dynamic or provide a method implementation in this category
</code></pre><p>这也意味着，分类中的<code>@property</code>并没有自动生成实例变量以及存取方法，而需要手动实现</p><h4 id=使用关联对象><a href=#使用关联对象 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>使用关联对象</h4><p>下面是通过 Objc运行时提供的关联对象 API 在分类中实现一个伪属性</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=cp>#import &#34;NSObject+Test.h&#34;
</span><span class=cp>#import &lt;objc/runtime.h&gt;
</span><span class=cp></span>
<span class=k>@implementation</span> <span class=nc>NSObject</span> <span class=nl>(Test)</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>setTest_name:</span><span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nv>test_name</span> <span class=p>{</span>
    <span class=n>objc_setAssociatedObject</span><span class=p>(</span><span class=nb>self</span><span class=p>,</span> <span class=k>@selector</span><span class=p>(</span><span class=n>test_name</span><span class=p>),</span> <span class=n>test_name</span><span class=p>,</span> <span class=n>OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class=p>);</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nf>test_name</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>objc_getAssociatedObject</span><span class=p>(</span><span class=nb>self</span><span class=p>,</span> <span class=n>_cmd</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>@end</span>
</code></pre></div><blockquote><p>这里的<code>_cmd</code>指代当前方法的选择子，也就是<code>@seletor(test_name)</code></p></blockquote><p>使用<code>objc_getAssociatedObject</code>和<code>objc_setAssociatedObject</code>来模拟『属性』的存取方法，而使用关联对象模拟实例变量</p><p>解释两个问题：</p><ul><li>为什么向方法中传入<code>@selector(test_name)</code></li><li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>是干什么的</li></ul><p>关于第一个问题，先看一下这两个方法的原型</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>OBJC_EXPORT</span> <span class=kt>void</span>
<span class=nf>objc_setAssociatedObject</span><span class=p>(</span><span class=n>id</span> <span class=n>_Nonnull</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span> <span class=n>_Nonnull</span> <span class=n>key</span><span class=p>,</span>
                         <span class=n>id</span> <span class=n>_Nullable</span> <span class=n>value</span><span class=p>,</span> <span class=n>objc_AssociationPolicy</span> <span class=n>policy</span><span class=p>)</span>
    <span class=n>OBJC_AVAILABLE</span><span class=p>(</span><span class=mf>10.6</span><span class=p>,</span> <span class=mf>3.1</span><span class=p>,</span> <span class=mf>9.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>);</span>

<span class=n>OBJC_EXPORT</span> <span class=n>id</span> <span class=n>_Nullable</span>
<span class=nf>objc_getAssociatedObject</span><span class=p>(</span><span class=n>id</span> <span class=n>_Nonnull</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span> <span class=n>_Nonnull</span> <span class=n>key</span><span class=p>)</span>
    <span class=n>OBJC_AVAILABLE</span><span class=p>(</span><span class=mf>10.6</span><span class=p>,</span> <span class=mf>3.1</span><span class=p>,</span> <span class=mf>9.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>);</span>
</code></pre></div><p><code>@selector(test_name)</code>也就是参数中的<code>key</code>，其实可以使用静态指针<code>static void *</code>类型的参数来代替</p><blockquote><p>这里推荐使用<code>@selector(test_name)</code>作为 <code>key</code>传入，因为这种方式省略了声明参数的代码，并且能很好地保护 <code>key</code> 的唯一性</p></blockquote><p><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>是什么呢？来看一下它的定义</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>typedef</span> <span class=nf>OBJC_ENUM</span><span class=p>(</span><span class=n>uintptr_t</span><span class=p>,</span> <span class=n>objc_AssociationPolicy</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>OBJC_ASSOCIATION_ASSIGN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>           <span class=cm>/**&lt; Specifies a weak reference to the associated object. */</span>
    <span class=n>OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/**&lt; Specifies a strong reference to the associated object. 
</span><span class=cm>                                            *   The association is not made atomically. */</span>
    <span class=n>OBJC_ASSOCIATION_COPY_NONATOMIC</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span>   <span class=cm>/**&lt; Specifies that the associated object is copied. 
</span><span class=cm>                                            *   The association is not made atomically. */</span>
    <span class=n>OBJC_ASSOCIATION_RETAIN</span> <span class=o>=</span> <span class=mo>01401</span><span class=p>,</span>       <span class=cm>/**&lt; Specifies a strong reference to the associated object.
</span><span class=cm>                                            *   The association is made atomically. */</span>
    <span class=n>OBJC_ASSOCIATION_COPY</span> <span class=o>=</span> <span class=mo>01403</span>          <span class=cm>/**&lt; Specifies that the associated object is copied.
</span><span class=cm>                                            *   The association is made atomically. */</span>
<span class=p>};</span>
</code></pre></div><p>从定义的注释中，不难看出：不同的<code>objc_AssociationPolicy</code>对应了不同的属性修饰符策略</p><div class=table-container><table><thead><tr><th>objc_AssociationPolicy</th><th>modifier</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>nonatomic, strong</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>nonatomic, copy</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>atomic, strong</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>atomic, copy</td></tr></tbody></table></div><p>我们在代码中实现的属性<code>test_name</code>就相当于使用了修饰符 <code>nonatomic</code> 和 <code>strong</code></p><h4 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>总结</h4><p><code>@property</code>其实有元编程的思想，它能够自动生成<strong>实例变量以及存取方法</strong>，而这三者构成属性这类似于语法糖的概念，提供了更便利的<strong>点语法</strong>来访问属性：</p><pre><code>self.property &lt;=&gt; [self property]
self.property = value &lt;=&gt; [self setProperty:value]
</code></pre><p>在分类中，因为类的示例变量的布局已经固定，使用<code>@property</code><strong>无法向固定的布局中添加新的实例变量</strong></p><p>因此，我们需要<strong>使用关联对象以及两个方法来模拟构成属性的三个要素</strong></p><h3 id=关联对象的底层实现><a href=#关联对象的底层实现 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>关联对象的底层实现</h3><p>在运行时提供关联对象的 API 有以下：</p><ul><li><p><strong>objc_setAssociatedObject</strong>：使用给定的键和关联策略为给定的对象设置关联的值</p></li><li><p><strong>objc_getAssociatedObject</strong>：返回与给定键的给定对象关联的值</p></li><li><p><strong>objc_removeAssociatedObjects</strong>：删除给定对象的所有关联</p></li></ul><h4 id=objc_setassociatedobject><a href=#objc_setassociatedobject class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>objc_setAssociatedObject</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>objc_setAssociatedObject</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>,</span> <span class=n>id</span> <span class=n>value</span><span class=p>,</span> <span class=n>objc_AssociationPolicy</span> <span class=n>policy</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>SetAssocHook</span><span class=p>.</span><span class=n>get</span><span class=p>()(</span><span class=n>object</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>policy</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>从源码中可以看出：采用<strong>接口模式</strong>的设计模式，起到对外的接口保持不变，内部逻辑的变化不影响外部的调用的作用</p><ul><li><p><code>SetAssocHook</code>是一个封装了函数指针的对象，源码定义为：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=n>ChainedHookFunction</span><span class=o>&lt;</span><span class=n>objc_hook_setAssociatedObject</span><span class=o>&gt;</span> <span class=n>SetAssocHook</span><span class=p>{</span><span class=n>_base_objc_setAssociatedObject</span><span class=p>};</span>
</code></pre></div></li><li><p><code>ChainedHookFunction</code>是用于线程安全的链式钩子函数的存储</p><ul><li>通过 <code>get()</code> 返回调用的值</li><li>通过 <code>set()</code> 注入一个新函数，并返回旧函数，确切地说，<code>set()</code>将旧值写入调用方提供的变量</li><li><code>get()</code> 和 <code>set()</code>使用适当的栅栏使得在新值调用前安全地写入变量</li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Fn</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>ChainedHookFunction</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>Fn</span><span class=o>&gt;</span> <span class=n>hook</span><span class=p>{</span><span class=n>nil</span><span class=p>};</span>
  
<span class=k>public</span><span class=o>:</span>
    <span class=n>ChainedHookFunction</span><span class=p>(</span><span class=n>Fn</span> <span class=n>f</span><span class=p>)</span> <span class=o>:</span> <span class=n>hook</span><span class=p>{</span><span class=n>f</span><span class=p>}</span> <span class=p>{</span> <span class=p>};</span>
  
    <span class=n>Fn</span> <span class=nf>get</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>hook</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
    <span class=p>}</span>
  
    <span class=kt>void</span> <span class=nf>set</span><span class=p>(</span><span class=n>Fn</span> <span class=n>newValue</span><span class=p>,</span> <span class=n>Fn</span> <span class=o>*</span><span class=n>oldVariable</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Fn</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>hook</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
        <span class=k>do</span> <span class=p>{</span>
            <span class=o>*</span><span class=n>oldVariable</span> <span class=o>=</span> <span class=n>oldValue</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>hook</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>oldValue</span><span class=p>,</span> <span class=n>newValue</span><span class=p>,</span>
                                             <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>,</span>
                                             <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>));</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div></li></ul><p>因此，<code>SetAssocHook.get()</code>返回的是传入的函数指针<code>_base_objc_setAssociatedObject</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>SetAssocHook</span><span class=p>.</span><span class=n>get</span><span class=p>()(</span><span class=n>object</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>policy</span><span class=p>)</span> <span class=o>&lt;==&gt;</span> <span class=n>base_objc_setAssociatedObject</span><span class=p>(</span><span class=n>object</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>policy</span><span class=p>)</span>
</code></pre></div><p>底层真正调用的是<code>_base_objc_setAssociatedObject</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span>
<span class=nf>_base_objc_setAssociatedObject</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>,</span> <span class=n>id</span> <span class=n>value</span><span class=p>,</span> <span class=n>objc_AssociationPolicy</span> <span class=n>policy</span><span class=p>)</span>
<span class=p>{</span>
  <span class=n>_object_set_associative_reference</span><span class=p>(</span><span class=n>object</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>policy</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p><code>_object_set_associative_reference</code>才是真正实现关联对象存储的函数</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>_object_set_associative_reference</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>,</span> <span class=n>id</span> <span class=n>value</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>policy</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// This code used to work when nil was passed for object and key. Some code
</span><span class=c1></span>    <span class=c1>// probably relies on that to not crash. Check and handle it explicitly.
</span><span class=c1></span>    <span class=c1>// rdar://problem/44094390
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>object</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>value</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>object</span><span class=o>-&gt;</span><span class=n>getIsa</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>forbidsAssociatedObjects</span><span class=p>())</span>
        <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&#34;</span><span class=p>,</span> <span class=n>object</span><span class=p>,</span> <span class=n>object_getClassName</span><span class=p>(</span><span class=n>object</span><span class=p>));</span>
    <span class=c1>//object封装成一个数组结构类型，类型为DisguisedPtr
</span><span class=c1></span>    <span class=n>DisguisedPtr</span><span class=o>&lt;</span><span class=n>objc_object</span><span class=o>&gt;</span> <span class=n>disguised</span><span class=p>{(</span><span class=n>objc_object</span> <span class=o>*</span><span class=p>)</span><span class=n>object</span><span class=p>};</span><span class=c1>//相当于包装了一下 对象object,便于使用
</span><span class=c1></span>    <span class=c1>// 包装一下 policy - value
</span><span class=c1></span>    <span class=n>ObjcAssociation</span> <span class=n>association</span><span class=p>{</span><span class=n>policy</span><span class=p>,</span> <span class=n>value</span><span class=p>};</span>

    <span class=c1>// retain the new value (if any) outside the lock.
</span><span class=c1></span>    <span class=n>association</span><span class=p>.</span><span class=n>acquireValue</span><span class=p>();</span><span class=c1>//根据策略类型进行处理
</span><span class=c1></span>    <span class=c1>//局部作用域空间
</span><span class=c1></span>    <span class=p>{</span>
        <span class=c1>//初始化manager变量，相当于自动调用AssociationsManager的析构函数进行初始化
</span><span class=c1></span>        <span class=n>AssociationsManager</span> <span class=n>manager</span><span class=p>;</span><span class=c1>//并不是全场唯一，构造函数中加锁只是为了避免重复创建，在这里是可以初始化多个AssociationsManager变量的
</span><span class=c1></span>    
        <span class=n>AssociationsHashMap</span> <span class=o>&amp;</span><span class=n>associations</span><span class=p>(</span><span class=n>manager</span><span class=p>.</span><span class=n>get</span><span class=p>());</span><span class=c1>//AssociationsHashMap 全场唯一
</span><span class=c1></span>
        <span class=k>if</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>auto</span> <span class=n>refs_result</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>disguised</span><span class=p>,</span> <span class=n>ObjectAssociationMap</span><span class=p>{});</span><span class=c1>//返回的结果是一个类对
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>refs_result</span><span class=p>.</span><span class=n>second</span><span class=p>)</span> <span class=p>{</span><span class=c1>//判断第二个存不存在，即bool值是否为true
</span><span class=c1></span>                <span class=cm>/* it&#39;s the first association we make 第一次建立关联*/</span>
                <span class=n>object</span><span class=o>-&gt;</span><span class=n>setHasAssociatedObjects</span><span class=p>();</span><span class=c1>//nonpointerIsa ，标记位true
</span><span class=c1></span>            <span class=p>}</span>

            <span class=cm>/* establish or replace the association 建立或者替换关联*/</span>
            <span class=k>auto</span> <span class=o>&amp;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>refs_result</span><span class=p>.</span><span class=n>first</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span> <span class=c1>//得到一个空的桶子，找到引用对象类型,即第一个元素的second值
</span><span class=c1></span>            <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>refs</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>association</span><span class=p>));</span><span class=c1>//查找当前的key是否有association关联对象
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>result</span><span class=p>.</span><span class=n>second</span><span class=p>)</span> <span class=p>{</span><span class=c1>//如果结果不存在
</span><span class=c1></span>                <span class=n>association</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>first</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span><span class=c1>//如果传的是空值，则移除关联，相当于移除
</span><span class=c1></span>            <span class=k>auto</span> <span class=n>refs_it</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>disguised</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>refs_it</span> <span class=o>!=</span> <span class=n>associations</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
                <span class=k>auto</span> <span class=o>&amp;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>refs_it</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
                <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>refs</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>refs</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
                    <span class=n>association</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span>
                    <span class=n>refs</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>refs</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                        <span class=n>associations</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>refs_it</span><span class=p>);</span>

                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// release the old value (outside of the lock).
</span><span class=c1></span>    <span class=n>association</span><span class=p>.</span><span class=n>releaseHeldValue</span><span class=p>();</span><span class=c1>//释放
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>首先，注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，需要了解其中它们的作用：</p><ul><li><p><strong>AssociationsManager</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>AssociationsManager</span> <span class=p>{</span>
    <span class=k>using</span> <span class=n>Storage</span> <span class=o>=</span> <span class=n>ExplicitInitDenseMap</span><span class=o>&lt;</span><span class=n>DisguisedPtr</span><span class=o>&lt;</span><span class=n>objc_object</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>ObjectAssociationMap</span><span class=o>&gt;</span><span class=p>;</span>
    <span class=k>static</span> <span class=n>Storage</span> <span class=n>_mapStorage</span><span class=p>;</span>
  
<span class=k>public</span><span class=o>:</span>
    <span class=n>AssociationsManager</span><span class=p>()</span>   <span class=p>{</span> <span class=n>AssociationsManagerLock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span> <span class=p>}</span>
    <span class=o>~</span><span class=n>AssociationsManager</span><span class=p>()</span>  <span class=p>{</span> <span class=n>AssociationsManagerLock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span> <span class=p>}</span>
  
    <span class=n>AssociationsHashMap</span> <span class=o>&amp;</span><span class=n>get</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>_mapStorage</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
    <span class=p>}</span>
  
    <span class=k>static</span> <span class=kt>void</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
        <span class=n>_mapStorage</span><span class=p>.</span><span class=n>init</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>这是一个管理类，维护着<code>spinlock_t</code>和<code>AssociationsManager</code>单例，调用构造函数初始化时，会加锁，在析构时会解锁，而 <code>get</code>方法用于获取全局的<code>AssociationsManager</code>单例</p><p>也就是说 <code>AssociationsManager</code> 通过持有一个<a href=https://en.wikipedia.org/wiki/Spinlock target=_blank rel=noopener>自旋锁</a> <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即<strong>每次只会有一个线程对 AssociationsHashMap 进行操作</strong></p></li><li><p><strong>AssociationsHashMap</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>typedef</span> <span class=n>DenseMap</span><span class=o>&lt;</span><span class=n>DisguisedPtr</span><span class=o>&lt;</span><span class=n>objc_object</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>ObjectAssociationMap</span><span class=o>&gt;</span> <span class=n>AssociationsHashMap</span><span class=p>;</span>
  
<span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>DisguisedPtr</span> <span class=p>{</span>
    <span class=n>uintptr_t</span> <span class=n>value</span><span class=p>;</span>
  
    <span class=k>static</span> <span class=n>uintptr_t</span> <span class=nf>disguise</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>-</span><span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>ptr</span><span class=p>;</span>
    <span class=p>}</span>
      <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p><code>DisguisedPtr&lt;T></code>是指针伪装模板类，通过运算使指针隐藏于系统工具(如<code>leaks</code>工具)，同时保持指针的能力，其作用是通过计算把保存的 <code>T</code> 类型的指针隐藏起来，实现指针到整数的映射</p><p><code>DisguisedPtr&lt;objc_object></code>就是将 <code>objc_object</code>类型的指针进行<strong>位运算</strong>「伪装」作为<code>key</code>，</p><p><code>AssociationsHashMap</code>用于存储<code>DisguisedPtr&lt;objc_object></code>到<code>ObjectAssociationMap</code>的映射</p></li><li><p><strong>ObjectAssociationMap</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>typedef</span> <span class=n>DenseMap</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=n>ObjcAssociation</span><span class=o>&gt;</span> <span class=n>ObjectAssociationMap</span><span class=p>;</span>
</code></pre></div><p><code>ObjectAssociationMap</code>用于存储<code>const void *</code>到<code>ObjcAssociation</code>的映射</p></li><li><p><strong>ObjcAssociation</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>ObjcAssociation</span> <span class=p>{</span>
    <span class=n>uintptr_t</span> <span class=n>_policy</span><span class=p>;</span>
    <span class=n>id</span> <span class=n>_value</span><span class=p>;</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>ObjcAssociation</span><span class=p>(</span><span class=n>uintptr_t</span> <span class=n>policy</span><span class=p>,</span> <span class=n>id</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>_policy</span><span class=p>(</span><span class=n>policy</span><span class=p>),</span> <span class=n>_value</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
    <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p><code>ObjcAssociation</code> 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它</p></li></ul><p><strong>存储</strong></p><p>这里举一个简单列子，说明关联对象在内存中以什么形式存储</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
    <span class=k>@autoreleasepool</span> <span class=p>{</span>
        <span class=n>Person</span> <span class=o>*</span><span class=n>obj</span> <span class=o>=</span> <span class=p>[</span><span class=n>Person</span> <span class=n>new</span><span class=p>];</span>
        <span class=n>objc_setAssociatedObject</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=k>@selector</span><span class=p>(</span><span class=n>hello</span><span class=p>),</span> <span class=s>@&#34;Hello&#34;</span><span class=p>,</span> <span class=n>OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>这里的关联对象 <code>ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @"Hello")</code>在内存是这样存储的：</p><p><img src=https://w-md.imzsy.design/image-20201211153708852.png alt=image-20201211153708852></p><p>现在来对<code>_object_set_associative_reference</code>进行分析</p><ol><li><p><code>ObjcAssociation association{policy, value}</code>创建临时的<code>ObjcAssociation</code>对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</p></li><li><p>调用<code>acquireValue</code>对<code>new_value</code>进行 <code>retain</code> 或 <code>copy</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>acquireValue</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>_value</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>_policy</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>OBJC_ASSOCIATION_SETTER_RETAIN</span><span class=p>:</span>
            <span class=n>_value</span> <span class=o>=</span> <span class=n>objc_retain</span><span class=p>(</span><span class=n>_value</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>OBJC_ASSOCIATION_SETTER_COPY</span><span class=p>:</span>
            <span class=n>_value</span> <span class=o>=</span> <span class=p>((</span><span class=n>id</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>id</span><span class=p>,</span> <span class=n>SEL</span><span class=p>))</span><span class=n>objc_msgSend</span><span class=p>)(</span><span class=n>_value</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=n>copy</span><span class=p>));</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li><li><p>初始化一个<code>AssociationsManager</code>，并获取唯一的保存关联对象的哈希表<code>AssociationsHashMap</code></p></li><li><p>先使用 <code>disguised</code> 作为 <code>key</code>，寻找对应的<code>ObjectAssociationMap</code>，并会传入一个空的<code>ObjectAssociationMap</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=n>refs_result</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>disguised</span><span class=p>,</span> <span class=n>ObjectAssociationMap</span><span class=p>{});</span>
</code></pre></div><ul><li>如果找到，会将找到的<code>ObjectAssociationMap</code>进行装配为类对，返回值的 <code>second = flase</code></li><li>如果没有找到，将 <code>disguised</code> 作为 <code>key</code>，传入的空<code>ObjectAssociationMap</code>做为值，插入到<code>AssociationsHashMap</code>，并装配为类对，返回值的 <code>second = true</code></li></ul></li><li><p>如果返回的<code>refs_result.second</code>为<code>true</code>，会调用<code>setHasAssociatedObjects</code>——对于<code>nonpointerIsa</code>更新<code>isa</code>的<code>has_assoc</code>为<code>true</code>，表明当前对象含有<strong>关联对象</strong></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=kt>void</span>
<span class=n>objc_object</span><span class=o>::</span><span class=n>setHasAssociatedObjects</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>isTaggedPointer</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
   
 <span class=nl>retry</span><span class=p>:</span>
    <span class=n>isa_t</span> <span class=n>oldisa</span> <span class=o>=</span> <span class=n>LoadExclusive</span><span class=p>(</span><span class=o>&amp;</span><span class=n>isa</span><span class=p>.</span><span class=n>bits</span><span class=p>);</span>
    <span class=n>isa_t</span> <span class=n>newisa</span> <span class=o>=</span> <span class=n>oldisa</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>newisa</span><span class=p>.</span><span class=n>nonpointer</span>  <span class=o>||</span>  <span class=n>newisa</span><span class=p>.</span><span class=n>has_assoc</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ClearExclusive</span><span class=p>(</span><span class=o>&amp;</span><span class=n>isa</span><span class=p>.</span><span class=n>bits</span><span class=p>);</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>newisa</span><span class=p>.</span><span class=n>has_assoc</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>StoreExclusive</span><span class=p>(</span><span class=o>&amp;</span><span class=n>isa</span><span class=p>.</span><span class=n>bits</span><span class=p>,</span> <span class=n>oldisa</span><span class=p>.</span><span class=n>bits</span><span class=p>,</span> <span class=n>newisa</span><span class=p>.</span><span class=n>bits</span><span class=p>))</span> <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li><li><p>再根据传入的<code>key</code>，寻找相应的<code>ObjectAssociation</code>，并将临时的<code>ObjcAssociation</code>对象传入</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=o>&amp;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>refs_result</span><span class=p>.</span><span class=n>first</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span> <span class=c1>// 相当于获取ObjectAssociationMap
</span><span class=c1></span><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>refs</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>association</span><span class=p>));</span> <span class=c1>// 查找ObjectAssociation
</span></code></pre></div><p>这里和上面查找<code>ObjectAssociationMap</code>类似</p><ul><li>如果找到，则返回的类对<code>second</code>为<code>true</code>，需要将进行替换<code>association.swap(result.first->second)</code></li><li>如果没有找到，则会将<code>ObjcAssociation</code>插入到<code>ObjectAssociationMap</code>中</li></ul></li><li><p>最后调用<code>releaseHeldValue</code>，将释放关联对象的值</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>releaseHeldValue</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>_value</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>_policy</span> <span class=o>&amp;</span> <span class=n>OBJC_ASSOCIATION_SETTER_RETAIN</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>objc_release</span><span class=p>(</span><span class=n>_value</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li></ol><p>到这里，传入 <code>value</code> 有值的实现就结束了</p><p><strong>value==nil</strong></p><p>如果传入的 <code>value == nil</code>，就说明需要删除对应 <code>key</code> 的关联对象，也就是走 <code>else</code> 流程</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=n>refs_it</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>disguised</span><span class=p>);</span> <span class=c1>// 获取ObjectAssociationMap
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>refs_it</span> <span class=o>!=</span> <span class=n>associations</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>refs_it</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>refs</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span> <span class=c1>// 获取ObjectAssociation
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>refs</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>association</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span>
        <span class=n>refs</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span> <span class=c1>// 擦除ObjectAssociation
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>refs</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// ObjectAssociationMap为空
</span><span class=c1></span>            <span class=n>associations</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>refs_it</span><span class=p>);</span> <span class=c1>// 擦除ObjectAssociationMapc
</span><span class=c1></span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>该流程中，与前面的唯一不同的就是，需要调用 <code>erase</code> 函数，擦除 <code>ObjectAssociationMap</code> 中 <code>key</code> 对应的节点，如果<code>ObjectAssociationMap</code>为空了，还需要从将其从 <code>AssociationHashMap</code> 中擦除</p><h4 id=objc_getassociatedobject><a href=#objc_getassociatedobject class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>objc_getAssociatedObject</h4><p>既然已经对<code>objc_setAssociatedObject</code>的实现比较熟悉了，那么对于<code>objc_getAssociatedObject</code>就比较容易理解了</p><p><code>objc_setAssociatedObject</code>方法的底层真正实现是<code>_object_get_associative_reference</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>id</span>
<span class=nf>objc_getAssociatedObject</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>_object_get_associative_reference</span><span class=p>(</span><span class=n>object</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>而<code>_object_get_associative_reference</code>相对来说，实现更简单一点</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>id</span>
<span class=nf>_object_get_associative_reference</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ObjcAssociation</span> <span class=n>association</span><span class=p>{};</span><span class=c1>//创建空的关联对象
</span><span class=c1></span>
    <span class=p>{</span>
        <span class=n>AssociationsManager</span> <span class=n>manager</span><span class=p>;</span><span class=c1>//创建一个AssociationsManager管理类
</span><span class=c1></span>        <span class=n>AssociationsHashMap</span> <span class=o>&amp;</span><span class=n>associations</span><span class=p>(</span><span class=n>manager</span><span class=p>.</span><span class=n>get</span><span class=p>());</span><span class=c1>//获取全局唯一的静态哈希map
</span><span class=c1></span>        <span class=n>AssociationsHashMap</span><span class=o>::</span><span class=n>iterator</span> <span class=n>i</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>find</span><span class=p>((</span><span class=n>objc_object</span> <span class=o>*</span><span class=p>)</span><span class=n>object</span><span class=p>);</span><span class=c1>//找到迭代器，即获取buckets
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>associations</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span><span class=c1>//如果这个迭代查询器不是最后一个 获取
</span><span class=c1></span>            <span class=n>ObjectAssociationMap</span> <span class=o>&amp;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>i</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span> <span class=c1>//找到ObjectAssociationMap的迭代查询器获取一个经过属性修饰符修饰的value
</span><span class=c1></span>            <span class=n>ObjectAssociationMap</span><span class=o>::</span><span class=n>iterator</span> <span class=n>j</span> <span class=o>=</span> <span class=n>refs</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=c1>//根据key查找ObjectAssociationMap，即获取bucket
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>!=</span> <span class=n>refs</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
                <span class=n>association</span> <span class=o>=</span> <span class=n>j</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span><span class=c1>//获取ObjcAssociation
</span><span class=c1></span>                <span class=n>association</span><span class=p>.</span><span class=n>retainReturnedValue</span><span class=p>();</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>association</span><span class=p>.</span><span class=n>autoreleaseReturnedValue</span><span class=p>();</span><span class=c1>//返回value
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p><strong>寻找关联对象的逻辑</strong></p><ul><li><p>创建空的关联对象，<code>AssociationsManager</code>管理类</p></li><li><p>获取静态哈希表 <code>AssociationsHashMap</code></p></li><li><p>以<code>object</code>为<code>key</code>查找<code>ObjectAssociationMap</code></p></li><li><p>以<code>void *key</code>为<code>key</code>查找<code>ObjectAssociation</code></p></li><li><p>再找到<code>ObjectAssociation</code>后，调用<code>retainReturnedValue</code>，根据<code>policy</code>是否需要<code>retain</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>retainReturnedValue</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>_value</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>_policy</span> <span class=o>&amp;</span> <span class=n>OBJC_ASSOCIATION_GETTER_RETAIN</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>objc_retain</span><span class=p>(</span><span class=n>_value</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li><li><p>最后返回关联对象的值，会调用一次<code>autoreleaseReturnedValue</code>，根据<code>policy</code>是否需要<code>autorelease</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=n>id</span> <span class=nf>autoreleaseReturnedValue</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>slowpath</span><span class=p>(</span><span class=n>_value</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>_policy</span> <span class=o>&amp;</span> <span class=n>OBJC_ASSOCIATION_GETTER_AUTORELEASE</span><span class=p>)))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>objc_autorelease</span><span class=p>(</span><span class=n>_value</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>_value</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li></ul><h4 id=objc_removeassociatedobjects><a href=#objc_removeassociatedobjects class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>objc_removeAssociatedObjects</h4><p>关于<code>objc_removeAssociatedObjects</code>方法，其实现也相对简单</p><p>为了加速移除对象的关联对象的速度，我们会通过标记位 <code>has_assoc</code> 来避免不必要的方法调用</p><p>在确认了对象和关联对象的存在之后，才会调用 <code>_object_remove_assocations</code> 方法移除对象上所有的关联对象：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>objc_removeAssociatedObjects</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>)</span> 
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>object</span> <span class=o>&amp;&amp;</span> <span class=n>object</span><span class=o>-&gt;</span><span class=n>hasAssociatedObjects</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>_object_remove_assocations</span><span class=p>(</span><span class=n>object</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p><code>_object_remove_assocations</code>实现也比较简单</p><ul><li>将对象包含的所有关联对象加入到一个迭代器中</li><li>然后对所有的<code>ObjcAssociation</code>调用<code>releaseHeldValue</code>方法，<code>release</code>释放不需要的值</li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>_object_remove_assocations</span><span class=p>(</span><span class=n>id</span> <span class=n>object</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ObjectAssociationMap</span> <span class=n>refs</span><span class=p>{};</span><span class=c1>//创建空的关联对象集合
</span><span class=c1></span>
    <span class=p>{</span>
        <span class=n>AssociationsManager</span> <span class=n>manager</span><span class=p>;</span><span class=c1>//创建一个AssociationsManager管理类
</span><span class=c1></span>        <span class=n>AssociationsHashMap</span> <span class=o>&amp;</span><span class=n>associations</span><span class=p>(</span><span class=n>manager</span><span class=p>.</span><span class=n>get</span><span class=p>());</span><span class=c1>//获取全局唯一的静态哈希map
</span><span class=c1></span>        <span class=n>AssociationsHashMap</span><span class=o>::</span><span class=n>iterator</span> <span class=n>i</span> <span class=o>=</span> <span class=n>associations</span><span class=p>.</span><span class=n>find</span><span class=p>((</span><span class=n>objc_object</span> <span class=o>*</span><span class=p>)</span><span class=n>object</span><span class=p>);</span><span class=c1>//找到迭代器，即获取buckets
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>associations</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span><span class=c1>//如果这个迭代查询器不是最后一个 获取
</span><span class=c1></span>            <span class=n>refs</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>i</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span><span class=c1>//获取ObjcAssociation
</span><span class=c1></span>            <span class=n>associations</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=c1>//删除
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// release everything (outside of the lock).
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>i</span><span class=p>:</span> <span class=n>refs</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>i</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>releaseHeldValue</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=总结-1><a href=#总结-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>总结</h3><p><strong>对于应用</strong></p><blockquote><p>分类中对属性的实现其实只是实现了一个看起来像属性的接口而已</p></blockquote><p>分类中手动实现 <code>setter、getter</code>，通常需要借助<strong>关联对象</strong></p><p><strong>对于实现</strong></p><p>关联对象是怎么实现并且管理的：</p><ul><li>关联对象本质是 <code>ObjectAssociation</code> 对象</li><li>关联对象由 <code>AssociationsManager</code> 管理并在 <code>AssociationsHashMap</code> 存储</li><li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li><li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li><li>对于<code>nonpointerIsa</code>, 每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li></ul><p>整个结构图为：</p><p><img src=https://w-md.imzsy.design/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png alt=关联对象数据结构></p></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>