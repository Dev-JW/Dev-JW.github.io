<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-dyld加载流程 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="我们都知道程序的入口函数是 main.m 文件里的 main函数，但这并不是一个 App 的生命起点，在进入……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/dyld-load/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-09-25T21:51:41+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/dyld-load/","name":"iOS底层原理探索-dyld加载流程","description":"我们都知道程序的入口函数是 main.m 文件里的 main函数，但这并不是一个 App 的生命起点，在进入……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-dyld加载流程"><meta property="og:description" content="我们都知道程序的入口函数是 main.m 文件里的 main函数，但这并不是一个 App 的生命起点，在进入……"><meta property="og:url" content="https://dev.hjw.best/dyld-load/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-dyld加载流程</h1><div class=post-meta><time datetime=2020-09-25T21:51:41+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-09-25</time></div><div class="post-body e-content"><p>我们都知道程序的入口函数是 <code>main.m</code> 文件里的 <code>main函数</code>，但这并不是一个 App 的生命起点，在进入 <code>main函数</code>之前还进行了许多的操作，本文将对这些操作进行梳理</p><p>同样的，提出几个问题：</p><ul><li>静态库与动态库的区别</li><li>dyld 是什么</li><li>dyld 加载过程</li></ul><h3 id=静态库与动态库><a href=#静态库与动态库 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>静态库与动态库</h3><p>Objective-C 是动态语言，得益于特有的 <strong>Runtime</strong> 机制，同时，也是编译型语言，需要通过编译器将源代码编译成机器码，链接各个模块的机器码和依赖库，串联起来生成可执行文件<code>mach-o</code></p><h5 id=编译过程><a href=#编译过程 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>编译过程</h5><blockquote><p>事实上，这个过程分解为4个步骤，分别是预处理(Prepressing)、编译(Compilation)、汇编(Assembly)和链接(Linking).------ 摘自《程序员的自我修养-- 链接、装载与库》</p></blockquote><p>Xcode 通常帮我们做了以下几件事：</p><ul><li>预编译：处理代码中的<code>#开头</code>的预编译指令，比如删除<code>#define</code>并展开宏定义，将<code>#include</code>包含的文件插入到该指令位置等</li><li>编译：对预编译处理过的文件进行词法分析、语法分析和语义分析，并进行源代码优化，然后生成汇编代码</li><li>汇编：通过汇编器将汇编代码转换为机器可以执行的指令，并生成目标文件<code>.o文件</code></li><li>链接：将目标文件链接成可执行文件。这个过程中，链接器会将不同的目标文件链接起来，因为目标文件需要依赖别的框架，比如经常调用 Foundation 框架和 UIKit 框架</li></ul><p><img src=https://w-md.imzsy.design/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png alt=编译过程></p><blockquote><div class=highlight><pre class=chroma><code class=language-ruby data-lang=ruby><span class=sb>`Foundation`</span><span class=err>和</span><span class=sb>`UIKit`</span><span class=err>这种可以共享代码、实现代码的复用统称为</span><span class=sb>`库`</span>

<span class=err>它是可执行代码的二进制文件，可以被操作系统写入内存，它又分为</span><span class=sb>`静态库`</span><span class=err>和</span><span class=sb>`动态库
</span></code></pre></div></blockquote><h5 id=静态库><a href=#静态库 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>静态库</h5><p><code>静态库</code>是指在链接生成可执行文件时，从这个单独的文件中『拷贝』它自己需要的内容到最终的可执行文件中，如<code>.a、.lib</code>都是静态库</p><h5 id=动态库><a href=#动态库 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>动态库</h5><p><code>动态库</code>是指在链接时不拷贝到可执行文件中，而是程序运行时由系统加在到内存中，供系统调用，系统只需加载一次，多次使用，共用节省内存。</p><p>如<code>.dylib</code>、<code>.framework</code>都是动态库</p><blockquote><p><strong>系统的framework是动态的，开发者创建的framework是静态的，也可以是动态的</strong></p></blockquote><h3 id=dyld><a href=#dyld class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyld</h3><p><strong>dyld简介</strong></p><p><code>dyld(The dynamic link editor)</code>是苹果的动态链接器，负责程序的链接及加载工作，是苹果操作系统的重要组成部分，存在于MacOS系统的<code>(/usr/lib/dyld)</code>目录下。</p><p>在应用被编译打包成可执行文件格式的<code>Mach-O</code>文件之后 ，交由<code>dyld</code>负责链接，加载程序</p><p><strong>dyld_shared_cache</strong></p><p>由于不止一个程序需要使用<code>UIKit</code>系统动态库，所以不可能在每个程序加载时都去加载所有的系统动态库。</p><p>为了优化程序启动速度和利用动态库缓存，苹果从<code>iOS3.1</code>之后，将所有系统库（私有与公有）编译成一个大的缓存文件，这就是<code>dyld_shared_cache</code>，该缓存文件存在iOS系统下的<code>/System/Library/Caches/com.apple.dyld/</code>目录下</p><h3 id=dyld加载流程><a href=#dyld加载流程 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyld加载流程</h3><p>分别在 <code>main函数</code>和 ViewController 的<code>+load</code>函数打断点，看一下断点进入位置，以及调用堆栈</p><p>可以发现，断点会先进入到<code>+load函数</code>，并且堆栈如下：</p><div class=highlight><pre class=chroma><code class=language-ruby data-lang=ruby><span class=o>*</span> <span class=n>thread</span> <span class=c1>#1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1</span>
  <span class=o>*</span> <span class=n>frame</span> <span class=c1>#0: 0x0000000101d4aaec NSProxyTest`+[ViewController load](self=ViewController, _cmd=&#34;load&#34;) at ViewController.m:18:1</span>
    <span class=n>frame</span> <span class=c1>#1: 0x00007fff201805e3 libobjc.A.dylib`load_images + 1442</span>
    <span class=n>frame</span> <span class=c1>#2: 0x0000000101d63e54 dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 425</span>
    <span class=n>frame</span> <span class=c1>#3: 0x0000000101d72887 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 437</span>
    <span class=n>frame</span> <span class=c1>#4: 0x0000000101d70bb0 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 188</span>
    <span class=n>frame</span> <span class=c1>#5: 0x0000000101d70c50 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 82</span>
    <span class=n>frame</span> <span class=c1>#6: 0x0000000101d642a9 dyld_sim`dyld::initializeMainExecutable() + 199</span>
    <span class=n>frame</span> <span class=c1>#7: 0x0000000101d68d50 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4431</span>
    <span class=n>frame</span> <span class=c1>#8: 0x0000000101d631c7 dyld_sim`start_sim + 122</span>
    <span class=n>frame</span> <span class=c1>#9: 0x0000000110dc285c dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308</span>
    <span class=n>frame</span> <span class=c1>#10: 0x0000000110dc04f4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837</span>
    <span class=n>frame</span> <span class=c1>#11: 0x0000000110dbb227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453</span>
    <span class=n>frame</span> <span class=c1>#12: 0x0000000110dbb025 dyld`_dyld_start + 37</span>
</code></pre></div><p>可以看出，首先调用 <code>dyld</code> 中的 <code>_dyld_start</code> 函数，再接着调用<code>dyldbootstrap::start()</code>函数</p><p>这里需要借助 <a href=https://opensource.apple.com/tarballs/dyld/ target=_blank rel=noopener>dyld源码</a>来查看函数的具体实现</p><h4 id=_dyld_start><a href=#_dyld_start class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>_dyld_start</h4><p>通过搜索<code>_dyld_start</code>，可以发现是在<code>dyldStartup.s</code>汇编文件内，从汇编注释可以看到会去调用<code>dyldbootstrap::start()</code>函数</p><p><img src=https://w-md.imzsy.design/_dyld_start.png alt=_dyld_start></p><h4 id=dyldbootstrapstart><a href=#dyldbootstrapstart class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyldbootstrap::start()</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>uintptr_t</span> <span class=nf>start</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=nc>macho_header</span><span class=o>*</span> <span class=n>appsMachHeader</span><span class=p>,</span> <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[],</span> 
				<span class=n>intptr_t</span> <span class=n>slide</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>macho_header</span><span class=o>*</span> <span class=n>dyldsMachHeader</span><span class=p>,</span>
				<span class=n>uintptr_t</span><span class=o>*</span> <span class=n>startGlue</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// if kernel had to slide dyld, we need to fix up load sensitive locations
</span><span class=c1></span>	<span class=c1>// we have to do this before using any global variables
</span><span class=c1></span>    <span class=c1>// 获取 slide
</span><span class=c1></span>    <span class=n>slide</span> <span class=o>=</span> <span class=n>slideOfMainExecutable</span><span class=p>(</span><span class=n>dyldsMachHeader</span><span class=p>);</span>
    <span class=kt>bool</span> <span class=n>shouldRebase</span> <span class=o>=</span> <span class=n>slide</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span>
<span class=cp>#if __has_feature(ptrauth_calls)
</span><span class=cp></span>    <span class=n>shouldRebase</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=k>if</span> <span class=p>(</span> <span class=n>shouldRebase</span> <span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 根据 slide 确定是否 rebase
</span><span class=c1></span>        <span class=n>rebaseDyld</span><span class=p>(</span><span class=n>dyldsMachHeader</span><span class=p>,</span> <span class=n>slide</span><span class=p>);</span>
    <span class=p>}</span>

	<span class=c1>// allow dyld to use mach messaging
</span><span class=c1></span>    <span class=c1>// 初始化 mach 消息
</span><span class=c1></span>	<span class=n>mach_init</span><span class=p>();</span>

	<span class=c1>// kernel sets up env pointer to be just past end of agv array
</span><span class=c1></span>	<span class=k>const</span> <span class=kt>char</span><span class=o>**</span> <span class=n>envp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>argv</span><span class=p>[</span><span class=n>argc</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
	
	<span class=c1>// kernel sets up apple pointer to be just past end of envp array
</span><span class=c1></span>	<span class=k>const</span> <span class=kt>char</span><span class=o>**</span> <span class=n>apple</span> <span class=o>=</span> <span class=n>envp</span><span class=p>;</span>
	<span class=k>while</span><span class=p>(</span><span class=o>*</span><span class=n>apple</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=o>++</span><span class=n>apple</span><span class=p>;</span> <span class=p>}</span>
	<span class=o>++</span><span class=n>apple</span><span class=p>;</span>

	<span class=c1>// set up random value for stack canary
</span><span class=c1></span>    <span class=c1>// 保护栈溢出
</span><span class=c1></span>	<span class=n>__guard_setup</span><span class=p>(</span><span class=n>apple</span><span class=p>);</span>

<span class=cp>#if DYLD_INITIALIZER_SUPPORT
</span><span class=cp></span>	<span class=c1>// run all C++ initializers inside dyld
</span><span class=c1></span>	<span class=n>runDyldInitializers</span><span class=p>(</span><span class=n>dyldsMachHeader</span><span class=p>,</span> <span class=n>slide</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=n>apple</span><span class=p>);</span>
<span class=cp>#endif
</span><span class=cp></span>
	<span class=c1>// now that we are done bootstrapping dyld, call dyld&#39;s main
</span><span class=c1></span>    <span class=c1>// 完成引导，调用 dyld::main 函数
</span><span class=c1></span>    <span class=c1>// appsSlide 获取偏移值，传给 main 函数
</span><span class=c1></span>	<span class=n>uintptr_t</span> <span class=n>appsSlide</span> <span class=o>=</span> <span class=n>slideOfMainExecutable</span><span class=p>(</span><span class=n>appsMachHeader</span><span class=p>);</span>
	<span class=k>return</span> <span class=n>dyld</span><span class=o>::</span><span class=n>_main</span><span class=p>(</span><span class=n>appsMachHeader</span><span class=p>,</span> <span class=n>appsSlide</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=n>apple</span><span class=p>,</span> <span class=n>startGlue</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>在这里主要做了四个操作</p><ul><li><p>根据 <code>dyldsMachHeader</code> 计算出 <code>slide</code>，通过 <code>slide</code> 判断是否需要重定位；</p><p><code>slide</code> 是根据 <code>ASLR技术</code> 计算出的一个随机值，使程序每一次运行的偏移值都不一样，防止攻击者通过固定地址发起恶意攻击</p></li><li><p><code>mach_init()</code>初始化（允许 dyld 使用 mach 消息传递）</p></li><li><p>栈溢出保护</p></li><li><p>计算 <code>appsMachHeader</code> 的偏移，调用 <code>dyld::main()</code> 函数</p></li></ul><h4 id=dyldmain><a href=#dyldmain class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyld::main()</h4><p>内核加载 <code>dyld</code> 并跳转到 <code>__dyld_start</code> 设置一些寄存器信息之后，会调用此函数。</p><p><code>dyld::main()</code> 函数实现是加载 <code>dyld</code> 的主要步骤</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>uintptr_t</span>
<span class=nf>_main</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mainExecutableMH</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>mainExecutableSlide</span><span class=p>,</span> 
        <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>envp</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>apple</span><span class=p>[],</span> 
        <span class=n>uintptr_t</span><span class=o>*</span> <span class=n>startGlue</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// Grab the cdHash of the main executable from the environment
</span><span class=c1></span>    <span class=c1>// 第一步，设置运行环境
</span><span class=c1></span>    <span class=kt>uint8_t</span> <span class=n>mainExecutableCDHashBuffer</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
    <span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>mainExecutableCDHash</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>hexToBytes</span><span class=p>(</span><span class=n>_simple_getenv</span><span class=p>(</span><span class=n>apple</span><span class=p>,</span> <span class=s>&#34;executable_cdhash&#34;</span><span class=p>),</span> <span class=mi>40</span><span class=p>,</span> <span class=n>mainExecutableCDHashBuffer</span><span class=p>)</span> <span class=p>)</span>
        <span class=c1>// 获取主程序的hash
</span><span class=c1></span>        <span class=n>mainExecutableCDHash</span> <span class=o>=</span> <span class=n>mainExecutableCDHashBuffer</span><span class=p>;</span>
    <span class=c1>// Trace dyld&#39;s load
</span><span class=c1></span>    <span class=n>notifyKernelAboutImage</span><span class=p>((</span><span class=n>macho_header</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>__dso_handle</span><span class=p>,</span> <span class=n>_simple_getenv</span><span class=p>(</span><span class=n>apple</span><span class=p>,</span> <span class=s>&#34;dyld_file&#34;</span><span class=p>));</span>
<span class=cp>#if !TARGET_IPHONE_SIMULATOR
</span><span class=cp></span>    <span class=c1>// Trace the main executable&#39;s load
</span><span class=c1></span>    <span class=n>notifyKernelAboutImage</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>,</span> <span class=n>_simple_getenv</span><span class=p>(</span><span class=n>apple</span><span class=p>,</span> <span class=s>&#34;executable_file&#34;</span><span class=p>));</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=n>uintptr_t</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// 获取主程序的macho_header结构
</span><span class=c1></span>    <span class=n>sMainExecutableMachHeader</span> <span class=o>=</span> <span class=n>mainExecutableMH</span><span class=p>;</span>
    <span class=c1>// 获取主程序的slide值
</span><span class=c1></span>    <span class=n>sMainExecutableSlide</span> <span class=o>=</span> <span class=n>mainExecutableSlide</span><span class=p>;</span>
    <span class=n>CRSetCrashLogMessage</span><span class=p>(</span><span class=s>&#34;dyld: launch started&#34;</span><span class=p>);</span>
    <span class=c1>// 设置上下文信息
</span><span class=c1></span>    <span class=n>setContext</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=n>apple</span><span class=p>);</span>
    <span class=c1>// Pickup the pointer to the exec path.
</span><span class=c1></span>    <span class=c1>// 获取主程序路径
</span><span class=c1></span>    <span class=n>sExecPath</span> <span class=o>=</span> <span class=n>_simple_getenv</span><span class=p>(</span><span class=n>apple</span><span class=p>,</span> <span class=s>&#34;executable_path&#34;</span><span class=p>);</span>
    <span class=c1>// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sExecPath</span><span class=p>)</span> <span class=n>sExecPath</span> <span class=o>=</span> <span class=n>apple</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>sExecPath</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;/&#39;</span> <span class=p>)</span> <span class=p>{</span>
        <span class=c1>// have relative path, use cwd to make absolute
</span><span class=c1></span>        <span class=kt>char</span> <span class=n>cwdbuff</span><span class=p>[</span><span class=n>MAXPATHLEN</span><span class=p>];</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>getcwd</span><span class=p>(</span><span class=n>cwdbuff</span><span class=p>,</span> <span class=n>MAXPATHLEN</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
            <span class=c1>// maybe use static buffer to avoid calling malloc so early...
</span><span class=c1></span>            <span class=kt>char</span><span class=o>*</span> <span class=n>s</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>cwdbuff</span><span class=p>)</span> <span class=o>+</span> <span class=n>strlen</span><span class=p>(</span><span class=n>sExecPath</span><span class=p>)</span> <span class=o>+</span> <span class=mi>2</span><span class=p>];</span>
            <span class=n>strcpy</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>cwdbuff</span><span class=p>);</span>
            <span class=n>strcat</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>);</span>
            <span class=n>strcat</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>sExecPath</span><span class=p>);</span>
            <span class=n>sExecPath</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// Remember short name of process for later logging
</span><span class=c1></span>    <span class=c1>// 获取进程名称
</span><span class=c1></span>    <span class=n>sExecShortName</span> <span class=o>=</span> <span class=o>::</span><span class=n>strrchr</span><span class=p>(</span><span class=n>sExecPath</span><span class=p>,</span> <span class=sc>&#39;/&#39;</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>sExecShortName</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span>
        <span class=o>++</span><span class=n>sExecShortName</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=n>sExecShortName</span> <span class=o>=</span> <span class=n>sExecPath</span><span class=p>;</span>
    
    <span class=c1>// 配置进程受限模式
</span><span class=c1></span>    <span class=n>configureProcessRestrictions</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>);</span>
    <span class=c1>// 检测环境变量
</span><span class=c1></span>    <span class=n>checkEnvironmentVariables</span><span class=p>(</span><span class=n>envp</span><span class=p>);</span>
    <span class=n>defaultUninitializedFallbackPaths</span><span class=p>(</span><span class=n>envp</span><span class=p>);</span>
    <span class=c1>// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_PRINT_OPTS</span> <span class=p>)</span>
        <span class=n>printOptions</span><span class=p>(</span><span class=n>argv</span><span class=p>);</span>
    <span class=c1>// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_PRINT_ENV</span> <span class=p>)</span> 
        <span class=n>printEnvironmentVariables</span><span class=p>(</span><span class=n>envp</span><span class=p>);</span>
    <span class=c1>// 获取当前程序架构
</span><span class=c1></span>    <span class=n>getHostInfo</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>,</span> <span class=n>mainExecutableSlide</span><span class=p>);</span>
    <span class=c1>//-------------第一步结束-------------
</span><span class=c1></span>    
    <span class=c1>// load shared cache
</span><span class=c1></span>    <span class=c1>// 第二步，加载共享缓存
</span><span class=c1></span>    <span class=c1>// 检查共享缓存是否开启，iOS必须开启
</span><span class=c1></span>    <span class=n>checkSharedRegionDisable</span><span class=p>((</span><span class=n>mach_header</span><span class=o>*</span><span class=p>)</span><span class=n>mainExecutableMH</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>gLinkContext</span><span class=p>.</span><span class=n>sharedRegionMode</span> <span class=o>!=</span> <span class=n>ImageLoader</span><span class=o>::</span><span class=n>kDontUseSharedRegion</span> <span class=p>)</span> <span class=p>{</span>
        <span class=n>mapSharedCache</span><span class=p>();</span>
    <span class=p>}</span>
    <span class=p>...</span>
    <span class=k>try</span> <span class=p>{</span>
        <span class=c1>// add dyld itself to UUID list
</span><span class=c1></span>        <span class=n>addDyldImageToUUIDList</span><span class=p>();</span>
        <span class=c1>// instantiate ImageLoader for main executable
</span><span class=c1></span>        <span class=c1>// 第三步 实例化主程序
</span><span class=c1></span>        <span class=n>sMainExecutable</span> <span class=o>=</span> <span class=n>instantiateFromLoadedImage</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>,</span> <span class=n>mainExecutableSlide</span><span class=p>,</span> <span class=n>sExecPath</span><span class=p>);</span>
        <span class=n>gLinkContext</span><span class=p>.</span><span class=n>mainExecutable</span> <span class=o>=</span> <span class=n>sMainExecutable</span><span class=p>;</span>
        <span class=n>gLinkContext</span><span class=p>.</span><span class=n>mainExecutableCodeSigned</span> <span class=o>=</span> <span class=n>hasCodeSignatureLoadCommand</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>);</span>
        <span class=c1>// Now that shared cache is loaded, setup an versioned dylib overrides
</span><span class=c1></span>    <span class=cp>#if SUPPORT_VERSIONED_PATHS
</span><span class=cp></span>        <span class=n>checkVersionedPaths</span><span class=p>();</span>
    <span class=cp>#endif
</span><span class=cp></span>        <span class=c1>// dyld_all_image_infos image list does not contain dyld
</span><span class=c1></span>        <span class=c1>// add it as dyldPath field in dyld_all_image_infos
</span><span class=c1></span>        <span class=c1>// for simulator, dyld_sim is in image list, need host dyld added
</span><span class=c1></span><span class=cp>#if TARGET_IPHONE_SIMULATOR
</span><span class=cp></span>        <span class=c1>// get path of host dyld from table of syscall vectors in host dyld
</span><span class=c1></span>        <span class=kt>void</span><span class=o>*</span> <span class=n>addressInDyld</span> <span class=o>=</span> <span class=n>gSyscallHelpers</span><span class=p>;</span>
<span class=cp>#else
</span><span class=cp></span>        <span class=c1>// get path of dyld itself
</span><span class=c1></span>        <span class=kt>void</span><span class=o>*</span>  <span class=n>addressInDyld</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>__dso_handle</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span>        <span class=kt>char</span> <span class=n>dyldPathBuffer</span><span class=p>[</span><span class=n>MAXPATHLEN</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
        <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>proc_regionfilename</span><span class=p>(</span><span class=n>getpid</span><span class=p>(),</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)(</span><span class=kt>long</span><span class=p>)</span><span class=n>addressInDyld</span><span class=p>,</span> <span class=n>dyldPathBuffer</span><span class=p>,</span> <span class=n>MAXPATHLEN</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>len</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
            <span class=n>dyldPathBuffer</span><span class=p>[</span><span class=n>len</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span> <span class=c1>// proc_regionfilename() does not zero terminate returned string
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span> <span class=n>strcmp</span><span class=p>(</span><span class=n>dyldPathBuffer</span><span class=p>,</span> <span class=n>gProcessInfo</span><span class=o>-&gt;</span><span class=n>dyldPath</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
                <span class=n>gProcessInfo</span><span class=o>-&gt;</span><span class=n>dyldPath</span> <span class=o>=</span> <span class=n>strdup</span><span class=p>(</span><span class=n>dyldPathBuffer</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=c1>// load any inserted libraries
</span><span class=c1></span>        <span class=c1>// 第四步 加载插入的动态库
</span><span class=c1></span>        <span class=k>if</span>  <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_INSERT_LIBRARIES</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span><span class=o>*</span> <span class=n>lib</span> <span class=o>=</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_INSERT_LIBRARIES</span><span class=p>;</span> <span class=o>*</span><span class=n>lib</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=o>++</span><span class=n>lib</span><span class=p>)</span>
                <span class=n>loadInsertedDylib</span><span class=p>(</span><span class=o>*</span><span class=n>lib</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=c1>// record count of inserted libraries so that a flat search will look at 
</span><span class=c1></span>        <span class=c1>// inserted libraries, then main, then others.
</span><span class=c1></span>        <span class=c1>// 记录插入的动态库数量
</span><span class=c1></span>        <span class=n>sInsertedDylibCount</span> <span class=o>=</span> <span class=n>sAllImages</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
        <span class=c1>// link main executable
</span><span class=c1></span>        <span class=c1>// 第五步 链接主程序
</span><span class=c1></span>        <span class=n>gLinkContext</span><span class=p>.</span><span class=n>linkingMainExecutable</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
<span class=cp>#if SUPPORT_ACCELERATE_TABLES
</span><span class=cp></span>        <span class=k>if</span> <span class=p>(</span> <span class=n>mainExcutableAlreadyRebased</span> <span class=p>)</span> <span class=p>{</span>
            <span class=c1>// previous link() on main executable has already adjusted its internal pointers for ASLR
</span><span class=c1></span>            <span class=c1>// work around that by rebasing by inverse amount
</span><span class=c1></span>            <span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>rebase</span><span class=p>(</span><span class=n>gLinkContext</span><span class=p>,</span> <span class=o>-</span><span class=n>mainExecutableSlide</span><span class=p>);</span>
        <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span>        <span class=n>link</span><span class=p>(</span><span class=n>sMainExecutable</span><span class=p>,</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_BIND_AT_LAUNCH</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=n>ImageLoader</span><span class=o>::</span><span class=n>RPathChain</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
        <span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>setNeverUnloadRecursive</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>forceFlat</span><span class=p>()</span> <span class=p>)</span> <span class=p>{</span>
            <span class=n>gLinkContext</span><span class=p>.</span><span class=n>bindFlat</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
            <span class=n>gLinkContext</span><span class=p>.</span><span class=n>prebindUsage</span> <span class=o>=</span> <span class=n>ImageLoader</span><span class=o>::</span><span class=n>kUseNoPrebinding</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// link any inserted libraries
</span><span class=c1></span>        <span class=c1>// do this after linking main executable so that any dylibs pulled in by inserted 
</span><span class=c1></span>        <span class=c1>// dylibs (e.g. libSystem) will not be in front of dylibs the program uses
</span><span class=c1></span>        <span class=c1>// 第六步 链接插入的动态库
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span> <span class=n>sInsertedDylibCount</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sInsertedDylibCount</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>sAllImages</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
                <span class=n>link</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_BIND_AT_LAUNCH</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=n>ImageLoader</span><span class=o>::</span><span class=n>RPathChain</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
                <span class=n>image</span><span class=o>-&gt;</span><span class=n>setNeverUnloadRecursive</span><span class=p>();</span>
            <span class=p>}</span>
            <span class=c1>// only INSERTED libraries can interpose
</span><span class=c1></span>            <span class=c1>// register interposing info after all inserted libraries are bound so chaining works
</span><span class=c1></span>            <span class=k>for</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sInsertedDylibCount</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>sAllImages</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
                <span class=n>image</span><span class=o>-&gt;</span><span class=n>registerInterposing</span><span class=p>();</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=c1>// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>long</span> <span class=n>i</span><span class=o>=</span><span class=n>sInsertedDylibCount</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sAllImages</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>sAllImages</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=k>if</span> <span class=p>(</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>inSharedCache</span><span class=p>()</span> <span class=p>)</span>
                <span class=k>continue</span><span class=p>;</span>
            <span class=n>image</span><span class=o>-&gt;</span><span class=n>registerInterposing</span><span class=p>();</span>
        <span class=p>}</span>
        <span class=p>...</span>
        <span class=c1>// apply interposing to initial set of images
</span><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sImageRoots</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>sImageRoots</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>applyInterposing</span><span class=p>(</span><span class=n>gLinkContext</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>gLinkContext</span><span class=p>.</span><span class=n>linkingMainExecutable</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
        
        <span class=c1>// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked
</span><span class=c1></span>        <span class=c1>// 第七步 执行弱符号绑定
</span><span class=c1></span>        <span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>weakBind</span><span class=p>(</span><span class=n>gLinkContext</span><span class=p>);</span>
        <span class=c1>// If cache has branch island dylibs, tell debugger about them
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>.</span><span class=n>mappingOffset</span> <span class=o>&gt;=</span> <span class=mh>0x78</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>.</span><span class=n>branchPoolsOffset</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>)</span> <span class=p>{</span>
            <span class=kt>uint32_t</span> <span class=n>count</span> <span class=o>=</span> <span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>.</span><span class=n>branchPoolsCount</span><span class=p>;</span>
            <span class=n>dyld_image_info</span> <span class=n>info</span><span class=p>[</span><span class=n>count</span><span class=p>];</span>
            <span class=k>const</span> <span class=kt>uint64_t</span><span class=o>*</span> <span class=n>poolAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span> <span class=o>+</span> <span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>loadAddress</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>.</span><span class=n>branchPoolsOffset</span><span class=p>);</span>
            <span class=c1>// &lt;rdar://problem/20799203&gt; empty branch pools can be in development cache
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span> <span class=p>((</span><span class=n>mach_header</span><span class=o>*</span><span class=p>)</span><span class=n>poolAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>magic</span> <span class=o>==</span> <span class=n>sMainExecutableMachHeader</span><span class=o>-&gt;</span><span class=n>magic</span> <span class=p>)</span> <span class=p>{</span>
                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>poolIndex</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>poolIndex</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=o>++</span><span class=n>poolIndex</span><span class=p>)</span> <span class=p>{</span>
                    <span class=kt>uint64_t</span> <span class=n>poolAddr</span> <span class=o>=</span> <span class=n>poolAddress</span><span class=p>[</span><span class=n>poolIndex</span><span class=p>]</span> <span class=o>+</span> <span class=n>sSharedCacheLoadInfo</span><span class=p>.</span><span class=n>slide</span><span class=p>;</span>
                    <span class=n>info</span><span class=p>[</span><span class=n>poolIndex</span><span class=p>].</span><span class=n>imageLoadAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>mach_header</span><span class=o>*</span><span class=p>)(</span><span class=kt>long</span><span class=p>)</span><span class=n>poolAddr</span><span class=p>;</span>
                    <span class=n>info</span><span class=p>[</span><span class=n>poolIndex</span><span class=p>].</span><span class=n>imageFilePath</span> <span class=o>=</span> <span class=s>&#34;dyld_shared_cache_branch_islands&#34;</span><span class=p>;</span>
                    <span class=n>info</span><span class=p>[</span><span class=n>poolIndex</span><span class=p>].</span><span class=n>imageFileModDate</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=c1>// add to all_images list
</span><span class=c1></span>                <span class=n>addImagesToAllImages</span><span class=p>(</span><span class=n>count</span><span class=p>,</span> <span class=n>info</span><span class=p>);</span>
                <span class=c1>// tell gdb about new branch island images
</span><span class=c1></span>                <span class=n>gProcessInfo</span><span class=o>-&gt;</span><span class=n>notification</span><span class=p>(</span><span class=n>dyld_image_adding</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>info</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=n>CRSetCrashLogMessage</span><span class=p>(</span><span class=s>&#34;dyld: launch, running initializers&#34;</span><span class=p>);</span>
        <span class=p>...</span>
        <span class=c1>// run all initializers
</span><span class=c1></span>        <span class=c1>// 第八步 执行初始化方法
</span><span class=c1></span>        <span class=n>initializeMainExecutable</span><span class=p>();</span> 
        <span class=c1>// notify any montoring proccesses that this process is about to enter main()
</span><span class=c1></span>        <span class=n>dyld3</span><span class=o>::</span><span class=n>kdebug_trace_dyld_signpost</span><span class=p>(</span><span class=n>DBG_DYLD_SIGNPOST_START_MAIN_DYLD2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
        <span class=n>notifyMonitoringDyldMain</span><span class=p>();</span>
        <span class=c1>// find entry point for main executable
</span><span class=c1></span>        <span class=c1>// 第九步 查找入口点并返回
</span><span class=c1></span>        <span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>getThreadPC</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>result</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
            <span class=c1>// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>gLibSystemHelpers</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>gLibSystemHelpers</span><span class=o>-&gt;</span><span class=n>version</span> <span class=o>&gt;=</span> <span class=mi>9</span><span class=p>)</span> <span class=p>)</span>
                <span class=o>*</span><span class=n>startGlue</span> <span class=o>=</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>gLibSystemHelpers</span><span class=o>-&gt;</span><span class=n>startGlueToCallExit</span><span class=p>;</span>
            <span class=k>else</span>
                <span class=n>halt</span><span class=p>(</span><span class=s>&#34;libdyld.dylib support not present for LC_MAIN&#34;</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// main executable uses LC_UNIXTHREAD, dyld needs to let &#34;start&#34; in program set up for main()
</span><span class=c1></span>            <span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>getMain</span><span class=p>();</span>
            <span class=o>*</span><span class=n>startGlue</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>catch</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>message</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>syncAllImages</span><span class=p>();</span>
        <span class=n>halt</span><span class=p>(</span><span class=n>message</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>catch</span><span class=p>(...)</span> <span class=p>{</span>
        <span class=n>dyld</span><span class=o>::</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;dyld: launch failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=p>...</span>
    
    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>简化之后的代码，整个加载过程可细分为九个步骤</p><ul><li>第一步：设置运行环境</li><li>第二步：加载共享缓存</li><li>第三步：实例化主程序</li><li>第四步：加载插入的动态库</li><li>第五步：链接主程序</li><li>第六步：链接插入的动态库</li><li>第七步：执行弱符号绑定</li><li>第八步：执行初始化方法</li><li>第九步：查找入口点并返回</li></ul><h5 id=设置运行环境><a href=#设置运行环境 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>设置运行环境</h5><p>这一步主要是设置运行参数、环境变量等。</p><p>代码在开始的时候，将入参 <code>mainExecutableMH</code> 赋值给 <code>sMainExecutableMachHeader</code>，这是一个 <code>macho_header</code> 结构体，表示的是当前主程序的 <code>Mach-O</code> 头部信息，加载器依据 <code>Mach-O</code> 头部信息就可以解析整个文件信息</p><p>接着调用 <code>setContext()</code> 设置上下文信息，包括一些回调函数、参数、标志信息等。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>setContext</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mainExecutableMH</span><span class=p>,</span> <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>envp</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>apple</span><span class=p>[])</span>
<span class=p>{</span>
   <span class=n>gLinkContext</span><span class=p>.</span><span class=n>loadLibrary</span>         <span class=o>=</span> <span class=o>&amp;</span><span class=n>libraryLocator</span><span class=p>;</span>
   <span class=n>gLinkContext</span><span class=p>.</span><span class=n>terminationRecorder</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>terminationRecorder</span><span class=p>;</span>
   <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p>设置的回调函数都是 dyld 模块自身实现的，如 <code>loadLibrary()</code>函数实际调用的是 <code>libraryLocator()</code>，负责加载动态库</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>configureProcessRestrictions</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mainExecutableMH</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>sEnvMode</span> <span class=o>=</span> <span class=n>envNone</span><span class=p>;</span> <span class=c1>// 受限模式
</span><span class=c1></span>    <span class=n>gLinkContext</span><span class=p>.</span><span class=n>requireCodeSignature</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// 需要代码签名
</span><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>csops</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>CS_OPS_STATUS</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flags</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>flags</span><span class=p>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 启用代码签名
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=n>CS_ENFORCEMENT</span> <span class=p>)</span> <span class=p>{</span>
            <span class=c1>// get_task_allow
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=n>CS_GET_TASK_ALLOW</span> <span class=p>)</span> <span class=p>{</span>
                <span class=c1>// Xcode built app for Debug allowed to use DYLD_* variables
</span><span class=c1></span>                <span class=c1>// Xcode调试时允许使用DYLD_*环境变量
</span><span class=c1></span>                <span class=n>sEnvMode</span> <span class=o>=</span> <span class=n>envAll</span><span class=p>;</span> <span class=c1>// 非受限模式
</span><span class=c1></span>            <span class=p>}</span>
            <span class=k>else</span> <span class=p>{</span>
                <span class=c1>// Development kernel can use DYLD_PRINT_* variables on any FairPlay encrypted app
</span><span class=c1></span>                <span class=kt>uint32_t</span> <span class=n>secureValue</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
                <span class=n>size_t</span>   <span class=n>secureValueSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>secureValue</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>sysctlbyname</span><span class=p>(</span><span class=s>&#34;kern.secure_kernel&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>secureValue</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>secureValueSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>secureValue</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>isFairPlayEncrypted</span><span class=p>(</span><span class=n>mainExecutableMH</span><span class=p>)</span> <span class=p>)</span> <span class=p>{</span>
                    <span class=n>sEnvMode</span> <span class=o>=</span> <span class=n>envPrintOnly</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// Development kernel can run unsigned code
</span><span class=c1></span>            <span class=c1>// 内核开发运行运行非签名代码
</span><span class=c1></span>            <span class=n>sEnvMode</span> <span class=o>=</span> <span class=n>envAll</span><span class=p>;</span> <span class=c1>// 非受限模式
</span><span class=c1></span>            <span class=n>gLinkContext</span><span class=p>.</span><span class=n>requireCodeSignature</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// 无需代码签名
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 如果设置了uid、gid则变成受限模式
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span> <span class=n>issetugid</span><span class=p>()</span> <span class=p>)</span> <span class=p>{</span>
        <span class=n>sEnvMode</span> <span class=o>=</span> <span class=n>envNone</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p><code>configureProcessRestrictions()</code>用来配置进程是否受限，代码逻辑比较简单，<code>sEnvMode</code>默认等于<code>envNone</code>（即受限模式）</p><ul><li><p>如果设置了<code>get_task_allow</code>权限或者是内核开发时会设置成<code>envAll</code></p></li><li><p>如果设置了<code>uid</code>和<code>gid</code>则立即变成受限模式</p></li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>checkEnvironmentVariables</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>envp</span><span class=p>[])</span>
<span class=p>{</span>
   <span class=k>if</span> <span class=p>(</span> <span class=n>sEnvMode</span> <span class=o>==</span> <span class=n>envNone</span> <span class=p>)</span>
      <span class=k>return</span><span class=p>;</span>
   <span class=k>const</span> <span class=kt>char</span><span class=o>**</span> <span class=n>p</span><span class=p>;</span>
   <span class=k>for</span><span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>envp</span><span class=p>;</span> <span class=o>*</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>keyEqualsValue</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
       <span class=k>if</span> <span class=p>(</span> <span class=n>strncmp</span><span class=p>(</span><span class=n>keyEqualsValue</span><span class=p>,</span> <span class=s>&#34;DYLD_&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
         <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>equals</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>keyEqualsValue</span><span class=p>,</span> <span class=sc>&#39;=&#39;</span><span class=p>);</span>
         <span class=k>if</span> <span class=p>(</span> <span class=n>equals</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
            <span class=n>strlcat</span><span class=p>(</span><span class=n>sLoadingCrashMessage</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>sLoadingCrashMessage</span><span class=p>));</span>
            <span class=n>strlcat</span><span class=p>(</span><span class=n>sLoadingCrashMessage</span><span class=p>,</span> <span class=n>keyEqualsValue</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>sLoadingCrashMessage</span><span class=p>));</span>
            <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>value</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>equals</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
            <span class=k>const</span> <span class=n>size_t</span> <span class=n>keyLen</span> <span class=o>=</span> <span class=n>equals</span><span class=o>-</span><span class=n>keyEqualsValue</span><span class=p>;</span>
            <span class=kt>char</span> <span class=n>key</span><span class=p>[</span><span class=n>keyLen</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
            <span class=n>strncpy</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>keyEqualsValue</span><span class=p>,</span> <span class=n>keyLen</span><span class=p>);</span>
            <span class=n>key</span><span class=p>[</span><span class=n>keyLen</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>sEnvMode</span> <span class=o>==</span> <span class=n>envPrintOnly</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>strncmp</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=s>&#34;DYLD_PRINT_&#34;</span><span class=p>,</span> <span class=mi>11</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>)</span>
               <span class=k>continue</span><span class=p>;</span>
            <span class=c1>// 处理并设置环境变量
</span><span class=c1></span>            <span class=n>processDyldEnvironmentVariable</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
         <span class=p>}</span>
      <span class=p>}</span>
      <span class=k>else</span> <span class=k>if</span> <span class=p>(</span> <span class=n>strncmp</span><span class=p>(</span><span class=n>keyEqualsValue</span><span class=p>,</span> <span class=s>&#34;LD_LIBRARY_PATH=&#34;</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
         <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>keyEqualsValue</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
         <span class=n>sEnv</span><span class=p>.</span><span class=n>LD_LIBRARY_PATH</span> <span class=o>=</span> <span class=n>parseColonList</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
      <span class=p>}</span>
   <span class=p>}</span>
   <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p><code>checkEnvironmentVariables()</code>检测环境变量，如果<code>sEnvMode</code>为<code>envNone</code>就直接返回，否则调用<code>processDyldEnvironmentVariable()</code>处理并设置环境变量</p><p>最后是调用<code>getHostInfo()</code>获取当前程序架构，至此，第一步的准备工作就完成了</p><blockquote><p><code>DYLD_*</code>开头的是环境变量，如：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_PRINT_OPTS</span> <span class=p>)</span>
    <span class=n>printOptions</span><span class=p>(</span><span class=n>argv</span><span class=p>);</span>
<span class=c1>// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_PRINT_ENV</span> <span class=p>)</span> 
    <span class=n>printEnvironmentVariables</span><span class=p>(</span><span class=n>envp</span><span class=p>);</span>
</code></pre></div><p>只要在 Xcode 中配置一下，即可使这些环境变量生效，在 App 启动时就会打印相关参数</p></blockquote><h5 id=加载共享缓存><a href=#加载共享缓存 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>加载共享缓存</h5><p>先调用<code>checkSharedRegionDisable()</code>检查共享缓存是否禁用</p><p>该函数的iOS实现部分仅有一句注释，从注释我们可以推断iOS必须开启共享缓存才能正常工作</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>checkSharedRegionDisable</span><span class=p>(</span><span class=k>const</span> <span class=n>mach_header</span><span class=o>*</span> <span class=n>mainExecutableMH</span><span class=p>)</span>
<span class=p>{</span>
   <span class=c1>// iOS cannot run without shared region
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>接着会调用<code>mapSharedCache()</code>加载共享缓存，而<code>mapSharedCache()</code>实际是调用 <code>loadDyldCache()</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>bool</span> <span class=nf>loadDyldCache</span><span class=p>(</span><span class=k>const</span> <span class=n>SharedCacheOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span> <span class=n>SharedCacheLoadInfo</span><span class=o>*</span> <span class=n>results</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>results</span><span class=o>-&gt;</span><span class=n>loadAddress</span>        <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>results</span><span class=o>-&gt;</span><span class=n>slide</span>              <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>results</span><span class=o>-&gt;</span><span class=n>cachedDylibsGroup</span>  <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
    <span class=n>results</span><span class=o>-&gt;</span><span class=n>errorMessage</span>       <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>options</span><span class=p>.</span><span class=n>forcePrivate</span> <span class=p>)</span> <span class=p>{</span>
        <span class=c1>// mmap cache into this process only
</span><span class=c1></span>        <span class=c1>// 仅加载到当前进程
</span><span class=c1></span>        <span class=k>return</span> <span class=n>mapCachePrivate</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=n>results</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// fast path: when cache is already mapped into shared region
</span><span class=c1></span>        <span class=c1>// 共享缓存已加载，不做任何处理
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span> <span class=n>reuseExistingCache</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=n>results</span><span class=p>)</span> <span class=p>)</span>
            <span class=k>return</span> <span class=p>(</span><span class=n>results</span><span class=o>-&gt;</span><span class=n>errorMessage</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
        <span class=c1>// slow path: this is first process to load cache
</span><span class=c1></span>        <span class=c1>// 当前进程首次加载共享缓存
</span><span class=c1></span>        <span class=k>return</span> <span class=n>mapCacheSystemWide</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=n>results</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>从代码可以看出，共享缓存加载分为：</p><ul><li>仅加载到当前进程，调用<code>mapCachePrivate()</code></li><li>共享缓存已加载，不做任何处理</li><li>当前进行首次加载共享缓存，调用<code>mapCacheSystemWide()</code></li></ul><p><code>mapCachePrivate()</code>、<code>mapCacheSystemWide()</code>里面就是具体的共享缓存解析逻辑，感兴趣的读者可以详细分析。</p><h5 id=实例化主程序><a href=#实例化主程序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>实例化主程序</h5><p>这里会将主程序的 <code>Mach-O</code> 加载到内存，并实例化一个 <code>ImageLoader</code> 对象</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=n>ImageLoaderMachO</span><span class=o>*</span> <span class=nf>instantiateFromLoadedImage</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mh</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>slide</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span><span class=p>)</span>
<span class=p>{</span>
  <span class=c1>// try mach-o loader
</span><span class=c1></span>  <span class=c1>// 尝试加载MachO
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span> <span class=n>isCompatibleMachO</span><span class=p>((</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>mh</span><span class=p>,</span> <span class=n>path</span><span class=p>)</span> <span class=p>)</span> <span class=p>{</span>
    <span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>ImageLoaderMachO</span><span class=o>::</span><span class=n>instantiateMainExecutable</span><span class=p>(</span><span class=n>mh</span><span class=p>,</span> <span class=n>slide</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>gLinkContext</span><span class=p>);</span>
    <span class=n>addImage</span><span class=p>(</span><span class=n>image</span><span class=p>);</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>ImageLoaderMachO</span><span class=o>*</span><span class=p>)</span><span class=n>image</span><span class=p>;</span>
  <span class=p>}</span>
  
  <span class=k>throw</span> <span class=s>&#34;main executable not a known format&#34;</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><code>instantiateFromLoadedImage()</code>首先调用<code>isCompatibleMachO()</code>检测 Mach-O 头部的 <code>magic</code>、<code>cputype</code>、<code>cpusubtype</code> 等相关属性，判断 Mach-O 文件的兼容性，如果兼容，则调用 <code>ImageLoaderMachO::instantiateMainExecutable()</code>实例化主程序的<code>ImageLoader</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ImageLoader</span><span class=o>*</span> <span class=n>ImageLoaderMachO</span><span class=o>::</span><span class=n>instantiateMainExecutable</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mh</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>slide</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=n>LinkContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>)</span>
<span class=p>{</span>
  <span class=kt>bool</span> <span class=n>compressed</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>segCount</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>libCount</span><span class=p>;</span>
  <span class=k>const</span> <span class=n>linkedit_data_command</span><span class=o>*</span> <span class=n>codeSigCmd</span><span class=p>;</span>
  <span class=k>const</span> <span class=n>encryption_info_command</span><span class=o>*</span> <span class=n>encryptCmd</span><span class=p>;</span>
  <span class=n>sniffLoadCommands</span><span class=p>(</span><span class=n>mh</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>compressed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>segCount</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>libCount</span><span class=p>,</span> <span class=n>context</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>codeSigCmd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>encryptCmd</span><span class=p>);</span>
  <span class=c1>// instantiate concrete class based on content of load commands
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span> <span class=n>compressed</span> <span class=p>)</span> 
    <span class=k>return</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>instantiateMainExecutable</span><span class=p>(</span><span class=n>mh</span><span class=p>,</span> <span class=n>slide</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>segCount</span><span class=p>,</span> <span class=n>libCount</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
  <span class=k>else</span>
<span class=cp>#if SUPPORT_CLASSIC_MACHO
</span><span class=cp></span>    <span class=k>return</span> <span class=n>ImageLoaderMachOClassic</span><span class=o>::</span><span class=n>instantiateMainExecutable</span><span class=p>(</span><span class=n>mh</span><span class=p>,</span> <span class=n>slide</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>segCount</span><span class=p>,</span> <span class=n>libCount</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
<span class=cp>#else
</span><span class=cp></span>    <span class=k>throw</span> <span class=s>&#34;missing LC_DYLD_INFO load command&#34;</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span><span class=p>}</span>
</code></pre></div><p>这个函数首先会调用<code>sniffLoadCommands()</code>函数来获取一些数据，包括：</p><ul><li><p><code>compressed</code>：若 Mach-O 存在 <code>LC_DYLD_INFO</code> 和 <code>LC_DYLD_INFO_ONLY</code> 加载命令，则说明是压缩类型的 Mach-O</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=o>-&gt;</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
<span class=k>case</span> <span class=nl>LC_DYLD_INFO</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>LC_DYLD_INFO_ONLY</span><span class=p>:</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>cmd</span><span class=o>-&gt;</span><span class=n>cmdsize</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>dyld_info_command</span><span class=p>)</span> <span class=p>)</span>
        <span class=k>throw</span> <span class=s>&#34;malformed mach-o image: LC_DYLD_INFO size wrong&#34;</span><span class=p>;</span>
    <span class=n>dyldInfoCmd</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>dyld_info_command</span><span class=o>*</span><span class=p>)</span><span class=n>cmd</span><span class=p>;</span>
    <span class=c1>// 存在LC_DYLD_INFO或者LC_DYLD_INFO_ONLY则表示是压缩类型的Mach-O
</span><span class=c1></span>    <span class=o>*</span><span class=n>compressed</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    <span class=k>break</span><span class=p>;</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div></li><li><p><code>segCount</code>: 根据 <code>LC_SEGMENT_COMMAND</code> 加载命令来统计段数量，这里抛出的错误日志也说明了段的数量不能超过 255 个</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=nl>LC_SEGMENT_COMMAND</span><span class=p>:</span>
    <span class=n>segCmd</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>macho_segment_command</span><span class=o>*</span><span class=p>)</span><span class=n>cmd</span><span class=p>;</span>
<span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>segCmd</span><span class=o>-&gt;</span><span class=n>vmsize</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
        <span class=o>*</span><span class=n>segCount</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span> <span class=o>*</span><span class=n>segCount</span> <span class=o>&gt;</span> <span class=mi>255</span> <span class=p>)</span>
    <span class=n>dyld</span><span class=o>::</span><span class=n>throwf</span><span class=p>(</span><span class=s>&#34;malformed mach-o image: more than 255 segments in %s&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</code></pre></div></li><li><p><code>libCount</code>：根据<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>、<code>LC_REEXPORT_DYLIB</code>、<code>LC_LOAD_UPWARD_DYLIB</code> 这几个加载命令来统计库的数量， 库的数量不能超过 4095 个</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=nl>LC_LOAD_DYLIB</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>LC_LOAD_WEAK_DYLIB</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>LC_REEXPORT_DYLIB</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>LC_LOAD_UPWARD_DYLIB</span><span class=p>:</span>
<span class=o>*</span><span class=n>libCount</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span> <span class=o>*</span><span class=n>libCount</span> <span class=o>&gt;</span> <span class=mi>4095</span> <span class=p>)</span>
    <span class=n>dyld</span><span class=o>::</span><span class=n>throwf</span><span class=p>(</span><span class=s>&#34;malformed mach-o image: more than 4095 dependent libraries in %s&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</code></pre></div></li><li><p><code>codeSigCmd</code>：通过解析<code>LC_CODE_SIGNATURE</code>来获取代码签名加载命令</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=nl>LC_CODE_SIGNATURE</span><span class=p>:</span>
<span class=o>*</span><span class=n>codeSigCmd</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>linkedit_data_command</span><span class=o>*</span><span class=p>)</span><span class=n>cmd</span><span class=p>;</span>
<span class=k>break</span><span class=p>;</span>
</code></pre></div></li><li><p><code>encryptCmd</code>：通过<code>LC_ENCRYPTION_INFO</code>和<code>LC_ENCRYPTION_INFO_64</code>来获取段的加密信息</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=nl>LC_ENCRYPTION_INFO</span><span class=p>:</span>
<span class=p>...</span>
<span class=o>*</span><span class=n>encryptCmd</span> <span class=o>=</span> <span class=p>(</span><span class=n>encryption_info_command</span><span class=o>*</span><span class=p>)</span><span class=n>cmd</span><span class=p>;</span>
<span class=k>break</span><span class=p>;</span>
<span class=k>case</span> <span class=nl>LC_ENCRYPTION_INFO_64</span><span class=p>:</span>
<span class=p>...</span>
<span class=o>*</span><span class=n>encryptCmd</span> <span class=o>=</span> <span class=p>(</span><span class=n>encryption_info_command</span><span class=o>*</span><span class=p>)</span><span class=n>cmd</span><span class=p>;</span>
<span class=k>break</span><span class=p>;</span>
</code></pre></div></li></ul><p><code>ImageLoader</code>是抽象类，其子类负责把 Mach-O 文件实例化为 image。</p><p>当<code>sniffLoadCommands()</code>解析完以后，根据<code>compressed</code>的值来觉得调用哪个子类进行实例化</p><p>这个过程，可以用下图来直观描述</p><p><img src=https://w-md.imzsy.design/image-20201008175315434.png alt=image-20201008175315434></p><p>这里以<code>ImageLoaderMachOCompressed::instantiateMainExecutable()</code>为例来看一下实现</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// create image for main executable
</span><span class=c1></span><span class=n>ImageLoaderMachOCompressed</span><span class=o>*</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>instantiateMainExecutable</span><span class=p>(</span><span class=k>const</span> <span class=n>macho_header</span><span class=o>*</span> <span class=n>mh</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>slide</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span><span class=p>,</span> 
                                    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>segCount</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>libCount</span><span class=p>,</span> <span class=k>const</span> <span class=n>LinkContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>)</span>
<span class=p>{</span>
  <span class=n>ImageLoaderMachOCompressed</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>instantiateStart</span><span class=p>(</span><span class=n>mh</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>segCount</span><span class=p>,</span> <span class=n>libCount</span><span class=p>);</span>
  <span class=c1>// set slide for PIE programs
</span><span class=c1></span>  <span class=n>image</span><span class=o>-&gt;</span><span class=n>setSlide</span><span class=p>(</span><span class=n>slide</span><span class=p>);</span>
  <span class=c1>// for PIE record end of program, to know where to start loading dylibs
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span> <span class=n>slide</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
    <span class=n>fgNextPIEDylibAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>getEnd</span><span class=p>();</span>
  <span class=n>image</span><span class=o>-&gt;</span><span class=n>disableCoverageCheck</span><span class=p>();</span>
  <span class=n>image</span><span class=o>-&gt;</span><span class=n>instantiateFinish</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
  <span class=n>image</span><span class=o>-&gt;</span><span class=n>setMapped</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span> <span class=n>context</span><span class=p>.</span><span class=n>verboseMapping</span> <span class=p>)</span> <span class=p>{</span>
    <span class=n>dyld</span><span class=o>::</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;dyld: Main executable mapped %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>e</span><span class=o>=</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>segmentCount</span><span class=p>();</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>e</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span> <span class=o>=</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segName</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
      <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;__PAGEZERO&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;__UNIXSTACK&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=p>)</span>
        <span class=n>dyld</span><span class=o>::</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;%18s at 0x%08lX-&gt;0x%08lX</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segPreferredLoadAddress</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segPreferredLoadAddress</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=o>+</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>segSize</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
      <span class=k>else</span>
        <span class=n>dyld</span><span class=o>::</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;%18s at 0x%08lX-&gt;0x%08lX</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segActualLoadAddress</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segActualEndAddress</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=n>image</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>总结为 4 步：</p><ul><li><code>ImageLoaderMachOCompressed::instantiateStart()</code>创建<code>ImageLoaderMachOCompressed</code>对象</li><li><code>image->disableCoverageCheck()</code>禁用段覆盖检测</li><li><code>image->instantiateFinish()</code>内部调用顺序：<ul><li>调用<code>parseLoadCmds()</code>解析加载命令，</li><li>调用<code>this->setDyldInfo()</code>设置动态库链接信息，</li><li>调用<code>this->setSymbolTableInfo()</code>设置符号表相关信息</li></ul></li><li><code>image->setMapped()</code>函数注册通知回调、计算执行时间等等</li></ul><p>在调用完<code>ImageLoaderMachO::instantiateMainExecutable()</code>后继续调用<code>addImage()</code>，将<code>image</code>加入到<code>sAllImages</code>全局镜像列表，并将<code>image</code>映射到申请的内存中</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>addImage</span><span class=p>(</span><span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span><span class=p>)</span>
<span class=p>{</span>
  <span class=c1>// add to master list
</span><span class=c1></span>    <span class=n>allImagesLock</span><span class=p>();</span>
        <span class=n>sAllImages</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>image</span><span class=p>);</span>
    <span class=n>allImagesUnlock</span><span class=p>();</span>
  
  <span class=c1>// update mapped ranges
</span><span class=c1></span>  <span class=n>uintptr_t</span> <span class=n>lastSegStart</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=n>uintptr_t</span> <span class=n>lastSegEnd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>e</span><span class=o>=</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>segmentCount</span><span class=p>();</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>e</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segUnaccessible</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>)</span> 
      <span class=k>continue</span><span class=p>;</span>
    <span class=n>uintptr_t</span> <span class=n>start</span> <span class=o>=</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segActualLoadAddress</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=n>uintptr_t</span> <span class=n>end</span> <span class=o>=</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>segActualEndAddress</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>start</span> <span class=o>==</span> <span class=n>lastSegEnd</span> <span class=p>)</span> <span class=p>{</span>
      <span class=c1>// two segments are contiguous, just record combined segments
</span><span class=c1></span>      <span class=n>lastSegEnd</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// non-contiguous segments, record last (if any)
</span><span class=c1></span>      <span class=k>if</span> <span class=p>(</span> <span class=n>lastSegEnd</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
        <span class=n>addMappedRange</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>lastSegStart</span><span class=p>,</span> <span class=n>lastSegEnd</span><span class=p>);</span>
      <span class=n>lastSegStart</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span>
      <span class=n>lastSegEnd</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
    <span class=p>}</span>   
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span> <span class=n>lastSegEnd</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
    <span class=n>addMappedRange</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>lastSegStart</span><span class=p>,</span> <span class=n>lastSegEnd</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span> <span class=n>gLinkContext</span><span class=p>.</span><span class=n>verboseLoading</span> <span class=o>||</span> <span class=p>(</span><span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_PRINT_LIBRARIES_POST_LAUNCH</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>sMainExecutable</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>sMainExecutable</span><span class=o>-&gt;</span><span class=n>isLinked</span><span class=p>())</span> <span class=p>)</span> <span class=p>{</span>
    <span class=n>dyld</span><span class=o>::</span><span class=n>log</span><span class=p>(</span><span class=s>&#34;dyld: loaded: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>getPath</span><span class=p>());</span>
  <span class=p>}</span>
  
<span class=p>}</span>
</code></pre></div><p>到这里，初始化主程序就完成了</p><h5 id=加载插入动态库><a href=#加载插入动态库 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>加载插入动态库</h5><p>加载环境变量<code>DYLD_INSERT_LIBRARIES</code>中配置的动态库，先判断<code>DYLD_INSERT_LIBRARIES</code>中是否存在要加载的动态库，如果存在则调用 <code>loadInsertedDylib()</code> 函数依次加载</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span>  <span class=p>(</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_INSERT_LIBRARIES</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span><span class=o>*</span> <span class=n>lib</span> <span class=o>=</span> <span class=n>sEnv</span><span class=p>.</span><span class=n>DYLD_INSERT_LIBRARIES</span><span class=p>;</span> <span class=o>*</span><span class=n>lib</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=o>++</span><span class=n>lib</span><span class=p>)</span>
    <span class=n>loadInsertedDylib</span><span class=p>(</span><span class=o>*</span><span class=n>lib</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p><code>loadInsertedDylib()</code>内部设置了一个 <code>LoadContext</code> 参数，调用了 <code>load()</code> 函数</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ImageLoader</span><span class=o>*</span> <span class=nf>load</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=n>LoadContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>,</span> <span class=kt>unsigned</span><span class=o>&amp;</span> <span class=n>cacheIndex</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>
    <span class=c1>// try all path permutations and check against existing loaded images
</span><span class=c1></span>    <span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>loadPhase0</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>orgPath</span><span class=p>,</span> <span class=n>context</span><span class=p>,</span> <span class=n>cacheIndex</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>image</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
        <span class=n>CRSetCrashLogMessage2</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>image</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// try all path permutations and try open() until first success
</span><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span><span class=o>*&gt;</span> <span class=n>exceptions</span><span class=p>;</span>
    <span class=n>image</span> <span class=o>=</span> <span class=n>loadPhase0</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>orgPath</span><span class=p>,</span> <span class=n>context</span><span class=p>,</span> <span class=n>cacheIndex</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>exceptions</span><span class=p>);</span>
<span class=cp>#if !TARGET_IPHONE_SIMULATOR
</span><span class=cp></span>    <span class=c1>// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span> <span class=n>image</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=n>image</span> <span class=o>=</span> <span class=n>loadPhase2cache</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>orgPath</span><span class=p>,</span> <span class=n>context</span><span class=p>,</span> <span class=n>cacheIndex</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>exceptions</span><span class=p>);</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p><code>load()</code> 函数实现为一系列的<code>loadPhase*()</code>函数，<code>loadPhase0()</code>~<code>loadPhase1()</code>函数会按照下图顺序搜索动态库，并调用不同函数来继续处理</p><p><img src=https://w-md.imzsy.design/image-20201008181008709.png alt=image-20201008181008709></p><p>当内部调用到<code>loadPhase5load()</code>函数的时候，会先在共享缓存中搜寻</p><ul><li>存在则使用<code>ImageLoaderMachO::instantiateFromCache()</code>来实例化<code>ImageLoader</code></li><li>不存在则通过<code>loadPhase5open()</code>打开文件并读取数据到内存后，再调用<code>loadPhase6()</code>，通过<code>ImageLoaderMachO::instantiateFromFile()</code>实例化<code>ImageLoader</code>，最后调用<code>checkandAddImage()</code>验证镜像并将其加入到全局镜像列表中</li></ul><h5 id=链接主程序><a href=#链接主程序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>链接主程序</h5><p>调用 <code>link()</code>函数将实例化后的主程序进行动态修正，让二进制变为可正常执行的状态</p><p><code>link()</code>函数内部调用了<code>ImageLoader::link()</code>函数</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>ImageLoader</span><span class=o>::</span><span class=n>link</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>forceLazysBound</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>preflightOnly</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>neverUnload</span><span class=p>,</span> <span class=k>const</span> <span class=n>RPathChain</span><span class=o>&amp;</span> <span class=n>loaderRPaths</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>imagePath</span><span class=p>)</span>
<span class=p>{</span>
  <span class=p>...</span>
  <span class=kt>uint64_t</span> <span class=n>t0</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
  <span class=c1>// 递归加载加载主程序所需依赖库
</span><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>recursiveLoadLibraries</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>preflightOnly</span><span class=p>,</span> <span class=n>loaderRPaths</span><span class=p>,</span> <span class=n>imagePath</span><span class=p>);</span>
  <span class=p>...</span>
  <span class=kt>uint64_t</span> <span class=n>t1</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
  <span class=n>context</span><span class=p>.</span><span class=n>clearAllDepths</span><span class=p>();</span>
  <span class=c1>// 递归刷新依赖库的层级
</span><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>recursiveUpdateDepth</span><span class=p>(</span><span class=n>context</span><span class=p>.</span><span class=n>imageCount</span><span class=p>());</span>
  <span class=kt>uint64_t</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
  <span class=c1>// 递归进行rebase
</span><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>recursiveRebase</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
  <span class=kt>uint64_t</span> <span class=n>t3</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
  <span class=c1>// 递归绑定符号表
</span><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>recursiveBind</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>forceLazysBound</span><span class=p>,</span> <span class=n>neverUnload</span><span class=p>);</span>
  <span class=kt>uint64_t</span> <span class=n>t4</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
  <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>context</span><span class=p>.</span><span class=n>linkingMainExecutable</span> <span class=p>)</span>
      <span class=c1>// 弱符号绑定
</span><span class=c1></span>      <span class=k>this</span><span class=o>-&gt;</span><span class=n>weakBind</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
  <span class=kt>uint64_t</span> <span class=n>t5</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span> 
  <span class=n>context</span><span class=p>.</span><span class=n>notifyBatch</span><span class=p>(</span><span class=n>dyld_image_state_bound</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
  <span class=kt>uint64_t</span> <span class=n>t6</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span> 
  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>DOFInfo</span><span class=o>&gt;</span> <span class=n>dofs</span><span class=p>;</span>
  <span class=c1>// 注册DOF节
</span><span class=c1></span>  <span class=k>this</span><span class=o>-&gt;</span><span class=n>recursiveGetDOFSections</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>dofs</span><span class=p>);</span>
  <span class=n>context</span><span class=p>.</span><span class=n>registerDOFs</span><span class=p>(</span><span class=n>dofs</span><span class=p>);</span>
  <span class=kt>uint64_t</span> <span class=n>t7</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span> 
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p>主要做了以下几个事情：</p><ul><li><code>recursiveLoadLibraries()</code> 根据<code>LC_LOAD_DYLIB</code>加载命令把所有依赖库加载进内存</li><li><code>recursiveUpdateDepth()</code> 递归刷新依赖库的层级</li><li><code>recursiveRebase()</code> 由于<code>ASLR</code>的存在，必须递归对主程序以及依赖库进行重定位操作</li><li><code>recursiveBind()</code> 把主程序二进制和依赖进来的动态库全部执行符号表绑定</li><li><code>weakBind()</code> 如果链接的不是主程序二进制的话，会在此时执行弱符号绑定，主程序二进制则在<code>link()</code>完后再执行弱符号绑定，后面会进行分析</li><li><code>recursiveGetDOFSections()</code>、<code>context.registerDOFs()</code> 注册<code>DOF</code>（DTrace Object Format）节</li></ul><h5 id=链接插入的动态库><a href=#链接插入的动态库 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>链接插入的动态库</h5><p>这一步和链接主程序一样，将前面调用<code>addImage()</code>函数保存在 <code>sAllImages</code> 中的动态库列表循环取出并调用<code>link()</code>进行链接</p><blockquote><p><code>sAllImages</code>中保存的第一项是主程序的镜像，所以要从<code>i+1</code>的位置开始，取到的才是动态库的<code>ImageLoader</code></p></blockquote><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ImageLoader</span><span class=o>*</span> <span class=n>image</span> <span class=o>=</span> <span class=n>sAllImages</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</code></pre></div><p>循环调用每个镜像的<code>registerInterposing()</code>函数，该函数会遍历Mach-O的<code>LC_SEGMENT_COMMAND</code>加载命令，读取<code>__DATA</code>,<code>__interpose</code>，并将读取到的信息保存到<code>fgInterposingTuples</code>中，接着调用<code>applyInterposing()</code>函数，内部经由<code>doInterpose()</code>虚函数进行替换操作</p><p>这里以 <code>ImageLoaderMachOCompressed::doInterpose()</code> 函数为例：</p><p>内部分别调用<code>eachBind()</code> 和 <code>eachLazyBind()</code>，具体处理函数是<code>interposeAt()</code>，该函数调用<code>interposedAddress()</code>在<code>fgInterposingTuples</code>中查找需要替换的符号地址，进行最终的符号地址替换</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>doInterpose</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// update prebound symbols
</span><span class=c1></span>    <span class=n>eachBind</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>interposeAt</span><span class=p>);</span>
    <span class=n>eachLazyBind</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>interposeAt</span><span class=p>);</span>
<span class=p>}</span>
<span class=n>uintptr_t</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>interposeAt</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkContext</span><span class=o>&amp;</span> <span class=n>context</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span><span class=p>,</span> 
                                                <span class=kt>uint8_t</span><span class=p>,</span> <span class=n>intptr_t</span><span class=p>,</span> <span class=kt>long</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span><span class=p>,</span> <span class=n>LastLookup</span><span class=o>*</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>runResolver</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>type</span> <span class=o>==</span> <span class=n>BIND_TYPE_POINTER</span> <span class=p>)</span> <span class=p>{</span>
        <span class=n>uintptr_t</span><span class=o>*</span> <span class=n>fixupLocation</span> <span class=o>=</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>;</span>
        <span class=n>uintptr_t</span> <span class=n>curValue</span> <span class=o>=</span> <span class=o>*</span><span class=n>fixupLocation</span><span class=p>;</span>
        <span class=n>uintptr_t</span> <span class=n>newValue</span> <span class=o>=</span> <span class=n>interposedAddress</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>curValue</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>newValue</span> <span class=o>!=</span> <span class=n>curValue</span><span class=p>)</span> <span class=p>{</span>
            <span class=o>*</span><span class=n>fixupLocation</span> <span class=o>=</span> <span class=n>newValue</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h5 id=执行弱符号绑定><a href=#执行弱符号绑定 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>执行弱符号绑定</h5><p><code>weakBind()</code>首先通过<code>getCoalescedImages()</code>合并所有动态库的弱符号到一个列表里，然后调用<code>initializeCoalIterator()</code>对需要绑定的弱符号进行排序，接着调用<code>incrementCoalIterator()</code>读取<code>dyld_info_command</code>结构的<code>weak_bind_off</code>和<code>weak_bind_size</code>字段，确定弱符号的数据偏移与大小，最终进行弱符号绑定，代码如下：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>bool</span> <span class=n>ImageLoaderMachOCompressed</span><span class=o>::</span><span class=n>incrementCoalIterator</span><span class=p>(</span><span class=n>CoalIterator</span><span class=o>&amp;</span> <span class=n>it</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span> <span class=n>it</span><span class=p>.</span><span class=n>done</span> <span class=p>)</span>
        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
    
    <span class=k>if</span> <span class=p>(</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>fDyldInfo</span><span class=o>-&gt;</span><span class=n>weak_bind_size</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
        <span class=c1>/// hmmm, ld set MH_WEAK_DEFINES or MH_BINDS_TO_WEAK, but there is no weak binding info
</span><span class=c1></span>        <span class=n>it</span><span class=p>.</span><span class=n>done</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=n>it</span><span class=p>.</span><span class=n>symbolName</span> <span class=o>=</span> <span class=s>&#34;~~~&#34;</span><span class=p>;</span>
        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>start</span> <span class=o>=</span> <span class=n>fLinkEditBase</span> <span class=o>+</span> <span class=n>fDyldInfo</span><span class=o>-&gt;</span><span class=n>weak_bind_off</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>start</span> <span class=o>+</span> <span class=n>it</span><span class=p>.</span><span class=n>curIndex</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>end</span> <span class=o>=</span> <span class=n>fLinkEditBase</span> <span class=o>+</span> <span class=n>fDyldInfo</span><span class=o>-&gt;</span><span class=n>weak_bind_off</span> <span class=o>+</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>fDyldInfo</span><span class=o>-&gt;</span><span class=n>weak_bind_size</span><span class=p>;</span>
    <span class=n>uintptr_t</span> <span class=n>count</span><span class=p>;</span>
    <span class=n>uintptr_t</span> <span class=n>skip</span><span class=p>;</span>
    <span class=n>uintptr_t</span> <span class=n>segOffset</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint8_t</span> <span class=n>immediate</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span> <span class=o>&amp;</span> <span class=n>BIND_IMMEDIATE_MASK</span><span class=p>;</span>
        <span class=kt>uint8_t</span> <span class=n>opcode</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span> <span class=o>&amp;</span> <span class=n>BIND_OPCODE_MASK</span><span class=p>;</span>
        <span class=o>++</span><span class=n>p</span><span class=p>;</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>opcode</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nl>BIND_OPCODE_DONE</span><span class=p>:</span>
                <span class=n>it</span><span class=p>.</span><span class=n>done</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
                <span class=n>it</span><span class=p>.</span><span class=n>curIndex</span> <span class=o>=</span> <span class=n>p</span> <span class=o>-</span> <span class=n>start</span><span class=p>;</span>
                <span class=n>it</span><span class=p>.</span><span class=n>symbolName</span> <span class=o>=</span> <span class=s>&#34;~~~&#34;</span><span class=p>;</span> <span class=c1>// sorts to end
</span><span class=c1></span>                <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>break</span><span class=p>;</span>
        <span class=p>...</span>
    <span class=p>}</span>
    <span class=p>...</span>
    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h5 id=执行初始化方法><a href=#执行初始化方法 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>执行初始化方法</h5><p>这一步由<code>initializeMainExecutable()</code>完成，<code>dyld</code>会优先初始化动态库，然后初始化主程序</p><p>该函数首先执行<code>runInitializers()</code>，内部再依次调用<code>processInitializers()</code>、<code>recursiveInitialization()</code></p><p>在<code>recursiveInitialization()</code>函数里找到了<code>notifySingle()</code>函数：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>context</span><span class=p>.</span><span class=n>notifySingle</span><span class=p>(</span><span class=n>dyld_image_state_dependents_initialized</span><span class=p>,</span> <span class=k>this</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>timingInfo</span><span class=p>);</span>
</code></pre></div><p>接着跟进<code>notifySingle</code>函数，看到下面处理代码：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>state</span> <span class=o>==</span> <span class=n>dyld_image_state_dependents_initialized</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>sNotifyObjCInit</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>notifyObjC</span><span class=p>()</span> <span class=p>)</span> <span class=p>{</span>
    <span class=kt>uint64_t</span> <span class=n>t0</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
    <span class=p>(</span><span class=o>*</span><span class=n>sNotifyObjCInit</span><span class=p>)(</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>getRealPath</span><span class=p>(),</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>machHeader</span><span class=p>());</span>
    <span class=kt>uint64_t</span> <span class=n>t1</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
    <span class=kt>uint64_t</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
    <span class=kt>uint64_t</span> <span class=n>timeInObjC</span> <span class=o>=</span> <span class=n>t1</span><span class=o>-</span><span class=n>t0</span><span class=p>;</span>
    <span class=kt>uint64_t</span> <span class=n>emptyTime</span> <span class=o>=</span> <span class=p>(</span><span class=n>t2</span><span class=o>-</span><span class=n>t1</span><span class=p>)</span><span class=o>*</span><span class=mi>100</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>timeInObjC</span> <span class=o>&gt;</span> <span class=n>emptyTime</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>timingInfo</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>)</span> <span class=p>{</span>
        <span class=n>timingInfo</span><span class=o>-&gt;</span><span class=n>addTime</span><span class=p>(</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>getShortName</span><span class=p>(),</span> <span class=n>timeInObjC</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>关心的只有<code>sNotifyObjCInit</code>这个回调，继续寻找赋值的地方：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>registerObjCNotifiers</span><span class=p>(</span><span class=n>_dyld_objc_notify_mapped</span> <span class=n>mapped</span><span class=p>,</span> <span class=n>_dyld_objc_notify_init</span> <span class=n>init</span><span class=p>,</span> <span class=n>_dyld_objc_notify_unmapped</span> <span class=n>unmapped</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// record functions to call
</span><span class=c1></span>    <span class=n>sNotifyObjCMapped</span>   <span class=o>=</span> <span class=n>mapped</span><span class=p>;</span>
    <span class=n>sNotifyObjCInit</span>     <span class=o>=</span> <span class=n>init</span><span class=p>;</span>
    <span class=n>sNotifyObjCUnmapped</span> <span class=o>=</span> <span class=n>unmapped</span><span class=p>;</span>
    <span class=p>...</span>
</code></pre></div><p>接着找<code>registerObjCNotifiers</code>函数调用，最终找到这里：</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>_dyld_objc_notify_register</span><span class=p>(</span><span class=n>_dyld_objc_notify_mapped</span>    <span class=n>mapped</span><span class=p>,</span>
                                <span class=n>_dyld_objc_notify_init</span>      <span class=n>init</span><span class=p>,</span>
                                <span class=n>_dyld_objc_notify_unmapped</span>  <span class=n>unmapped</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>dyld</span><span class=o>::</span><span class=n>registerObjCNotifiers</span><span class=p>(</span><span class=n>mapped</span><span class=p>,</span> <span class=n>init</span><span class=p>,</span> <span class=n>unmapped</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>那么究竟是谁调用了<code>_dyld_objc_notify_register()</code></p><p>静态分析已经无法得知，只能对<code>_dyld_objc_notify_register</code>下个符号断点，打印堆栈来探索一下了</p><div class=highlight><pre class=chroma><code class=language-ruby data-lang=ruby><span class=o>*</span> <span class=n>thread</span> <span class=c1>#1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.2</span>
  <span class=o>*</span> <span class=n>frame</span> <span class=c1>#0: 0x00007fff2025bda1 libdyld.dylib`_dyld_objc_notify_register</span>
    <span class=n>frame</span> <span class=c1>#1: 0x00007fff2018dbdb libobjc.A.dylib`_objc_init + 1092</span>
    <span class=n>frame</span> <span class=c1>#2: 0x000000010bed1110 libdispatch.dylib`_os_object_init + 13</span>
    <span class=n>frame</span> <span class=c1>#3: 0x000000010bee047d libdispatch.dylib`libdispatch_init + 303</span>
    <span class=n>frame</span> <span class=c1>#4: 0x00007fff531d286f libSystem.B.dylib`libSystem_initializer + 252</span>
    <span class=n>frame</span> <span class=c1>#5: 0x000000010bc8794b dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 537</span>
    <span class=n>frame</span> <span class=c1>#6: 0x000000010bc87d34 dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40</span>
    <span class=n>frame</span> <span class=c1>#7: 0x000000010bc82899 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 455</span>
    <span class=n>frame</span> <span class=c1>#8: 0x000000010bc82806 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 308</span>
    <span class=n>frame</span> <span class=c1>#9: 0x000000010bc80bb0 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 188</span>
    <span class=n>frame</span> <span class=c1>#10: 0x000000010bc80c50 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 82</span>
    <span class=n>frame</span> <span class=c1>#11: 0x000000010bc74263 dyld_sim`dyld::initializeMainExecutable() + 129</span>
    <span class=n>frame</span> <span class=c1>#12: 0x000000010bc78d50 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4431</span>
    <span class=n>frame</span> <span class=c1>#13: 0x000000010bc731c7 dyld_sim`start_sim + 122</span>
    <span class=n>frame</span> <span class=c1>#14: 0x0000000110dac85c dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308</span>
    <span class=n>frame</span> <span class=c1>#15: 0x0000000110daa4f4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837</span>
    <span class=n>frame</span> <span class=c1>#16: 0x0000000110da5227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453</span>
    <span class=n>frame</span> <span class=c1>#17: 0x0000000110da5025 dyld`_dyld_start + 37</span>
</code></pre></div><p>从调用栈看到是<code>libobjc.A.dylib</code>的<code>_objc_init</code>函数调用了<code>_dyld_objc_notify_register()</code></p><p>从 objc源码中，找到<code>_objc_init</code>函数</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>_objc_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=kt>bool</span> <span class=n>initialized</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>initialized</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
    <span class=n>initialized</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    
    <span class=c1>// fixme defer initialization until an objc-using image is found?
</span><span class=c1></span>    <span class=n>environ_init</span><span class=p>();</span>
    <span class=n>tls_init</span><span class=p>();</span>
    <span class=n>static_init</span><span class=p>();</span>
    <span class=n>runtime_init</span><span class=p>();</span>
    <span class=n>exception_init</span><span class=p>();</span>
    <span class=n>cache_init</span><span class=p>();</span>
    <span class=n>_imp_implementationWithBlock_init</span><span class=p>();</span>

    <span class=n>_dyld_objc_notify_register</span><span class=p>(</span><span class=o>&amp;</span><span class=n>map_images</span><span class=p>,</span> <span class=n>load_images</span><span class=p>,</span> <span class=n>unmap_image</span><span class=p>);</span>

<span class=cp>#if __OBJC2__
</span><span class=cp></span>    <span class=n>didCallDyldNotifyRegister</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span><span class=p>}</span>
</code></pre></div><p>这里注册的 init 回调函数就是 <code>load_images()</code>，回调函数<code>load_images()</code>里面会调用<code>call_load_methods()</code>来执行所有的<code>+load()</code>方法，这也就验证了，为什么一开始<code>+load()</code>函数会比 <code>main()</code> 函数先执行</p><p>从文章一开始的堆栈中可以看到<code>notifySingle()</code>之后调用<code>doInitialization()</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// initialize this image
</span><span class=c1>// 调用constructor()
</span><span class=c1></span><span class=kt>bool</span> <span class=n>hasInitializers</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>doInitialization</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</code></pre></div><p><code>doInitialization()</code>内部调用顺序</p><ul><li><code>doImageInit</code>来执行镜像的初始化函数，也就是<code>LC_ROUTINES_COMMAND</code>中记录的函数，</li><li><code>doModInitFunctions()</code>方法来解析并执行<code>_DATA_</code>,<code>__mod_init_func</code>这个<code>section</code>中保存的函数</li></ul><p><code>_mod_init_funcs</code>中保存的是全局<code>C++</code>对象的构造函数以及所有带<code>__attribute__</code>((constructor)的C函数</p><p>我们在 <code>main()</code> 函数中加入以下代码</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=cp>#import &#34;AppDelegate.h&#34;
</span><span class=cp></span>
<span class=n>__attribute__</span><span class=p>((</span><span class=n>constructor</span><span class=p>))</span>  <span class=kt>void</span> <span class=n>init_func1</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
<span class=p>}</span>


<span class=n>__attribute__</span><span class=p>((</span><span class=n>constructor</span><span class=p>))</span>  <span class=kt>void</span> <span class=n>init_func2</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=n>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
    <span class=n>NSString</span> <span class=o>*</span> <span class=n>appDelegateClassName</span><span class=p>;</span>
    <span class=k>@autoreleasepool</span> <span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;main&#34;</span><span class=p>);</span>
        <span class=c1>// Setup code that might create autoreleased objects goes here.
</span><span class=c1></span>        <span class=n>appDelegateClassName</span> <span class=o>=</span> <span class=n>NSStringFromClass</span><span class=p>([</span><span class=n>AppDelegate</span> <span class=k>class</span><span class=p>]);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>UIApplicationMain</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=nb>nil</span><span class=p>,</span> <span class=n>appDelegateClassName</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>输出：</p><div class=highlight><pre class=chroma><code class=language-ruby data-lang=ruby><span class=mi>2020</span><span class=o>-</span><span class=mi>09</span><span class=o>-</span><span class=mi>25</span> <span class=mi>19</span><span class=p>:</span><span class=mi>12</span><span class=p>:</span><span class=mi>41</span><span class=o>.</span><span class=mi>850546</span><span class=o>+</span><span class=mi>0800</span> <span class=no>DyldTest</span><span class=o>[</span><span class=mi>14523</span><span class=p>:</span><span class=mi>25898716</span><span class=o>]</span> <span class=nb>load</span>
<span class=n>init_func1</span>
<span class=n>init_func2</span>
<span class=mi>2020</span><span class=o>-</span><span class=mi>09</span><span class=o>-</span><span class=mi>25</span> <span class=mi>19</span><span class=p>:</span><span class=mi>12</span><span class=p>:</span><span class=mi>41</span><span class=o>.</span><span class=mi>851222</span><span class=o>+</span><span class=mi>0800</span> <span class=no>DyldTest</span><span class=o>[</span><span class=mi>14523</span><span class=p>:</span><span class=mi>25898716</span><span class=o>]</span> <span class=n>main</span>
</code></pre></div><h5 id=查找程序入口点并返回><a href=#查找程序入口点并返回 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>查找程序入口点并返回</h5><p>这一步调用主程序镜像的<code>getThreadPC()</code>，从加载命令读取<code>LC_MAIN</code>入口，如果没有<code>LC_MAIN</code>就调用<code>getMain()</code>读取<code>LC_UNIXTHREAD</code>，找到后就跳到入口点指定的地址并返回</p><p>至此，整个 dyld 的加载过程就分析完了</p><h3 id=dyld-加载流程图><a href=#dyld-加载流程图 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dyld 加载流程图</h3><p><img src=https://w-md.imzsy.design/dyld%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png alt=dyld加载过程></p><h3 id=参考资料><a href=#参考资料 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>参考资料</h3><blockquote><p><a href=https://leylfl.github.io/2018/05/28/dyld%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/ target=_blank rel=noopener>dyld启动流程</a></p><p><a href=http://www.zoomfeng.com/blog/launch-optimize-from-wwdc2019.html target=_blank rel=noopener>WWDC2019之启动时间与Dyld3</a></p><p><a href=https://developer.apple.com/videos/play/wwdc2017/413/ target=_blank rel=noopener>App Startup Time: Past, Present, and Future</a></p><p><a href=https://www.dllhook.com/post/238.html target=_blank rel=noopener>dyld详解</a></p></blockquote></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>