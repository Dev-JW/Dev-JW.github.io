<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>栈和队列练习 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="算法题 代码仓库地址 1. 括号匹配检验 假设表达式中允许包含两种括号：圆括号和方括号,其嵌套……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/Stack-Queue-Exercise/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-04-14T10:00:00+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/Stack-Queue-Exercise/","name":"栈和队列练习","description":"算法题 代码仓库地址 1. 括号匹配检验 假设表达式中允许包含两种括号：圆括号和方括号,其嵌套……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="栈和队列练习"><meta property="og:description" content="算法题 代码仓库地址 1. 括号匹配检验 假设表达式中允许包含两种括号：圆括号和方括号,其嵌套……"><meta property="og:url" content="https://dev.hjw.best/Stack-Queue-Exercise/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">栈和队列练习</h1><div class=post-meta><time datetime=2020-04-14T10:00:00+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-04-14</time></div><div class="post-body e-content"><h3 id=算法题><a href=#算法题 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>算法题</h3><blockquote><p><a href=https://github.com/dev-jw/linearList target=_blank rel=noopener>代码仓库地址</a></p></blockquote><h4 id=1-括号匹配检验httpsleetcode-cncomproblemsvalid-parentheses><a href=#1-括号匹配检验httpsleetcode-cncomproblemsvalid-parentheses class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>1. <a href=https://leetcode-cn.com/problems/valid-parentheses/ target=_blank rel=noopener>括号匹配检验</a></h4><p>假设表达式中允许包含两种括号：圆括号和方括号,其嵌套的顺序随意,即<code>([]())</code>或<code>[([][])]</code>等为正确的格式，<code>[(]</code>或<code>([())</code>或<code>(()])</code>均为不正确的格式。输入一个包含上述括号的表达式，检验括号是否配对。</p><p><strong>思路</strong></p><ul><li><p><strong>算法原理</strong></p><p>栈<strong>后进先出</strong>的特性刚好与本题括号排序特点一致，即若遇到<strong>左括号入栈</strong>，遇到<strong>右括号</strong>时将对应<strong>栈顶左括号</strong>出栈，则遍历完所有括号后，栈<code>stack</code>仍为空</p></li><li><p><strong>算法流程</strong></p><ul><li>当前遍历括号是<strong>左括号</strong>，则<strong>入栈</strong></li><li>当前遍历括号不是<strong>左括号</strong>：<ul><li>如果栈为空，则无法匹配，返回-1</li><li>如果与栈顶括号匹配成功，<strong>出栈</strong></li><li>如果与栈顶括号匹配失败，返回-1</li></ul></li><li>最后判断栈是否为空</li></ul></li><li><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，n是字符串的长度</li><li><strong>空间复杂度：O(1)</strong></li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>isValid</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 空字符串符合
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=o>*</span><span class=n>s</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
    <span class=c1>// 长度为奇数，一定不符合
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>length</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
    
    <span class=c1>// 创建顺序栈
</span><span class=c1></span>    <span class=kt>char</span> <span class=n>stack</span><span class=p>[</span><span class=n>length</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>

    <span class=c1>// 遍历字符串
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;(&#39;</span> <span class=o>||</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;[&#39;</span> <span class=o>||</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;{&#39;</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 如果是左括号，入栈
</span><span class=c1></span>            <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span><span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>top</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 如果不是左括号，栈为空，无法匹配
</span><span class=c1></span>            <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
        <span class=p>}</span><span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 如果不是左括号，栈非空，当前字符和栈顶字符匹配成功，出栈
</span><span class=c1></span>            <span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=o>--</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;#&#39;</span><span class=p>;</span>
        <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 如果不是左括号，栈非空，当前字符和栈顶字符无法匹配
</span><span class=c1></span>            <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>top</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// 判断栈是否为空
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h4 id=2-每日气温httpsleetcode-cncomproblemsdaily-temperatures><a href=#2-每日气温httpsleetcode-cncomproblemsdaily-temperatures class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>2. <a href=https://leetcode-cn.com/problems/daily-temperatures/ target=_blank rel=noopener>每日气温</a></h4><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的都是 [30, 100] 范围内的整数。</p><p><strong>图解</strong></p><p><img src=https://w-md.imzsy.design/%E6%AF%8F%E6%97%A5%E6%B0%94%E6%B8%A9.gif alt=每日气温></p><p><strong>思路</strong></p><ul><li><p><strong>算法原理</strong></p><p>我们可以借助栈<strong>后进先出</strong>的特性来解决这个问题，但是有一点特殊的是，这个栈是<strong>递减栈</strong>，栈里只有递减元素，记录气温索引位置。</p></li><li><p><strong>算法流程</strong></p><ul><li>遍历整个数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是 <strong>递减栈</strong> ，所以需要取出栈顶元素，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。</li></ul></li><li><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，只需要遍历一次数组，每个元素最多被压入或者弹出栈一次</li><li><strong>空间复杂度：O(n)</strong></li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span><span class=o>*</span> <span class=nf>dailyTemperatures</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>TSize</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>returnSize</span><span class=p>)</span> <span class=p>{</span>

    <span class=c1>// 创建 记录 数组
</span><span class=c1></span>    <span class=kt>int</span> <span class=o>*</span><span class=n>ans</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=n>TSize</span><span class=p>);</span>
    
    <span class=c1>// 初始化数组元素为0
</span><span class=c1></span>    <span class=n>memset</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>TSize</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>

    <span class=c1>// 创建栈
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>stack</span><span class=p>[</span><span class=n>TSize</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>

    <span class=c1>// 正序遍历
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>TSize</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 如果栈顶元素小于当前气温，记录下标索引的距离差，同时出栈
</span><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>top</span> <span class=o>&gt;</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>T</span><span class=p>[</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]]</span> <span class=o>&lt;</span> <span class=n>T</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
            <span class=n>ans</span><span class=p>[</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>];</span>
            <span class=n>top</span><span class=o>--</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 否则将下标索引入栈
</span><span class=c1></span>        <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=o>*</span><span class=n>returnSize</span> <span class=o>=</span> <span class=n>TSize</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=3-爬楼梯问题httpsleetcode-cncomproblemsclimbing-stairs><a href=#3-爬楼梯问题httpsleetcode-cncomproblemsclimbing-stairs class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>3. <a href=https://leetcode-cn.com/problems/climbing-stairs/ target=_blank rel=noopener>爬楼梯问题</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意</strong>：给定 <em>n</em> 是一个正整数。</p><p><strong>思路：</strong></p><ul><li><strong>方法一：暴力递归</strong><ul><li>把所有可能的阶数进行组合，也就是1和2。而在之后的每一步中，我们都是反复调用climbStairs函数去模拟爬1阶和2阶的情形，并返回两个函数的返回值之和</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 第一种写法
</span><span class=c1></span><span class=kt>int</span> <span class=nf>climb_Stairs</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>climb_Stairs</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>+</span> <span class=n>climb_Stairs</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>climbStairs</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
 	 <span class=k>return</span> <span class=n>climb_Stairs</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
<span class=p>}</span>

<span class=c1>// 第二种写法
</span><span class=c1></span><span class=kt>int</span> <span class=nf>climbStairs</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span><span class=mi>2</span> <span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>climbStairs</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>climbStairs</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
<span class=p>}</span>

</code></pre></div><ul><li><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：O($2^n$)</strong> ，树形递归的大小为$2^n$</li><li><strong>空间复杂度：O(n)</strong> ，递归树的深度可以达到n</li></ul></li><li><p><strong>方法二：动态规划</strong></p><ul><li>首先，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建</li><li>第 <code>i</code> 阶可以由以下两种方法得到：<ol><li>在第 <code>i - 1</code>阶后向上爬一阶</li><li>在第 <code>i - 2</code>阶后向上爬二阶</li></ol></li><li>所以到达第 i 阶的方法总是就是第 i- 1 阶和第 i - 2 阶的方法数之和, 即$dp[i] = dp[i - 1] + dp[i - 2]$</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>climbStairsDP</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    
    <span class=kt>int</span> <span class=o>*</span><span class=n>dp</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>dp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></div><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：O(n)</strong></li><li><strong>空间复杂度：O(n)</strong></li></ul><h4 id=4-去除重复字符httpsleetcode-cncomproblemsremove-duplicate-letters><a href=#4-去除重复字符httpsleetcode-cncomproblemsremove-duplicate-letters class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>4. <a href=https://leetcode-cn.com/problems/remove-duplicate-letters/ target=_blank rel=noopener>去除重复字符</a></h4><p>给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: "bcabc"
输出: "abc"</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: "cbacdcbc"
输出: "acdb"</p></blockquote><p><strong>思路：</strong> 贪心 + 栈</p><ul><li><strong>算法原理</strong><ul><li>什么是“字典序”。字符串之间比较和数字之间比较是不太一样的，字符串是从头往后一个字符一个字符比较的，哪个字符大取决于两个字符串中<strong>第一个不对应相等的字符</strong>。</li><li>也就是说，任意一个以<code>a</code>开头的字符串都大于任意一个以<code>b</code>开头的字符串</li></ul></li><li><strong>算法流程</strong><ul><li>遍历字符串，获取每个字符的出现次数，保存在计数器中</li><li>如果<strong>栈顶元素</strong>比当前元素的字典序大，并且当前元素的位置后面还有栈顶元素，就将栈顶元素<strong>出栈</strong>，将当前元素入栈</li></ul></li><li><strong>复杂度</strong><ul><li><strong>时间复杂度：O(n)</strong> ，虽然外循环里面有一个内循环，但是内循环的次数受栈中剩余字符总数的限制</li><li><strong>空间复杂度：O(n)</strong> ，申请栈的空间为字符串的长度+1</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span> <span class=nf>removeDuplicateLetters</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span> <span class=n>s</span><span class=p>){</span>
    
    <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>

    <span class=c1>// 空字符串
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=c1>// 计数
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>letter</span><span class=p>[</span><span class=mi>26</span><span class=p>];</span> <span class=c1>// 计数器必须初始化
</span><span class=c1></span>    <span class=n>memset</span><span class=p>(</span><span class=n>letter</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>26</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>letter</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=c1>// 创建栈
</span><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>res</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=n>memset</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=kt>int</span> <span class=n>top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    
    <span class=c1>// 遍历字符串
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        
        <span class=kt>int</span> <span class=n>isExist</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>top</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 如果当前字符，已经在栈中
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>res</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
                <span class=n>isExist</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>isExist</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>letter</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span><span class=o>--</span><span class=p>;</span>
            <span class=k>continue</span><span class=p>;</span>
        <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
            <span class=cm>/* 栈顶元素比当前元素的字典序大，当前元素的位置后面还有栈顶元素，就将栈顶元素出栈 */</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>top</span> <span class=o>&gt;</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>res</span><span class=p>[</span><span class=n>top</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>letter</span><span class=p>[</span><span class=n>res</span><span class=p>[</span><span class=n>top</span><span class=p>]</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
              <span class=c1>// 计数器--
</span><span class=c1></span>              <span class=n>letter</span><span class=p>[</span><span class=n>res</span><span class=p>[</span><span class=n>top</span><span class=p>]</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span><span class=o>--</span><span class=p>;</span>
              <span class=c1>// 出栈
</span><span class=c1></span>              <span class=n>top</span><span class=o>--</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=c1>// 将当前元素入栈
</span><span class=c1></span>            <span class=n>res</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
    
    <span class=c1>// 结束标识
</span><span class=c1></span>    <span class=n>res</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></div><h4 id=5-字符串解码httpsleetcode-cncomproblemsdecode-string><a href=#5-字符串解码httpsleetcode-cncomproblemsdecode-string class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>5. <a href=https://leetcode-cn.com/problems/decode-string/ target=_blank rel=noopener>字符串解码</a></h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为:<code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code>正好重复<code>k</code>次，<code>k</code>为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p><strong>示例：</strong></p><blockquote><p>s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".</p></blockquote><p><strong>思路：</strong></p><ul><li><strong>方法一：辅助栈</strong></li><li><strong>算法原理</strong><ul><li>利用栈的先进后出思想，以及C函数<code>sscanf</code>分离数字和字符</li></ul></li><li><strong>算法流程</strong><ul><li>首先遍历字符串，将第一个匹配到<code>]</code>字符之前的所有字符入栈</li><li>匹配到<code>]</code>之后，将之前的栈中的元素出栈，并通过C函数库将字符和数字分离</li><li>拼接指定次数的字符压入栈中</li><li>再继续遍历原字符串，直到结束</li></ul></li><li><strong>复杂度</strong><ul><li><strong>时间复杂度：O(N)</strong> ，只需遍历一次字符串</li><li><strong>空间复杂度：O(N)</strong></li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define IsStackEmpty (top == -1)
</span><span class=cp>#define MAX_RESULT_SIZE 10000
</span><span class=cp></span>
<span class=kt>char</span> <span class=o>*</span> <span class=nf>decodeString</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span> <span class=n>s</span><span class=p>){</span>
    
    <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
    
    <span class=cm>/* 空字符串 */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
    <span class=p>}</span>
        
    <span class=cm>/* 初始化一个字符串，存储最后的结果 */</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>ans</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=n>MAX_RESULT_SIZE</span><span class=p>);</span>
    <span class=n>memset</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=n>MAX_RESULT_SIZE</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    
    <span class=kt>char</span> <span class=o>*</span><span class=n>stack</span> <span class=o>=</span> <span class=n>ans</span><span class=p>;</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* 栈为空，或者不是右括号 */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>IsStackEmpty</span> <span class=o>||</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>!=</span> <span class=sc>&#39;]&#39;</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
        <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
            <span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    
            <span class=cm>/* 如果栈顶元素不是数字  */</span>
            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>IsStackEmpty</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>isdigit</span><span class=p>(</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]))</span> <span class=p>{</span>
                <span class=n>str</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=o>--</span><span class=p>];</span>
            <span class=p>}</span>
            <span class=cm>/* 如果栈顶元素是数字 */</span>
            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>IsStackEmpty</span> <span class=o>&amp;&amp;</span> <span class=n>isdigit</span><span class=p>(</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=p>]))</span> <span class=p>{</span>
                <span class=n>str</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=o>--</span><span class=p>];</span>
            <span class=p>}</span>
            <span class=kt>int</span> <span class=n>k</span><span class=p>;</span>
            <span class=kt>char</span> <span class=n>tmp</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1000</span><span class=p>];</span>
            <span class=cm>/* 解析数字和字符 */</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>sscanf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;%d[%[^]]&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>k</span><span class=p>,</span> <span class=n>tmp</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
                <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
                <span class=n>top</span> <span class=o>+=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>tmp</span><span class=p>)</span><span class=o>*</span><span class=n>k</span><span class=p>;</span> <span class=cm>/* 这个必须在扩展前操作因为k会变更 */</span>
                <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
                    <span class=n>strcat</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
                    <span class=n>k</span><span class=o>--</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=n>p</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ans</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=6-杨辉三角httpsleetcode-cncomproblemspascals-triangle><a href=#6-杨辉三角httpsleetcode-cncomproblemspascals-triangle class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>6. <a href=https://leetcode-cn.com/problems/pascals-triangle/ target=_blank rel=noopener>杨辉三角</a></h4><p>给定一个非负整数 *numRows，*生成杨辉三角的前 <em>numRows</em> 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例：</strong></p><pre><code>输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre><p>**思路：**动态规划</p><ul><li><p><strong>算法原理</strong></p><ul><li>知道一行杨辉三角，就可以根据每对相邻的值计算出它的下一行，这里直接使用动态规划就行了</li></ul></li><li><p><strong>算法流程</strong></p><ul><li>第一个循环，先将每行的元素个数记录，同时将每行第一个和最后一个元素赋值为1</li><li>第二个循环，根据上一行的相邻两个数，算出对应位置的值</li></ul></li><li><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：$O(numRows^2)$</strong>，更新总数为1+2+3+...+numRows，根据高斯公式</li></ul><p>$$
\frac{numRows(numRows + 1)}{2}
$$</p><ul><li><strong>空间复杂度：$O(numRows^2)$</strong></li></ul></li></ul><blockquote><p>主要注意，指针和数组的形式</p></blockquote><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span><span class=o>**</span> <span class=nf>generate</span><span class=p>(</span><span class=kt>int</span> <span class=n>numRows</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>returnSize</span><span class=p>,</span> <span class=kt>int</span><span class=o>**</span> <span class=n>returnColumnSizes</span><span class=p>){</span>
    <span class=o>*</span><span class=n>returnSize</span> <span class=o>=</span> <span class=n>numRows</span><span class=p>;</span>
    <span class=o>*</span><span class=n>returnColumnSizes</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=n>numRows</span><span class=p>);</span>
    <span class=kt>int</span> <span class=o>**</span><span class=n>res</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>**</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=o>*</span> <span class=n>numRows</span><span class=p>);</span>
    
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=o>*</span><span class=n>returnSize</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>(</span><span class=o>*</span><span class=n>returnColumnSizes</span><span class=p>)[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>returnColumnSizes</span><span class=p>)[</span><span class=n>i</span><span class=p>]);</span>
        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numRows</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>res</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>res</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=7-七进制数httpsleetcode-cncomproblemsbase-7><a href=#7-七进制数httpsleetcode-cncomproblemsbase-7 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>7. <a href=https://leetcode-cn.com/problems/base-7/ target=_blank rel=noopener>七进制数</a></h4><p>给定一个整数，将其转化为7进制，并以字符串形式输出。</p><p><strong>示例 1:</strong></p><pre><code>输入: 101
输出: &quot;203&quot;
</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: -7
输出: &quot;-10&quot;
</code></pre><p><strong>注意:</strong> 输入范围是 [-1e7, 1e7] 。</p><p><strong>思路：</strong></p><ul><li><strong>算法原理</strong><ul><li>十进制数<code>N</code>和其它<code>d进制数</code>的转换的算法基于原理：<br>$$
N = (N / d) * d + N % d
$$</li></ul></li></ul><div class=table-container><table><thead><tr><th>N</th><th>N / d</th><th>N mod d</th></tr></thead><tbody><tr><td>100</td><td>14</td><td>3</td></tr><tr><td>14</td><td>2</td><td>0</td></tr><tr><td>2</td><td>0</td><td>2</td></tr><tr><td>根据上面的计算过程，可以得到最好的结果为<code>203</code>，计算顺序与输出顺序正好相反。</td><td></td><td></td></tr></tbody></table></div><p>可以借助<strong>栈先进后出的特性</strong>实现</p><ul><li><p><strong>算法流程</strong></p><ul><li>按照公式，将每次取余的结果入栈</li></ul></li><li><p>遍历出栈，即为最终结果</p></li><li><p><strong>复杂度</strong></p><ul><li><strong>时间复杂度：O(n)</strong></li><li><strong>空间复杂度：O(n)</strong></li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span> <span class=nf>convertToBase</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>,</span> <span class=kt>int</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span>
    
    <span class=c1>// 创建栈
</span><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span> <span class=n>stack</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=mi>13</span><span class=p>);</span>
    <span class=n>memset</span><span class=p>(</span><span class=n>stack</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=mi>13</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    
    <span class=c1>// 入栈
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>abs</span><span class=p>(</span><span class=n>num</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>N</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=n>N</span> <span class=o>%</span> <span class=n>d</span> <span class=o>+</span> <span class=sc>&#39;0&#39;</span><span class=p>;</span>
        <span class=n>N</span> <span class=o>=</span> <span class=n>N</span> <span class=o>/</span> <span class=n>d</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=c1>// 处理符号
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>num</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;-&#39;</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=c1>// 特殊情况 0
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>num</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>stack</span><span class=p>[</span><span class=o>++</span><span class=n>top</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;0&#39;</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=c1>// 出栈
</span><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>res</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>stack</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=n>memset</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>stack</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    
    <span class=k>while</span> <span class=p>(</span><span class=n>top</span> <span class=o>&gt;</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>res</span><span class=p>[</span><span class=o>++</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>stack</span><span class=p>[</span><span class=n>top</span><span class=o>--</span><span class=p>];</span>
    <span class=p>}</span>
    
    <span class=c1>// 字符串结束标识
</span><span class=c1></span>    <span class=n>res</span><span class=p>[</span><span class=o>++</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>char</span> <span class=o>*</span> <span class=nf>converToBase7</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>convertToBase</span><span class=p>(</span><span class=n>num</span><span class=p>,</span> <span class=mi>7</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></div></article><div class=post-tags><a href=../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>数据结构与算法</a>
<a href=../tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>线性结构</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>