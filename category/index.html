<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-分类和拓展的加载 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="上篇文章iOS底层原理探索-类的加载分析了类的加载过程，理解了类是如何从 Mach-O 加载到内存……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/category/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-10-16T20:02:39+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/category/","name":"iOS底层原理探索-分类和拓展的加载","description":"上篇文章iOS底层原理探索-类的加载分析了类的加载过程，理解了类是如何从 Mach-O 加载到内存……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-分类和拓展的加载"><meta property="og:description" content="上篇文章iOS底层原理探索-类的加载分析了类的加载过程，理解了类是如何从 Mach-O 加载到内存……"><meta property="og:url" content="https://dev.hjw.best/category/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-分类和拓展的加载</h1><div class=post-meta><time datetime=2020-10-16T20:02:39+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-10-16</time></div><div class="post-body e-content"><p>上篇文章<a href=../class-load>iOS底层原理探索-类的加载</a>分析了<code>类的加载</code>过程，理解了类是如何从 Mach-O 加载到内存中，但是还没有对<code>attachCategories</code>详细展开，而这个函数正是分类的加载的入口</p><p>（请先对<code>类的加载过程</code>有了一定了解之后再开启本文）</p><p>同样的，提出几个问题：</p><ul><li>分类的本质是什么</li><li>分类与类的几种搭配加载过程</li><li>类拓展的加载</li><li><code>initalize</code>的分析</li></ul><h3 id=分类的本质><a href=#分类的本质 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>分类的本质</h3><p>为了探索分类的本质，我们需要借助 <code>clang</code> 查看分类在底层究竟是什么</p><p>创建一个类，以及其分类</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@interface</span> <span class=nc>Person</span> : <span class=nc>NSObject</span>
<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>copy</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>assign</span><span class=p>)</span> <span class=n>NSNumber</span> <span class=o>*</span><span class=n>age</span><span class=p>;</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>doFirst</span><span class=p>;</span>
<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>doSecond</span><span class=p>;</span>
<span class=k>@end</span>

<span class=k>@implementation</span> <span class=nc>Person</span>
<span class=p>+</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>load</span> <span class=p>{</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>doFirst</span> <span class=p>{}</span>
<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>doSecond</span> <span class=p>{}</span>
<span class=k>@end</span>

<span class=k>@interface</span> <span class=nc>Person</span> <span class=nl>(Test)</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>copy</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>test_name</span><span class=p>;</span>
<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>assign</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>test_age</span><span class=p>;</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>test_doFirst</span><span class=p>;</span>
<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>test_doSecond</span><span class=p>;</span>
<span class=k>@end</span>

<span class=k>@implementation</span> <span class=nc>Person</span> <span class=nl>(Test)</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>test_doFirst</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%s&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>);</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>test_doSecond</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%s&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>@end</span>
</code></pre></div><p><code>clang</code> 编译，首先可以得出分类是存储在 Mach-O 的 <code>__DATA</code> 段的 <code>__objc_catlist</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=k>struct</span> <span class=nc>_category_t</span> <span class=o>*</span><span class=n>L_OBJC_LABEL_CATEGORY_</span><span class=err>$</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>used</span><span class=p>,</span> <span class=n>section</span> <span class=p>(</span><span class=s>&#34;__DATA, __objc_catlist,regular,no_dead_strip&#34;</span><span class=p>)))</span><span class=o>=</span> <span class=p>{</span>
	<span class=o>&amp;</span><span class=n>_OBJC_</span><span class=err>$</span><span class=n>_CATEGORY_Person_</span><span class=err>$</span><span class=n>_Test</span><span class=p>,</span>
<span class=p>};</span>
</code></pre></div><p>然后是 Person 的分类结构为<code>_category_t</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=k>struct</span> <span class=nc>_category_t</span> <span class=n>_OBJC_</span><span class=err>$</span><span class=n>_CATEGORY_Person_</span><span class=err>$</span><span class=n>_Test</span> <span class=n>__attribute__</span> <span class=p>((</span><span class=n>used</span><span class=p>,</span> <span class=n>section</span> <span class=p>(</span><span class=s>&#34;__DATA,__objc_const&#34;</span><span class=p>)))</span> <span class=o>=</span> 
<span class=p>{</span>
	<span class=s>&#34;Person&#34;</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span> <span class=c1>// &amp;OBJC_CLASS_$_Person,
</span><span class=c1></span>	<span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=nc>_method_list_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>_OBJC_</span><span class=err>$</span><span class=n>_CATEGORY_INSTANCE_METHODS_Person_</span><span class=err>$</span><span class=n>_Test</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=nc>_prop_list_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>_OBJC_</span><span class=err>$</span><span class=n>_PROP_LIST_Person_</span><span class=err>$</span><span class=n>_Test</span><span class=p>,</span>
<span class=p>};</span>
</code></pre></div><p>再来看一下<code>_category_t</code>在底层具体结构为</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>_category_t</span> <span class=p>{</span>
	<span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
	<span class=k>struct</span> <span class=nc>_class_t</span> <span class=o>*</span><span class=n>cls</span><span class=p>;</span>
	<span class=k>const</span> <span class=k>struct</span> <span class=nc>_method_list_t</span> <span class=o>*</span><span class=n>instance_methods</span><span class=p>;</span>
	<span class=k>const</span> <span class=k>struct</span> <span class=nc>_method_list_t</span> <span class=o>*</span><span class=n>class_methods</span><span class=p>;</span>
	<span class=k>const</span> <span class=k>struct</span> <span class=nc>_protocol_list_t</span> <span class=o>*</span><span class=n>protocols</span><span class=p>;</span>
	<span class=k>const</span> <span class=k>struct</span> <span class=nc>_prop_list_t</span> <span class=o>*</span><span class=n>properties</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>而在objc源码中的结构为</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>category_t</span> <span class=p>{</span>
    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
    <span class=n>classref_t</span> <span class=n>cls</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>method_list_t</span> <span class=o>*</span><span class=n>instanceMethods</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>method_list_t</span> <span class=o>*</span><span class=n>classMethods</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>protocol_list_t</span> <span class=o>*</span><span class=n>protocols</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>property_list_t</span> <span class=o>*</span><span class=n>instanceProperties</span><span class=p>;</span>
    <span class=c1>// Fields below this point are not always present on disk.
</span><span class=c1></span>    <span class=k>struct</span> <span class=nc>property_list_t</span> <span class=o>*</span><span class=n>_classProperties</span><span class=p>;</span>

    <span class=n>method_list_t</span> <span class=o>*</span><span class=nf>methodsForMeta</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isMeta</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>isMeta</span><span class=p>)</span> <span class=k>return</span> <span class=n>classMethods</span><span class=p>;</span>
        <span class=k>else</span> <span class=k>return</span> <span class=n>instanceMethods</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>property_list_t</span> <span class=o>*</span><span class=nf>propertiesForMeta</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isMeta</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>header_info</span> <span class=o>*</span><span class=n>hi</span><span class=p>);</span>
    
    <span class=n>protocol_list_t</span> <span class=o>*</span><span class=nf>protocolsForMeta</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isMeta</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>isMeta</span><span class=p>)</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
        <span class=k>else</span> <span class=k>return</span> <span class=n>protocols</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>那么，我们也就得出了分类的本质是一个<code>category_t</code>的结构体，其内部成员有：</p><ul><li><code>name</code>：类的名字，并不是分类的名字</li><li><code>cls</code>：类对象</li><li><code>instanceMethods</code>：分类上存储的实例方法</li><li><code>classMethods</code>：分类上存储的类方法</li><li><code>protocols</code>：分类上所实现的协议</li><li><code>instanceProperties</code>：分类所定义的实例属性，不会实现<code>set、get</code>，因此通常是通过关联对象的方式实现</li><li><code>_classProperties</code>：分类所定义的类属性</li></ul><blockquote><p>分类的方法为什么要分为实例方法和类方法存储呢？</p><p>答：因为类和元类在编译期间，已经确定好了内存布局，即实例方法存储在类中，类方法存储在元类中，而分类是在运行时才加入的，所以需要将方法加载到对应的位置</p></blockquote><h3 id=分类的加载><a href=#分类的加载 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>分类的加载</h3><p>前面我们已经分析过<strong>懒加载类</strong>和<strong>非懒加载类</strong>的加载时机并不一样</p><p>对于分类，同样有<strong>懒加载分类</strong>和<strong>非懒加载分类</strong></p><p>因此，就出现这样四种组合情况：</p><ul><li>懒加载类 + 懒加载分类</li><li>非懒加载类 + 懒加载分类</li><li>懒加载类 + 非懒加载分类</li><li>非懒加载类 + 非懒加载分类</li></ul><p><strong>研究各种组合下的分类加载流程</strong></p><h4 id=懒加载类--懒加载分类><a href=#懒加载类--懒加载分类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>懒加载类 + 懒加载分类</h4><blockquote><p>主类、分类都不实现<code>+load</code></p></blockquote><p><strong>懒加载类的加载时机</strong>是在类第一次发送消息，也就是<code>lookUpImpOrForward -> realizeClassMaybeSwiftAndLeaveLocked -> realizeClassMaybeSwiftMaybeRelock -> realizeClassWithoutSwift</code></p><p>在<code>readClass</code>加入调试代码，并下断点</p><p><img src=https://w-md.imzsy.design/image-20201209150540453.png alt=image-20201209150540453></p><p>终端打印 <code>test_ro</code> 中的 <code>baseMethodList</code>, 可以得到所有的方法，其中也包括分类的</p><p>那么，可以得出结论：<strong>懒加载分类</strong>在<strong>编译时</strong>就已经确定了，当<strong>懒加载类</strong>在慢速消息查找流程中通过<code>realizeClassWithoutSwift</code>加载，会将 Mach-O 数据的数据段读取到内存，其中包括分类数据</p><h4 id=非懒加载类--懒加载分类><a href=#非懒加载类--懒加载分类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>非懒加载类 + 懒加载分类</h4><blockquote><p>主类实现<code>+load</code>，分类不实现</p></blockquote><p><strong>非懒加载</strong>是在应用启动时刻——PreMain阶段加载的，即 <code>map_images -> readClass -> realizeClassWithoutSwift</code>，那么同样只要在<code>readClass</code>中打印 <code>test_ro</code> 的 <code>baseMethodList</code>，打印结果中，同样含有分类的方法</p><p>这也说明了，懒加载分类，不管是懒加载类还是懒加载分类，都在编译时就确定了</p><h4 id=非懒加载类--非懒加载分类><a href=#非懒加载类--非懒加载分类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>非懒加载类 + 非懒加载分类</h4><blockquote><p>主类、分类均实现<code>+load</code></p></blockquote><p>在上一篇文章中提到：在<code>methodizeClass</code>中的<code>attachToClass</code>方法会去加载分类</p><p>通过<code>attachToClass</code>源码实现，<code>attachCategories</code>便是分类的加载</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>attachToClass</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>Class</span> <span class=n>previously</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
    <span class=n>ASSERT</span><span class=p>((</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_CLASS</span><span class=p>)</span> <span class=o>||</span>
           <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_METACLASS</span><span class=p>)</span> <span class=o>||</span>
           <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_CLASS_AND_METACLASS</span><span class=p>));</span>

    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>map</span> <span class=o>=</span> <span class=n>get</span><span class=p>();</span>
    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>map</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>previously</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>map</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>category_list</span> <span class=o>&amp;</span><span class=n>list</span> <span class=o>=</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_CLASS_AND_METACLASS</span><span class=p>)</span> <span class=p>{</span>
            <span class=kt>int</span> <span class=n>otherFlags</span> <span class=o>=</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>ATTACH_CLASS_AND_METACLASS</span><span class=p>;</span>
            <span class=n>attachCategories</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>list</span><span class=p>.</span><span class=n>array</span><span class=p>(),</span> <span class=n>list</span><span class=p>.</span><span class=n>count</span><span class=p>(),</span> <span class=n>otherFlags</span> <span class=o>|</span> <span class=n>ATTACH_CLASS</span><span class=p>);</span>
            <span class=n>attachCategories</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>(),</span> <span class=n>list</span><span class=p>.</span><span class=n>array</span><span class=p>(),</span> <span class=n>list</span><span class=p>.</span><span class=n>count</span><span class=p>(),</span> <span class=n>otherFlags</span> <span class=o>|</span> <span class=n>ATTACH_METACLASS</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>attachCategories</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>list</span><span class=p>.</span><span class=n>array</span><span class=p>(),</span> <span class=n>list</span><span class=p>.</span><span class=n>count</span><span class=p>(),</span> <span class=n>flags</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>map</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>现在的问题：什么时候<code>attachCategories</code>会被调用</p><p>通过全局搜索，发现有两个地方会调用<code>attachCategories</code></p><ul><li><code>attachToClass</code></li><li><code>load_categories_nolock</code></li></ul><p>而根据断点调试，<code>attachToClass</code>不会执行到<code>if</code>流程，即<code>attachCategories</code>不会被调用，除非类加载两次</p><p><code>load_categories_nolock</code>又有两次被调用</p><ul><li><code>loadAllCategories</code></li><li><code>_read_images</code></li></ul><p>同样地，断点调试发现，<code>_read_images</code>并不会进入，而<code>loadAllCategories</code>又是在<code>load_images</code>中被调用的</p><p>因此，分类的加载流程为：<code>load_images -> loadAllCategories -> load_categories_nolock -> attachCategories</code></p><ul><li><strong>非懒加载分类</strong>是在 <code>load_images</code> 时加载的</li><li><strong>懒加载类</strong>是在<code>map_images</code>时加载的</li></ul><h4 id=懒加载类--非懒加载分类><a href=#懒加载类--非懒加载分类 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>懒加载类 + 非懒加载分类</h4><blockquote><p>主类不实现，分类实现<code>+load</code></p></blockquote><p>同样的，在<code>realizeClassWithoutSwift</code>加入调试代码，并下断点</p><p>但是，可以发现的是，在类并没有发送第一次消息时，就已经来到断点了</p><blockquote><p>那么懒加载类为什么会提前被加载，<code>realizeClassWithoutSwift</code>又是在什么时刻被调用的</p></blockquote><p>先在 <code>readClass</code> 加入同样的调试代码，并且此时打印 <code>test_ro</code>，不能得到分类中的方法</p><p>再到<code>attachCategories</code>下断点，断点进入时，通过 <code>bt</code> 打印函数堆栈：<code>load_images -> loadAllCategories -> load_categories_nolock -> attachCategories</code></p><p>那么也就说明了，<strong>懒加载分类</strong>在当类为<strong>懒加载类</strong>时，会迫使主类提前加载，即懒加载类变为非懒加载类</p><h4 id=类和分类加载总结><a href=#类和分类加载总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类和分类加载总结</h4><ul><li>懒加载类 + 懒加载分类<ul><li>类的加载：第一次发送消息</li><li>分类的加载：编译时</li></ul></li><li>非懒加载类 + 懒加载分类<ul><li>类的加载：<code>_read_images</code></li><li>分类的加载：编译时</li></ul></li><li>非懒加载类 + 非懒加载分类<ul><li>类的加载：<code>_read_images</code></li><li>分类的加载：<code>load_image</code></li></ul></li><li>懒加载类 + 非懒加载分类<ul><li>类的加载：在<code>_read_images</code>中完成类的重映射操作，而在<code>load_image</code>中实现数据的加载</li><li>分类的加载：<code>load_image</code></li></ul></li></ul><h4 id=类和分类的同名方法调用><a href=#类和分类的同名方法调用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类和分类的同名方法调用</h4><blockquote><p>当类和分类中，有同名的方法时，那么会调用哪个方法</p></blockquote><p>在上一篇文章中，提到过<code>prepareMethodLists</code>中的<code>fixupMethodList</code>会对方法进行排序</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> 
<span class=nf>prepareMethodLists</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>method_list_t</span> <span class=o>**</span><span class=n>addedLists</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addedCount</span><span class=p>,</span>
                   <span class=kt>bool</span> <span class=n>baseMethods</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>methodsFromBundle</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>addedCount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// There exist RR/AWZ/Core special cases for some class&#39;s base methods.
</span><span class=c1></span>    <span class=c1>// But this code should never need to scan base methods for RR/AWZ/Core:
</span><span class=c1></span>    <span class=c1>// default RR/AWZ/Core cannot be set before setInitialized().
</span><span class=c1></span>    <span class=c1>// Therefore we need not handle any special cases here.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>baseMethods</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>hasCustomAWZ</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>hasCustomRR</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>hasCustomCore</span><span class=p>());</span>
    <span class=p>}</span>

    <span class=c1>// Add method lists to array.
</span><span class=c1></span>    <span class=c1>// Reallocate un-fixed method lists.
</span><span class=c1></span>    <span class=c1>// The new methods are PREPENDED to the method list array.
</span><span class=c1></span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>addedCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>method_list_t</span> <span class=o>*</span><span class=n>mlist</span> <span class=o>=</span> <span class=n>addedLists</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>mlist</span><span class=p>);</span>

        <span class=c1>// Fixup selectors if necessary
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isFixedUp</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>fixupMethodList</span><span class=p>(</span><span class=n>mlist</span><span class=p>,</span> <span class=n>methodsFromBundle</span><span class=p>,</span> <span class=nb>true</span><span class=cm>/*sort*/</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// If the class is initialized, then scan for method implementations
</span><span class=c1></span>    <span class=c1>// tracked by the class&#39;s flags. If it&#39;s not initialized yet,
</span><span class=c1></span>    <span class=c1>// then objc_class::setInitialized() will take care of it.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isInitialized</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>objc</span><span class=o>::</span><span class=n>AWZScanner</span><span class=o>::</span><span class=n>scanAddedMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>addedLists</span><span class=p>,</span> <span class=n>addedCount</span><span class=p>);</span>
        <span class=n>objc</span><span class=o>::</span><span class=n>RRScanner</span><span class=o>::</span><span class=n>scanAddedMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>addedLists</span><span class=p>,</span> <span class=n>addedCount</span><span class=p>);</span>
        <span class=n>objc</span><span class=o>::</span><span class=n>CoreScanner</span><span class=o>::</span><span class=n>scanAddedMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>addedLists</span><span class=p>,</span> <span class=n>addedCount</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>void</span> 
<span class=nf>fixupMethodList</span><span class=p>(</span><span class=n>method_list_t</span> <span class=o>*</span><span class=n>mlist</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>bundleCopy</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>sort</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isFixedUp</span><span class=p>());</span>

    <span class=c1>// fixme lock less in attachMethodLists ?
</span><span class=c1></span>    <span class=c1>// dyld3 may have already uniqued, but not sorted, the list
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>isUniqued</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>mutex_locker_t</span> <span class=n>lock</span><span class=p>(</span><span class=n>selLock</span><span class=p>);</span>
    
        <span class=c1>// Unique selectors in list.
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>meth</span> <span class=p>:</span> <span class=o>*</span><span class=n>mlist</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=n>sel_cname</span><span class=p>(</span><span class=n>meth</span><span class=p>.</span><span class=n>name</span><span class=p>);</span>
            <span class=n>meth</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>sel_registerNameNoLock</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>bundleCopy</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Sort by selector address.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sort</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>method_t</span><span class=o>::</span><span class=n>SortBySELAddress</span> <span class=n>sorter</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>stable_sort</span><span class=p>(</span><span class=n>mlist</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>(),</span> <span class=n>mlist</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>(),</span> <span class=n>sorter</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=c1>// Mark method list as uniqued and sorted
</span><span class=c1></span>    <span class=n>mlist</span><span class=o>-&gt;</span><span class=n>setFixedUp</span><span class=p>();</span>
<span class=p>}</span>

<span class=k>struct</span> <span class=nc>method_t</span> <span class=p>{</span>
    <span class=n>SEL</span> <span class=n>name</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>types</span><span class=p>;</span>
    <span class=n>MethodListIMP</span> <span class=n>imp</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>SortBySELAddress</span> <span class=o>:</span>
        <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>binary_function</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>method_t</span><span class=o>&amp;</span><span class=p>,</span>
                                    <span class=k>const</span> <span class=n>method_t</span><span class=o>&amp;</span><span class=p>,</span> <span class=kt>bool</span><span class=o>&gt;</span>
    <span class=p>{</span>
        <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()</span> <span class=p>(</span><span class=k>const</span> <span class=n>method_t</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span>
                         <span class=k>const</span> <span class=n>method_t</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
        <span class=p>{</span> <span class=k>return</span> <span class=n>lhs</span><span class=p>.</span><span class=n>name</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>name</span><span class=p>;</span> <span class=p>}</span>
    <span class=p>};</span>
<span class=p>};</span>
</code></pre></div><p>根据排序规则可得：当方法同名时，会根据方法的 <code>name</code> 进行排序</p><p>再来分析<code>attachCategories</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span>
<span class=nf>attachCategories</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=k>const</span> <span class=n>locstamped_category_t</span> <span class=o>*</span><span class=n>cats_list</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>cats_count</span><span class=p>,</span>
                 <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>slowpath</span><span class=p>(</span><span class=n>PrintReplacedMethods</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>printReplacements</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>cats_list</span><span class=p>,</span> <span class=n>cats_count</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>slowpath</span><span class=p>(</span><span class=n>PrintConnecting</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;CLASS: attaching %d categories to%s class &#39;%s&#39;%s&#34;</span><span class=p>,</span>
                     <span class=n>cats_count</span><span class=p>,</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_EXISTING</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34; existing&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span><span class=p>,</span>
                     <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>(),</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_METACLASS</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34; (meta)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/*
</span><span class=cm>     * Only a few classes have more than 64 categories during launch.
</span><span class=cm>     * This uses a little stack, and avoids malloc.
</span><span class=cm>     *
</span><span class=cm>     * Categories must be added in the proper order, which is back
</span><span class=cm>     * to front. To do that with the chunking, we iterate cats_list
</span><span class=cm>     * from front to back, build up the local buffers backwards,
</span><span class=cm>     * and call attachLists on the chunks. attachLists prepends the
</span><span class=cm>     * lists, so the final result is in the expected order.
</span><span class=cm>     */</span>
    <span class=k>constexpr</span> <span class=kt>uint32_t</span> <span class=n>ATTACH_BUFSIZ</span> <span class=o>=</span> <span class=mi>64</span><span class=p>;</span>
    <span class=n>method_list_t</span>   <span class=o>*</span><span class=n>mlists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span><span class=p>];</span>
    <span class=n>property_list_t</span> <span class=o>*</span><span class=n>proplists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span><span class=p>];</span>
    <span class=n>protocol_list_t</span> <span class=o>*</span><span class=n>protolists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span><span class=p>];</span>

    <span class=kt>uint32_t</span> <span class=n>mcount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>propcount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>protocount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>fromBundle</span> <span class=o>=</span> <span class=n>NO</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>isMeta</span> <span class=o>=</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_METACLASS</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>rwe</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>extAllocIfNeeded</span><span class=p>();</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>cats_count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>auto</span><span class=o>&amp;</span> <span class=n>entry</span> <span class=o>=</span> <span class=n>cats_list</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>

        <span class=n>method_list_t</span> <span class=o>*</span><span class=n>mlist</span> <span class=o>=</span> <span class=n>entry</span><span class=p>.</span><span class=n>cat</span><span class=o>-&gt;</span><span class=n>methodsForMeta</span><span class=p>(</span><span class=n>isMeta</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>mlist</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>mcount</span> <span class=o>==</span> <span class=n>ATTACH_BUFSIZ</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>prepareMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>mlists</span><span class=p>,</span> <span class=n>mcount</span><span class=p>,</span> <span class=n>NO</span><span class=p>,</span> <span class=n>fromBundle</span><span class=p>);</span>
                <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>methods</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>mlists</span><span class=p>,</span> <span class=n>mcount</span><span class=p>);</span>
                <span class=n>mcount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>mlists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=o>++</span><span class=n>mcount</span><span class=p>]</span> <span class=o>=</span> <span class=n>mlist</span><span class=p>;</span>
            <span class=n>fromBundle</span> <span class=o>|=</span> <span class=n>entry</span><span class=p>.</span><span class=n>hi</span><span class=o>-&gt;</span><span class=n>isBundle</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=n>property_list_t</span> <span class=o>*</span><span class=n>proplist</span> <span class=o>=</span>
            <span class=n>entry</span><span class=p>.</span><span class=n>cat</span><span class=o>-&gt;</span><span class=n>propertiesForMeta</span><span class=p>(</span><span class=n>isMeta</span><span class=p>,</span> <span class=n>entry</span><span class=p>.</span><span class=n>hi</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>proplist</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>propcount</span> <span class=o>==</span> <span class=n>ATTACH_BUFSIZ</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>properties</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>proplists</span><span class=p>,</span> <span class=n>propcount</span><span class=p>);</span>
                <span class=n>propcount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>proplists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=o>++</span><span class=n>propcount</span><span class=p>]</span> <span class=o>=</span> <span class=n>proplist</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>protocol_list_t</span> <span class=o>*</span><span class=n>protolist</span> <span class=o>=</span> <span class=n>entry</span><span class=p>.</span><span class=n>cat</span><span class=o>-&gt;</span><span class=n>protocolsForMeta</span><span class=p>(</span><span class=n>isMeta</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>protolist</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>protocount</span> <span class=o>==</span> <span class=n>ATTACH_BUFSIZ</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>protocols</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>protolists</span><span class=p>,</span> <span class=n>protocount</span><span class=p>);</span>
                <span class=n>protocount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>protolists</span><span class=p>[</span><span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=o>++</span><span class=n>protocount</span><span class=p>]</span> <span class=o>=</span> <span class=n>protolist</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>mcount</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>prepareMethodLists</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>mlists</span> <span class=o>+</span> <span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=n>mcount</span><span class=p>,</span> <span class=n>mcount</span><span class=p>,</span> <span class=n>NO</span><span class=p>,</span> <span class=n>fromBundle</span><span class=p>);</span>
        <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>methods</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>mlists</span> <span class=o>+</span> <span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=n>mcount</span><span class=p>,</span> <span class=n>mcount</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ATTACH_EXISTING</span><span class=p>)</span> <span class=n>flushCaches</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>properties</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>proplists</span> <span class=o>+</span> <span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=n>propcount</span><span class=p>,</span> <span class=n>propcount</span><span class=p>);</span>

    <span class=n>rwe</span><span class=o>-&gt;</span><span class=n>protocols</span><span class=p>.</span><span class=n>attachLists</span><span class=p>(</span><span class=n>protolists</span> <span class=o>+</span> <span class=n>ATTACH_BUFSIZ</span> <span class=o>-</span> <span class=n>protocount</span><span class=p>,</span> <span class=n>protocount</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>没错，分类添加方法、属性、协议也是通过<code>attachLists</code>，而其内部是通过<code>memmove、memcpy</code></p><p>所以得出：</p><ul><li><p>分类并不会覆盖主类已有的方法</p></li><li><p>分类的方法被放到新方法列表的前面，而类的方法被放倒了新列表的后面</p><p>当运行时在进行方法查找时，会优先找到分类的方法，返回<code>imp</code></p></li></ul><p><strong>分类与主类同名方法调用顺序</strong></p><ul><li>类和分类方法同名时，必定响应分类方法（不管类和分类是否实现<code>+load</code>）</li><li>类和多个分类方法同名时<ul><li>如果分类没有实现或全都<code>+load</code>方法，响应的是<strong>编译器</strong>最后一个分类，即<code>Compile Sources</code>中的最后一个分类</li><li>如果分类中其中一个实现<code>+load</code>，那么响应的是编译器中最后的一个非懒加载分类</li></ul></li></ul><h3 id=load_images><a href=#load_images class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>load_images</h3><p><code>load_image</code>源码</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span>
<span class=nf>load_images</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span> <span class=n>__unused</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>mach_header</span> <span class=o>*</span><span class=n>mh</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>didInitialAttachCategories</span> <span class=o>&amp;&amp;</span> <span class=n>didCallDyldNotifyRegister</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>didInitialAttachCategories</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=n>loadAllCategories</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=c1>// Return without taking locks if there are no +load methods here.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hasLoadMethods</span><span class=p>((</span><span class=k>const</span> <span class=n>headerType</span> <span class=o>*</span><span class=p>)</span><span class=n>mh</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=n>recursive_mutex_locker_t</span> <span class=n>lock</span><span class=p>(</span><span class=n>loadMethodLock</span><span class=p>);</span>

    <span class=c1>// Discover load methods
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>mutex_locker_t</span> <span class=n>lock2</span><span class=p>(</span><span class=n>runtimeLock</span><span class=p>);</span>
        <span class=n>prepare_load_methods</span><span class=p>((</span><span class=k>const</span> <span class=n>headerType</span> <span class=o>*</span><span class=p>)</span><span class=n>mh</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Call +load methods (without runtimeLock - re-entrant)
</span><span class=c1></span>    <span class=n>call_load_methods</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p><code>loadAllCategories</code>之前分析了，主要是负责加载分类的</p><p>除此之外，还有两个关键的函数：</p><ul><li><code>prepare_load_methods</code>：发现 load 方法</li><li><code>call_load_methods</code>：调用 load 方法</li></ul><h4 id=prepare_load_methods><a href=#prepare_load_methods class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>prepare_load_methods</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>prepare_load_methods</span><span class=p>(</span><span class=k>const</span> <span class=n>headerType</span> <span class=o>*</span><span class=n>mhdr</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>

    <span class=n>runtimeLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>

    <span class=n>classref_t</span> <span class=k>const</span> <span class=o>*</span><span class=n>classlist</span> <span class=o>=</span> 
        <span class=n>_getObjc2NonlazyClassList</span><span class=p>(</span><span class=n>mhdr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>schedule_class_load</span><span class=p>(</span><span class=n>remapClass</span><span class=p>(</span><span class=n>classlist</span><span class=p>[</span><span class=n>i</span><span class=p>]));</span>
    <span class=p>}</span>

    <span class=n>category_t</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span><span class=n>categorylist</span> <span class=o>=</span> <span class=n>_getObjc2NonlazyCategoryList</span><span class=p>(</span><span class=n>mhdr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>category_t</span> <span class=o>*</span><span class=n>cat</span> <span class=o>=</span> <span class=n>categorylist</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=n>remapClass</span><span class=p>(</span><span class=n>cat</span><span class=o>-&gt;</span><span class=n>cls</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>  <span class=c1>// category for ignored weak-linked class
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isSwiftStable</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>_objc_fatal</span><span class=p>(</span><span class=s>&#34;Swift class extensions and categories on Swift &#34;</span>
                        <span class=s>&#34;classes are not allowed to have +load methods&#34;</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>realizeClassWithoutSwift</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>
        <span class=n>add_category_to_loadable_list</span><span class=p>(</span><span class=n>cat</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ul><li><p>通过<code>_getObjc2NonlazyClassList</code>从 Mach-O 中读取所有的非懒加载类遍历调用<code>schedule_class_load</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>schedule_class_load</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>  <span class=c1>// _read_images should realize
</span><span class=c1></span>  
    <span class=k>if</span> <span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>RW_LOADED</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
  
    <span class=c1>// Ensure superclass-first ordering
</span><span class=c1></span>    <span class=n>schedule_class_load</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>superclass</span><span class=p>);</span>
  
    <span class=n>add_class_to_loadable_list</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=n>cls</span><span class=o>-&gt;</span><span class=n>setInfo</span><span class=p>(</span><span class=n>RW_LOADED</span><span class=p>);</span> 
<span class=p>}</span>
  
<span class=c1>// 保存 +load 方法
</span><span class=c1></span><span class=kt>void</span> <span class=nf>add_class_to_loadable_list</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>IMP</span> <span class=n>method</span><span class=p>;</span>
  
    <span class=n>loadMethodLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>
  
    <span class=n>method</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>getLoadMethod</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>method</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>  <span class=c1>// Don&#39;t bother if cls has no +load method
</span><span class=c1></span>      
    <span class=k>if</span> <span class=p>(</span><span class=n>PrintLoading</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;LOAD: class &#39;%s&#39; scheduled for +load&#34;</span><span class=p>,</span> 
                     <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
    <span class=p>}</span>
      
    <span class=k>if</span> <span class=p>(</span><span class=n>loadable_classes_used</span> <span class=o>==</span> <span class=n>loadable_classes_allocated</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>loadable_classes_allocated</span> <span class=o>=</span> <span class=n>loadable_classes_allocated</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>16</span><span class=p>;</span>
        <span class=n>loadable_classes</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>loadable_class</span> <span class=o>*</span><span class=p>)</span>
            <span class=n>realloc</span><span class=p>(</span><span class=n>loadable_classes</span><span class=p>,</span>
                              <span class=n>loadable_classes_allocated</span> <span class=o>*</span>
                              <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>loadable_class</span><span class=p>));</span>
    <span class=p>}</span>
      
    <span class=n>loadable_classes</span><span class=p>[</span><span class=n>loadable_classes_used</span><span class=p>].</span><span class=n>cls</span> <span class=o>=</span> <span class=n>cls</span><span class=p>;</span>
    <span class=n>loadable_classes</span><span class=p>[</span><span class=n>loadable_classes_used</span><span class=p>].</span><span class=n>method</span> <span class=o>=</span> <span class=n>method</span><span class=p>;</span>
    <span class=n>loadable_classes_used</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>内部递归调用<code>schedule_class_load</code>，根据类的继承链递归去发现父类的<code>+load</code>方法，以确保父类的<code>+load</code>方法优先加载</p><p>再调用<code>add_class_to_loadable_list</code>把类的<code>+load</code>方法存在<code>loadable_classes</code></p></li><li><p>通过<code>_getObjc2NonlazyCategoryList</code>从 Mach-O 中读取所有的非懒加载分类遍历</p><ul><li>通过<code>realizeClassWithoutSwift</code>来防止类没有初始化（若已经初始化了则不影响）</li><li>调用<code>add_category_to_loadable_list</code>加载分类中的<code>+load</code>方法到<code>loadable_categories</code></li></ul></li></ul><h4 id=call_load_methods><a href=#call_load_methods class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>call_load_methods</h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>call_load_methods</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=kt>bool</span> <span class=n>loading</span> <span class=o>=</span> <span class=n>NO</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>more_categories</span><span class=p>;</span>

    <span class=n>loadMethodLock</span><span class=p>.</span><span class=n>assertLocked</span><span class=p>();</span>

    <span class=c1>// Re-entrant calls do nothing; the outermost call will finish the job.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>loading</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
    <span class=n>loading</span> <span class=o>=</span> <span class=n>YES</span><span class=p>;</span>

    <span class=kt>void</span> <span class=o>*</span><span class=n>pool</span> <span class=o>=</span> <span class=n>objc_autoreleasePoolPush</span><span class=p>();</span>

    <span class=k>do</span> <span class=p>{</span>
        <span class=c1>// 1. Repeatedly call class +loads until there aren&#39;t any more
</span><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>loadable_classes_used</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>call_class_loads</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=c1>// 2. Call category +loads ONCE
</span><span class=c1></span>        <span class=n>more_categories</span> <span class=o>=</span> <span class=n>call_category_loads</span><span class=p>();</span>

        <span class=c1>// 3. Run more +loads if there are classes OR more untried categories
</span><span class=c1></span>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>loadable_classes_used</span> <span class=o>&gt;</span> <span class=mi>0</span>  <span class=o>||</span>  <span class=n>more_categories</span><span class=p>);</span>

    <span class=n>objc_autoreleasePoolPop</span><span class=p>(</span><span class=n>pool</span><span class=p>);</span>

    <span class=n>loading</span> <span class=o>=</span> <span class=n>NO</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// 调用类的+load
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>call_class_loads</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    
    <span class=c1>// Detach current loadable list.
</span><span class=c1></span>    <span class=k>struct</span> <span class=nc>loadable_class</span> <span class=o>*</span><span class=n>classes</span> <span class=o>=</span> <span class=n>loadable_classes</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>used</span> <span class=o>=</span> <span class=n>loadable_classes_used</span><span class=p>;</span>
    <span class=n>loadable_classes</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
    <span class=n>loadable_classes_allocated</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>loadable_classes_used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    
    <span class=c1>// Call all +loads for the detached list.
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>used</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Class</span> <span class=n>cls</span> <span class=o>=</span> <span class=n>classes</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cls</span><span class=p>;</span>
        <span class=n>load_method_t</span> <span class=n>load_method</span> <span class=o>=</span> <span class=p>(</span><span class=n>load_method_t</span><span class=p>)</span><span class=n>classes</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>method</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span> 

        <span class=k>if</span> <span class=p>(</span><span class=n>PrintLoading</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;LOAD: +[%s load]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
        <span class=p>}</span>
        <span class=p>(</span><span class=o>*</span><span class=n>load_method</span><span class=p>)(</span><span class=n>cls</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=n>load</span><span class=p>));</span>
    <span class=p>}</span>
    
    <span class=c1>// Destroy the detached list.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>classes</span><span class=p>)</span> <span class=n>free</span><span class=p>(</span><span class=n>classes</span><span class=p>);</span>
<span class=p>}</span>

<span class=c1>// 调用分类的+load
</span><span class=c1></span><span class=k>static</span> <span class=kt>bool</span> <span class=nf>call_category_loads</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>shift</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>new_categories_added</span> <span class=o>=</span> <span class=n>NO</span><span class=p>;</span>
    
    <span class=c1>// Detach current loadable list.
</span><span class=c1></span>    <span class=k>struct</span> <span class=nc>loadable_category</span> <span class=o>*</span><span class=n>cats</span> <span class=o>=</span> <span class=n>loadable_categories</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>used</span> <span class=o>=</span> <span class=n>loadable_categories_used</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>allocated</span> <span class=o>=</span> <span class=n>loadable_categories_allocated</span><span class=p>;</span>
    <span class=n>loadable_categories</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
    <span class=n>loadable_categories_allocated</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>loadable_categories_used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=c1>// Call all +loads for the detached list.
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>used</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Category</span> <span class=n>cat</span> <span class=o>=</span> <span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cat</span><span class=p>;</span>
        <span class=n>load_method_t</span> <span class=n>load_method</span> <span class=o>=</span> <span class=p>(</span><span class=n>load_method_t</span><span class=p>)</span><span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>method</span><span class=p>;</span>
        <span class=n>Class</span> <span class=n>cls</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cat</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

        <span class=n>cls</span> <span class=o>=</span> <span class=n>_category_getClass</span><span class=p>(</span><span class=n>cat</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cls</span>  <span class=o>&amp;&amp;</span>  <span class=n>cls</span><span class=o>-&gt;</span><span class=n>isLoadable</span><span class=p>())</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>PrintLoading</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;LOAD: +[%s(%s) load]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> 
                             <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>(),</span> 
                             <span class=n>_category_getName</span><span class=p>(</span><span class=n>cat</span><span class=p>));</span>
            <span class=p>}</span>
            <span class=p>(</span><span class=o>*</span><span class=n>load_method</span><span class=p>)(</span><span class=n>cls</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=n>load</span><span class=p>));</span>
            <span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cat</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Compact detached list (order-preserving)
</span><span class=c1></span>    <span class=n>shift</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>used</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cat</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=n>shift</span><span class=p>]</span> <span class=o>=</span> <span class=n>cats</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>shift</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>used</span> <span class=o>-=</span> <span class=n>shift</span><span class=p>;</span>

    <span class=c1>// Copy any new +load candidates from the new list to the detached list.
</span><span class=c1></span>    <span class=n>new_categories_added</span> <span class=o>=</span> <span class=p>(</span><span class=n>loadable_categories_used</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loadable_categories_used</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>used</span> <span class=o>==</span> <span class=n>allocated</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>allocated</span> <span class=o>=</span> <span class=n>allocated</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>16</span><span class=p>;</span>
            <span class=n>cats</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>loadable_category</span> <span class=o>*</span><span class=p>)</span>
                <span class=n>realloc</span><span class=p>(</span><span class=n>cats</span><span class=p>,</span> <span class=n>allocated</span> <span class=o>*</span>
                                  <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>loadable_category</span><span class=p>));</span>
        <span class=p>}</span>
        <span class=n>cats</span><span class=p>[</span><span class=n>used</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>loadable_categories</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=c1>// Destroy the new list.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>loadable_categories</span><span class=p>)</span> <span class=n>free</span><span class=p>(</span><span class=n>loadable_categories</span><span class=p>);</span>

    <span class=c1>// Reattach the (now augmented) detached list. 
</span><span class=c1></span>    <span class=c1>// But if there&#39;s nothing left to load, destroy the list.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>used</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>loadable_categories</span> <span class=o>=</span> <span class=n>cats</span><span class=p>;</span>
        <span class=n>loadable_categories_used</span> <span class=o>=</span> <span class=n>used</span><span class=p>;</span>
        <span class=n>loadable_categories_allocated</span> <span class=o>=</span> <span class=n>allocated</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cats</span><span class=p>)</span> <span class=n>free</span><span class=p>(</span><span class=n>cats</span><span class=p>);</span>
        <span class=n>loadable_categories</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span>
        <span class=n>loadable_categories_used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>loadable_categories_allocated</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>PrintLoading</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>loadable_categories_used</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;LOAD: %d categories still waiting for +load</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
                         <span class=n>loadable_categories_used</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>new_categories_added</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><code>do-while</code>循环中主要做 3 个操作：</p><ul><li>循环调用<code>类的+load</code>方法，直到调用完</li><li>调用一次<code>分类中的+load</code></li><li>如果有类或更多未尝试的分类，则运行更多的<code>+load</code></li></ul><blockquote><p>使用<strong>自动释放池</strong>管理内存，关于自动释放池，在后续篇章会详细展开</p></blockquote><h2 id=initalize分析><a href=#initalize分析 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>initalize分析</h2><p>关于<code>initalize</code>的苹果官方文档定义为：Initializes the class before it receives its first message.</p><blockquote><p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?language=objc" target=_blank rel=noopener><code>initalize</code>定义</a></p></blockquote><p>即在接收到第一个消息之前初始化该类</p><p>那么，我们在 objc源码中 <code>lookUpImpOrForward</code>查看</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>IMP</span> <span class=nf>lookUpImpOrForward</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>SEL</span> <span class=n>sel</span><span class=p>,</span> <span class=n>id</span> <span class=n>inst</span><span class=p>,</span> 
                       <span class=kt>bool</span> <span class=n>initialize</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>cache</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>resolver</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>initialize</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isInitialized</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>cls</span> <span class=o>=</span> <span class=n>initializeAndLeaveLocked</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>inst</span><span class=p>,</span> <span class=n>runtimeLock</span><span class=p>);</span>
        <span class=p>...</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>Class</span> <span class=nf>initializeAndLeaveLocked</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>id</span> <span class=n>obj</span><span class=p>,</span> <span class=n>mutex_t</span><span class=o>&amp;</span> <span class=n>lock</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>initializeAndMaybeRelock</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> <span class=n>lock</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>Class</span> <span class=nf>initializeAndMaybeRelock</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>id</span> <span class=n>inst</span><span class=p>,</span>
                                      <span class=n>mutex_t</span><span class=o>&amp;</span> <span class=n>lock</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>leaveLocked</span><span class=p>)</span>
<span class=p>{</span>
    <span class=err>···</span>
    <span class=n>initializeNonMetaClass</span><span class=p>(</span><span class=n>nonmeta</span><span class=p>);</span>
    <span class=err>···</span>
<span class=p>}</span>
</code></pre></div><p><code>lookUpImpOrForward -> initializeAndLeaveLocked -> initializeAndMaybeRelock -> initializeNonMetaClass</code></p><p>在<code>initializeNonMetaClass</code>递归调用父类<code>initialize</code>，然后调用<code>callInitialize</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>initializeNonMetaClass</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>
    <span class=n>supercls</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>superclass</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>supercls</span>  <span class=o>&amp;&amp;</span>  <span class=o>!</span><span class=n>supercls</span><span class=o>-&gt;</span><span class=n>isInitialized</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>initializeNonMetaClass</span><span class=p>(</span><span class=n>supercls</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=p>...</span>
    <span class=p>{</span>
            <span class=n>callInitialize</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>PrintInitializing</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>_objc_inform</span><span class=p>(</span><span class=s>&#34;INITIALIZE: thread %p: finished +[%s initialize]&#34;</span><span class=p>,</span>
                             <span class=n>pthread_self</span><span class=p>(),</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>nameForLogging</span><span class=p>());</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p><code>callInitialize</code>是一个普通的消息发送</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=kt>void</span> <span class=nf>callInitialize</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>((</span><span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>Class</span><span class=p>,</span> <span class=n>SEL</span><span class=p>))</span><span class=n>objc_msgSend</span><span class=p>)(</span><span class=n>cls</span><span class=p>,</span> <span class=n>SEL_initialize</span><span class=p>);</span>
    <span class=k>asm</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>关于<code>initalize</code>的结论：</p><ul><li><code>initialize</code>在类或者其子类的第一个方法被调用前（发送消息前）调用</li><li>只在类中添加<code>initialize</code>但不使用的情况下，是不会调用<code>initialize</code></li><li>父类的<code>initialize</code>方法会比子类先执行</li><li>当子类未实现<code>initialize</code>方法时，会调用父类<code>initialize</code>方法；子类实现<code>initialize</code>方法时，会覆盖父类<code>initialize</code>方法</li><li>当有多个分类都实现了<code>initialize</code>方法，会覆盖类中的方法，只执行一个(会执行最后被加载到内存中的分类的方法)</li></ul><h3 id=类拓展><a href=#类拓展 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类拓展</h3><p>类拓展 <code>extension</code> 又称为<code>匿名的分类</code>，同样可以为类增加属性和方法</p><p>在开始的类中，加入类拓展</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@interface</span> <span class=nc>Person</span> <span class=p>()</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>copy</span><span class=p>)</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>ex_name</span><span class=p>;</span>
<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>assign</span><span class=p>)</span> <span class=n>NSNumber</span> <span class=o>*</span><span class=n>ex_age</span><span class=p>;</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>ex_doFirst</span><span class=p>;</span>
<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>ex_doSecond</span><span class=p>;</span>
<span class=k>@end</span>
</code></pre></div><p><code>clang</code> 编译</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=k>struct</span> <span class=err>/*</span><span class=nc>_ivar_list_t</span><span class=err>*/</span> <span class=p>{</span>
	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>entsize</span><span class=p>;</span>  <span class=c1>// sizeof(struct _prop_t)
</span><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
	<span class=k>struct</span> <span class=nc>_ivar_t</span> <span class=n>ivar_list</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
<span class=p>}</span> <span class=n>_OBJC_</span><span class=err>$</span><span class=n>_INSTANCE_VARIABLES_Person</span> <span class=n>__attribute__</span> <span class=p>((</span><span class=n>used</span><span class=p>,</span> <span class=n>section</span> <span class=p>(</span><span class=s>&#34;__DATA,__objc_const&#34;</span><span class=p>)))</span> <span class=o>=</span> <span class=p>{</span>
	<span class=k>sizeof</span><span class=p>(</span><span class=n>_ivar_t</span><span class=p>),</span>
	<span class=mi>4</span><span class=p>,</span>
	<span class=p>{{(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>OBJC_IVAR_</span><span class=err>$</span><span class=n>_Person</span><span class=err>$</span><span class=n>_name</span><span class=p>,</span> <span class=s>&#34;_name&#34;</span><span class=p>,</span> <span class=s>&#34;@</span><span class=se>\&#34;</span><span class=s>NSString</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>},</span>
	 <span class=p>{(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>OBJC_IVAR_</span><span class=err>$</span><span class=n>_Person</span><span class=err>$</span><span class=n>_age</span><span class=p>,</span> <span class=s>&#34;_age&#34;</span><span class=p>,</span> <span class=s>&#34;@</span><span class=se>\&#34;</span><span class=s>NSNumber</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>},</span>
	 <span class=p>{(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>OBJC_IVAR_</span><span class=err>$</span><span class=n>_Person</span><span class=err>$</span><span class=n>_ex_name</span><span class=p>,</span> <span class=s>&#34;_ex_name&#34;</span><span class=p>,</span> <span class=s>&#34;@</span><span class=se>\&#34;</span><span class=s>NSString</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>},</span>
	 <span class=p>{(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>OBJC_IVAR_</span><span class=err>$</span><span class=n>_Person</span><span class=err>$</span><span class=n>_ex_age</span><span class=p>,</span> <span class=s>&#34;_ex_age&#34;</span><span class=p>,</span> <span class=s>&#34;@</span><span class=se>\&#34;</span><span class=s>NSNumber</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>}}</span>
<span class=p>};</span>

<span class=k>static</span> <span class=k>struct</span> <span class=err>/*</span><span class=nc>_method_list_t</span><span class=err>*/</span> <span class=p>{</span>
	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>entsize</span><span class=p>;</span>  <span class=c1>// sizeof(struct _objc_method)
</span><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>method_count</span><span class=p>;</span>
	<span class=k>struct</span> <span class=nc>_objc_method</span> <span class=n>method_list</span><span class=p>[</span><span class=mi>19</span><span class=p>];</span>
<span class=p>}</span> <span class=n>_OBJC_</span><span class=err>$</span><span class=n>_INSTANCE_METHODS_Person</span> <span class=n>__attribute__</span> <span class=p>((</span><span class=n>used</span><span class=p>,</span> <span class=n>section</span> <span class=p>(</span><span class=s>&#34;__DATA,__objc_const&#34;</span><span class=p>)))</span> <span class=o>=</span> <span class=p>{</span>
	<span class=k>sizeof</span><span class=p>(</span><span class=n>_objc_method</span><span class=p>),</span>
	<span class=mi>19</span><span class=p>,</span>
	<span class=p>{{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;doFirst&#34;</span><span class=p>,</span> <span class=s>&#34;v16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_doFirst</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;doSecond&#34;</span><span class=p>,</span> <span class=s>&#34;v16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_doSecond</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;ex_doFirst&#34;</span><span class=p>,</span> <span class=s>&#34;v16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_ex_doFirst</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;name&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_name</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setName:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setName_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;age&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_age</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setAge:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setAge_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;ex_name&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_ex_name</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setEx_name:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setEx_name_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;ex_age&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_ex_age</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setEx_age:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setEx_age_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;name&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_name</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setName:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setName_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;age&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_age</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setAge:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setAge_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;ex_name&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_ex_name</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setEx_name:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setEx_name_</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;ex_age&#34;</span><span class=p>,</span> <span class=s>&#34;@16@0:8&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_ex_age</span><span class=p>},</span>
	<span class=p>{(</span><span class=k>struct</span> <span class=nc>objc_selector</span> <span class=o>*</span><span class=p>)</span><span class=s>&#34;setEx_age:&#34;</span><span class=p>,</span> <span class=s>&#34;v24@0:8@16&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>_I_Person_setEx_age_</span><span class=p>}}</span>
<span class=p>};</span>
</code></pre></div><p>可以看到，类拓展中的属性已经被加入到 <code>ivar_list_t</code> 中，方法<code>ex_doFirst</code>被加入到了 <code>method_list_t</code>，<code>ex_doSecond</code>没有被加入是因为没有在主类中实现</p><p>因此</p><ul><li><p>类拓展在编译时会作为类的一部分进行编译</p></li><li><p>类拓展只是声明，依赖于当前主类，方法需要在主类 <code>.m</code> 文件中实现</p></li></ul><h3 id=类拓展与分类的区别><a href=#类拓展与分类的区别 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>类拓展与分类的区别</h3><p><strong>分类</strong></p><ul><li>为某个类添加方法、协议、属性（一般使用关联对象），通常用来为系统的类拓展方法或者把复杂类根据功能拆分到不同的文件里</li></ul><p><strong>类拓展</strong></p><ul><li>为某个类添加原来没有的成员变量、属性、方法（方法只是声明，需要实现），通常用来扩展私有属性，或者把<code>.h</code>的<strong>只读属性</strong>重写<strong>可读写</strong>的</li></ul><p><strong>区别</strong></p><ul><li>分类是在运行时，才把分类的信息合并到类信息中，而类拓展是在编译时</li><li>分类声明的属性，只会生成 <code>setter/getter</code> 方法的声明，不会自动生成<strong>成员变量</strong>和<code>setter/getter</code> 方法的实现，而类拓展可以</li><li>分类不可以为类添加实例变量，而类拓展可以</li><li>分类可以为类添加方法的实现，而类拓展只能声明方法，而不能实现</li></ul><p><strong>分类的局限点</strong></p><ul><li>无法为类添加实例变量，但可通过关联对象进行实现</li><li>分类的方法若和类中原来的方法实现重名，会优先调用分类中的方法</li><li>多个分类的方法重名，会调用最后编译的那个分类的方法实现</li></ul></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>