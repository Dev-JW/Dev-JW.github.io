<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>常见的排序算法 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="冒泡排序 作为最简单的排序算法之一，也是我们最先接触到的排序算法，简单并且一看就明白的……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/Sort/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-05-18T20:26:34+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/Sort/","name":"常见的排序算法","description":"冒泡排序 作为最简单的排序算法之一，也是我们最先接触到的排序算法，简单并且一看就明白的……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="常见的排序算法"><meta property="og:description" content="冒泡排序 作为最简单的排序算法之一，也是我们最先接触到的排序算法，简单并且一看就明白的……"><meta property="og:url" content="https://dev.hjw.best/Sort/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">常见的排序算法</h1><div class=post-meta><time datetime=2020-05-18T20:26:34+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-05-18</time></div><div class="post-body e-content"><h3 id=冒泡排序><a href=#冒泡排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>冒泡排序</h3><p>作为最简单的排序算法之一，也是我们最先接触到的排序算法，简单并且一看就明白的排序算法</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/BubbleSort.gif alt=BubbleSort></p><p><strong>算法思路</strong></p><p>两个数之间相互比较，较大的数向后移动，较小的数向前移动，经过 n 轮的比较之后，每一轮下来都可以确定一个最小的数，最终达到小的数在前，大的数在后，完成排序。</p><p><strong>算法优化</strong></p><p>因为冒泡排序是实打实的判断每一轮的两个元素，当某一趟遍历并没有进行数据元素交换时，说明已经排序好了，也就不需要进行迭代。这样可以通过使用一个标记 flag 记录这个状态。</p><ul><li>如果发生了交换，flag 设置为 true</li><li>如果没有交换就设置为 false</li></ul><p>这样当一轮比较结束后如果 flag 仍为 false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去，排序结束。</p><p><strong>时间复杂度</strong>：$O(n^2)$，要进行n轮的比较，每一轮的比较平均进行（n + 1）/ 2次</p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>BubbleSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// 优化
</span><span class=c1></span><span class=kt>void</span> <span class=nf>BubbleSort2</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>flag</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
                <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=选择排序><a href=#选择排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>选择排序</h3><p>选择排序是一种简单直观的排序算法</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/SelectionSort.gif alt=SelectionSort></p><p><strong>算法思路</strong></p><p>先在数列中找出最大或最小的元素，放到序列的起始，然后再余下的数据中继续寻找最大或最小的元素，一次放到排序序列中，直到所有数据样本排序完成</p><p><strong>时间复杂度</strong>：$O(n^2)$，进行了n轮的比较，每一轮找出最大或最小值的期望是（n+1）/ 2</p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>SelectionSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 需要交换的位置;
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>exchangePos</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>exchangePos</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
                <span class=c1>// 每一轮遍历找到一个最小值的下标;
</span><span class=c1></span>                <span class=n>exchangePos</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=c1>// 如果下标发生改变,说明存在比该位置更小的值,需要交换;
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>exchangePos</span><span class=p>)</span> <span class=p>{</span>
            <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>exchangePos</span><span class=p>];</span>
            <span class=n>arr</span><span class=p>[</span><span class=n>exchangePos</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></div><h3 id=插入排序><a href=#插入排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>插入排序</h3><p>通过构建有序序列，对于未排序的数列，在已排序序列中从后向前扫描，找到相应的位置并插入。类似打扑克牌的码牌，抓到一张牌，就要和原来手中的牌逐一比较，找到前一张不再大于手中待插入的牌时，即插入的位置</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/InsertionSort.gif alt=InsertionSort></p><p><strong>算法思路</strong></p><p>先将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序的序列，接着从头到尾依次扫描未排序序列，并将扫描到的每一个元素插入有序序列的适当位置，直到所有数据元素都完成排序</p><p><strong>时间复杂度</strong>： $O(n^2)$，同样要确定n个位置，每个位置需要确定的平均次数为(n + 1)/2</p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>InsertionSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 一直找到前一个位置不再大于插入数据的位置进行交换
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
            <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
                <span class=c1>// 增加这个break可以提高插入排序的速度;
</span><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=希尔排序><a href=#希尔排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>希尔排序</h3><p>希尔排序也称为递减增量排序，是插入排序的一种改进版本，效率虽然高，但它是一种不稳定的排序算法。</p><p>插入排序对几乎排好序的数列操作时，效率是非常好的，但是插入排序每次只能移动一位数据，因此插入排序效率还是比较低；希尔排序则在插入排序的基础上进行了改进，先将整个数列分割成若干子序列分别进行插入排序，待整个序列中的数据基本有序后，再对全部数据依次进行插入操作</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/ShellSort.gif alt=ShellSort></p><p><strong>算法思路</strong></p><ol><li>将数列分成 n 组，并对每组数据进行插入排序</li><li>将 n 组数据进行合并</li><li>重复 1 - 2 步骤，同时将增量 n 减少为 n / 2</li></ol><p><strong>时间复杂度</strong>：$O(n^{2/3})$，希尔排序的时间复杂度计算与其增量的分割有关</p><p><strong>代码实现</strong>**</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>ShellSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>inc</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=k>do</span> <span class=p>{</span>
      	<span class=c1>// 设置增量
</span><span class=c1></span>        <span class=n>inc</span> <span class=o>=</span> <span class=n>inc</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
       	<span class=c1>// i 的待插入序列数据[inc + 1, length]
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>inc</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
       			<span class=c1>// 如果 arr[i] 小于它的序列组元素，则进行插入排序   
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>inc</span><span class=p>])</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
                <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=n>inc</span><span class=p>;</span>
                <span class=k>for</span> <span class=p>(;</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>temp</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>];</span> <span class=n>j</span> <span class=o>-=</span> <span class=n>inc</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>inc</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
                <span class=p>}</span>
                <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>inc</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>inc</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h3 id=堆排序><a href=#堆排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>堆排序</h3><p>在了解堆排序之前，先来看看什么是最大堆和最小堆</p><p>最大堆就是指每一个根结点的值都比其左右子树的值要大，这样就可以得出根结点的值是所有结点中最大的；最小堆同理</p><p>堆排序是采用<strong>二叉堆</strong>的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树（完全二叉树在之前有所涉及，这里就不过多阐述）</p><p>二叉堆具有以下性质：</p><ul><li>父结点的值总数大于或等于（小于或等于）任何一个子结点的值</li><li>每一个结点的左右子树都是一个二叉堆（都是最大堆或最小堆）</li></ul><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/HeapSort.gif alt=HeapSort></p><p><strong>算法思路</strong></p><ol><li>根据初始数组，构建二叉堆，保证所有的父节点比子节点的值大</li><li>每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为最大堆</li></ol><p><strong>时间复杂度</strong>：每次重新恢复堆的时间复杂度为<strong>O(logn)</strong>，对于取元素一共进行了<code>n - 1</code>次，再加上前面建立堆时<code>n / 2</code>次向下调整，每次调整时间复杂度也为<strong>O(logn)</strong>。二次操作时间相加还是<strong>O(nlogn)</strong>。</p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>max_heaplfy</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>root</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>chlid</span> <span class=o>=</span> <span class=n>root</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>chlid</span> <span class=o>&gt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>chlid</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=n>arr</span><span class=p>[</span><span class=n>chlid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>chlid</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
            <span class=n>chlid</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>chlid</span><span class=p>])</span> <span class=p>{</span>
            <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>root</span><span class=p>];</span>
            <span class=n>arr</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>chlid</span><span class=p>];</span>
            <span class=n>arr</span><span class=p>[</span><span class=n>chlid</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
            <span class=n>root</span> <span class=o>=</span> <span class=n>chlid</span><span class=p>;</span>
        <span class=p>}</span><span class=k>else</span> <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>HeapSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 创建最大堆
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>length</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>length</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>max_heaplfy</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>length</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
        <span class=c1>// 将 [i, i - 1]调整成最大堆
</span><span class=c1></span>        <span class=n>max_heaplfy</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=归并排序><a href=#归并排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>归并排序</h3><p>归并排序是采用分治法的一个典型应用。先递归分解数组，将数组不断地拆分下去，直到数组长度为 1，再将这些数组两两合并，从底层不断地递归回去，所以是两个子序列的合并，称为更大的序列，顾而为归并排序</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/MergeSort.gif alt=MergeSort></p><p><strong>算法思路</strong></p><ol><li>递归分解，将数组分解成 left 和 right，如果这 2 个数组内部数据是有序的，则合并；如果无序，则对数组进行二分，直到分解出的小组只有一个元素，此时认为该小组内部有序</li><li>合并两个有序数组，比较两个数组的最前面的树，谁小就先取谁</li><li>重复步骤 2，直到一个数组为空</li><li>最后把另一个数组的剩余部分复制过来</li></ol><p><strong>时间复杂度</strong>：归并排序的效率是比较高的，设数组长为n，将数组分开成小数组一共要<code>logn</code>步，每步都是一个合并有序数列的过程，时间复杂度可以记为<strong>O(n)</strong>，故一共为<strong>O(nlogn)</strong>。</p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define MAXINT 10000
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>res</span><span class=p>,</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>start</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
  	<span class=c1>// 将 arr 中数据从小到大并入 res 中
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>start</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>count</span> <span class=o>=</span> <span class=n>low</span><span class=p>;</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>mid</span> <span class=o>&amp;&amp;</span> <span class=n>start</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>;</span> <span class=n>count</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>])</span> <span class=p>{</span>
            <span class=n>res</span><span class=p>[</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=o>++</span><span class=p>];</span>
        <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
            <span class=n>res</span><span class=p>[</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=o>++</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
		<span class=c1>// 将剩余的元素复制到 res 中    
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;=</span> <span class=n>mid</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>mid</span> <span class=o>-</span> <span class=n>low</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>res</span><span class=p>[</span><span class=n>count</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=o>+</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>high</span> <span class=o>-</span> <span class=n>start</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>res</span><span class=p>[</span><span class=n>count</span><span class=o>+</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=o>+</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>mSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>res</span><span class=p>,</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
 
    <span class=kt>int</span> <span class=n>mid</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>temp</span><span class=p>[</span><span class=n>MAXINT</span><span class=p>];</span>
    
    <span class=k>if</span> <span class=p>(</span><span class=n>low</span> <span class=o>==</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>res</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
    <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
      	<span class=c1>// 分解数组
</span><span class=c1></span>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
        <span class=c1>// 左边数组递归分解
</span><span class=c1></span>        <span class=n>mSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
        <span class=c1>// 右边数组递归分解
</span><span class=c1></span>        <span class=n>mSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
        <span class=c1>// 迭代合并左右数组
</span><span class=c1></span>        <span class=n>merge</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>res</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>mergeSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>mSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>arr</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
<span class=p>}</span>

<span class=cm>/* 非递归实现 */</span>
<span class=c1>//对SR数组中相邻长度为s的子序列进行两两归并到TR[]数组中;
</span><span class=c1></span><span class=kt>void</span> <span class=nf>MergePass</span><span class=p>(</span><span class=kt>int</span> <span class=n>SR</span><span class=p>[],</span><span class=kt>int</span> <span class=n>TR</span><span class=p>[],</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span><span class=kt>int</span> <span class=n>length</span><span class=p>){</span>
  
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
    
    <span class=c1>//①合并数组
</span><span class=c1></span>    <span class=c1>//s=1 循环结束位置:8 (9-2*1+1=8)
</span><span class=c1></span>    <span class=c1>//s=2 循环结束位置:6 (9-2*2+1=6)
</span><span class=c1></span>    <span class=c1>//s=4 循环结束位置:2 (9-2*4+1=2)
</span><span class=c1></span>    <span class=c1>//s=8 循环结束位置:-6(9-2*8+1=-6) s = 8时,不会进入到循环;
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span><span class=o>&lt;=</span> <span class=n>length</span><span class=o>-</span><span class=mi>2</span><span class=o>*</span><span class=n>s</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>//两两归并(合并相邻的2段数据)
</span><span class=c1></span>        <span class=n>merge</span><span class=p>(</span><span class=n>SR</span><span class=p>,</span> <span class=n>TR</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=o>+</span><span class=n>s</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=o>*</span><span class=n>s</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=o>*</span><span class=n>s</span><span class=p>;</span>
        
        <span class=cm>/*
</span><span class=cm>         s = 1,i = 1,Merge(SR,TR,1,1,2);
</span><span class=cm>         s = 1,i = 3,Merge(SR,TR,3,3,4);
</span><span class=cm>         s = 1,i = 5,Merge(SR,TR,5,5,6);
</span><span class=cm>         s = 1,i = 7,Merge(SR,TR,7,7,8);
</span><span class=cm>         s = 1,i = 9,退出循环;
</span><span class=cm>         */</span>
        
        <span class=cm>/*
</span><span class=cm>         s = 2,i = 1,Merge(SR,TR,1,2,4);
</span><span class=cm>         s = 2,i = 5,Merge(SR,TR,5,6,8);
</span><span class=cm>         s = 2,i = 9,退出循环;
</span><span class=cm>         */</span>
        
        <span class=cm>/*
</span><span class=cm>         s = 4,i = 1,Merge(SR,TR,1,4,8);
</span><span class=cm>         s = 4,i = 9,退出循环;
</span><span class=cm>         */</span>
    <span class=p>}</span>
    
    <span class=c1>//②如果i&lt;length-s+1,表示有2个长度不等的子序列. 其中一个长度为length,另一个小于length
</span><span class=c1></span>    <span class=c1>// 1 &lt; (9-8+1)(2)
</span><span class=c1></span>    <span class=c1>//s = 8时, 1 &lt; (9-8+1)
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=o>-</span><span class=n>s</span><span class=o>+</span><span class=mi>1</span><span class=p>){</span>
        <span class=c1>//Merge(SR,TR,1,8,9)
</span><span class=c1></span>        <span class=n>merge</span><span class=p>(</span><span class=n>SR</span><span class=p>,</span> <span class=n>TR</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=o>+</span><span class=n>s</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>length</span><span class=p>);</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=c1>//③只剩下一个子序列;
</span><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span><span class=n>length</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>TR</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>SR</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>MergeSort2</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>L</span><span class=p>){</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>TR</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=c1>//k的拆分变换是 1,2,4,8;
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
        <span class=c1>//将SR数组按照s=2的长度进行拆分合并,结果存储到TR数组中;
</span><span class=c1></span>        <span class=c1>//注意:此时经过第一轮的归并排序的结果是存储到TR数组了;
</span><span class=c1></span>        <span class=n>MergePass</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>TR</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
        <span class=n>k</span> <span class=o>=</span> <span class=mi>2</span><span class=o>*</span><span class=n>k</span><span class=p>;</span>
        <span class=c1>//将刚刚归并排序后的TR数组,按照s = 2k的长度进行拆分合并. 结果存储到L-&gt;r数组中;
</span><span class=c1></span>        <span class=c1>//注意:因为上一轮的排序的结果是存储到TR数组,所以这次排序的数据应该是再次对TR数组排序;
</span><span class=c1></span>        <span class=n>MergePass</span><span class=p>(</span><span class=n>TR</span><span class=p>,</span> <span class=n>L</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
        <span class=n>k</span> <span class=o>=</span> <span class=mi>2</span><span class=o>*</span><span class=n>k</span><span class=p>;</span>
        
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=快速排序><a href=#快速排序 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>快速排序</h3><p>快速排序是使用分治思想将一个序列分为两个子序列，而划分的依据是从数列中挑选一个合适的元素，该元素称为「基准」pivot。重新排列序列，所有比基准小的元素在基准前面，所有比基准大的元素在基准后面，等到分区结束之后，该基数就处于数列的中间位置。这这之后，重复这个操作，直到整个数列排序完成</p><p><strong>动画演示</strong></p><p><img src=https://w-md.imzsy.design/QuickSort.gif alt=QuickSort></p><p><strong>选取基准方法</strong></p><ol><li>固定位置：固定取数列的第一个或最后一个元素</li><li>随机选基准：取待排序数列中任意一个元素</li><li>三数取中：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴</li></ol><p><strong>算法思路</strong></p><ol><li>从数列中挑出一个元素，称为『基准』</li><li>进行分区操作，即重新排序数列，将小于基准的元素放在基准之前，将大于基准的元素放在基准之后</li><li>递归地把小于基准值元素的子数列和大于基准值源的子数列排序</li></ol><p><strong>时间复杂度</strong>：最坏运行情况是 <strong>O(n²)</strong>，比如说顺序数列的快排。但它的平摊期望时间是 <strong>O(nlogn)</strong></p><p><strong>代码实现</strong></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>//计算基准, 同时保证小于基准的位于左边，大于基准的位于右边
</span><span class=c1></span><span class=kt>int</span> <span class=nf>Partition</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>higt</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>pivotKey</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>higt</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>higt</span> <span class=o>&amp;&amp;</span> <span class=n>arr</span><span class=p>[</span><span class=n>higt</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>pivotKey</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>higt</span><span class=o>--</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 交换数字
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>temp1</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>higt</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>higt</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp1</span><span class=p>;</span>
        
        <span class=k>while</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>higt</span> <span class=o>&amp;&amp;</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>pivotKey</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>low</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 交换数字
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>temp2</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>higt</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>higt</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp2</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>low</span><span class=p>;</span>
<span class=p>};</span>

<span class=kt>void</span> <span class=nf>QSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>pivot</span><span class=p>;</span>
    
    <span class=k>if</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pivot</span> <span class=o>=</span> <span class=n>Partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
        
        <span class=n>QSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>pivot</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
        <span class=n>QSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>pivot</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>QSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
<span class=p>}</span>
</code></pre></div><p><strong>快速排序优化</strong></p><ol><li>三数取中</li><li>当待排序序列的长度分割到一定大小后，使用插入排序</li><li>优化递归：快排函数在函数尾部有两次递归操作，可以进行尾递归优化</li></ol><h3 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>总结</h3><p><a href=https://github.com/dev-jw/algorithm-sort target=_blank rel=noopener>完整代码</a></p><p><strong>常见排序算法效率比较</strong></p><div class=table-container><table><thead><tr><th>排序方式</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(nlogn) - O(n^2)$</td><td>$O(n^{2/3})$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(logn)-O(n)$</td><td>不稳定</td></tr></tbody></table></div></div></article><div class=post-tags><a href=../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>数据结构与算法</a>
<a href=../tags/%E6%8E%92%E5%BA%8F/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>排序</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>