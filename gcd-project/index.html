<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-GCD应用 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="在iOS多线程开发中，GCD是最为常用的一种方案，本文将对其的使用进行介绍 同样的，提……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/gcd-project/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-11-03T20:47:18+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/gcd-project/","name":"iOS底层原理探索-GCD应用","description":"在iOS多线程开发中，GCD是最为常用的一种方案，本文将对其的使用进行介绍 同样的，提……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-GCD应用"><meta property="og:description" content="在iOS多线程开发中，GCD是最为常用的一种方案，本文将对其的使用进行介绍 同样的，提……"><meta property="og:url" content="https://dev.hjw.best/gcd-project/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-GCD应用</h1><div class=post-meta><time datetime=2020-11-03T20:47:18+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-11-03</time></div><div class="post-body e-content"><p>在iOS多线程开发中，GCD是最为常用的一种方案，本文将对其的使用进行介绍</p><p>同样的，提几个问题：</p><ul><li>什么是 GCD</li><li>函数与队列</li><li>GCD常见的应用</li></ul><h3 id=gcd简介><a href=#gcd简介 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>GCD简介</h3><p>GCD全称是<code>Grand Central Dispatch</code>，它是纯 C 语言，并且提供了非常多强大的函数</p><p><strong>GCD的优势</strong></p><ul><li>GCD是苹果公司为<code>多核的并行运算</code>提出的<code>解决方案</code></li><li>GCD会<code>自动利用</code>更多的<code>CPU内核</code>（比如双核、四核）</li><li>GCD会<code>自动管理</code>线程的<code>生命周期</code>（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul><blockquote><p>我们要关注的点：GCD的核心——<code>将任务添加到队列，并且指定执行任务的函数</code></p></blockquote><p>例如：下面这段 GCD 代码</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=n>dispatch_async</span><span class=p>(</span><span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.GCD.Queue&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span> <span class=o>^</span><span class=p>{</span>
   <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;GCD基本使用&#34;</span><span class=p>);</span>
<span class=p>});</span>
</code></pre></div><p>可以将上面代码拆分为：<code>任务 + 队列 + 函数</code> 三部分</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=c1>//********GCD基础写法********
</span><span class=c1>//创建任务
</span><span class=c1></span><span class=n>dispatch_block_t</span> <span class=n>block</span> <span class=o>=</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;hello GCD&#34;</span><span class=p>);</span>
<span class=p>};</span>

<span class=c1>//创建串行队列
</span><span class=c1></span><span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.GCD.Queue&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>

<span class=c1>//将任务添加到队列，并指定函数执行
</span><span class=c1></span><span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=n>block</span><span class=p>);</span>
</code></pre></div><ul><li><code>dispatch_block_t</code>创建任务，使用 block 封装任务</li><li><code>dispatch_queue_t</code>创建队列</li><li><code>dispatch_async</code>将任务添加到队列</li></ul><h3 id=函数与队列><a href=#函数与队列 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>函数与队列</h3><h4 id=函数><a href=#函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>函数</h4><p>在 GCD 中执行任务的方式有两种</p><ul><li>同步函数执行 —— <code>dispatch_sync</code><ul><li>必须等到当前语句执行完毕，才会执行下一条语句</li><li>不会开启线程，即不具备开启新线程的能力</li><li>在当前线程中执行 block 任务</li></ul></li><li>异步函数执行 —— <code>dispatch_async</code><ul><li>不用等待当前语句执行完毕，就可以执行下一条语句</li><li>会开启线程执行 block 任务，即具备开启新线程的能力（并不一定开启新线程，与任务所指定的队列类型有关）</li></ul></li></ul><p>所以，两种执行任务的函数主要区别是：</p><ul><li>是否等待队列的任务执行完毕</li><li>是否具备开启新线程的能力</li></ul><h4 id=队列><a href=#队列 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>队列</h4><p>多线程中的队列是指<strong>执行任务的等待队列</strong>，即用来存放任务的队列</p><p>在 GCD 中，队列主要分为：</p><ul><li>串行队列——Serial Dispatch Queue</li><li>并发队列——Concurrent Dispatch Queue</li></ul><p><img src=https://w-md.imzsy.design/image-20201218161055440.png alt=image-20201218161055440></p><p><strong>串行队列</strong></p><p>每次只有一个任务被执行，等待上一个任务执行完毕再执行下一个，即同一时刻只调度一个任务执行</p><ul><li><code>dispatch_queue_create("xxx", DISPATCH_QUEUE_SERIAL)</code>创建串行队列</li><li><code>dispatch_queue_create("xxx", NULL)</code>也可以创建串行队列</li></ul><p><strong>并发队列</strong></p><p>一次可以并发执行多个任务，即同一时刻可以调度多个任务执行，开启多个线程，并同时执行任务</p><ul><li><code>dispatch_queue_create("xxx", DISPATCH_QUEUE_CONCURRENT)</code>创建并发队列</li><li>并发队列的并发功能只在异步函数下才有效</li></ul><p><strong>主队列</strong></p><p>Main Dispatch Queue，专门用来在主线程上调度任务的串行队列，依赖于主线程、主RunLoop，在 main 函数调用之前自动创建</p><ul><li>使用<code>dispatch_get_main_queue()</code>获取主队列</li><li>如果当前主线程正在执行任务，那么无论主队列中当前被添加什么任务，都不会被调度</li><li>通常在返回主线程，更新UI时使用</li></ul><p><strong>全局并发队列</strong></p><p>Global Dispatch Queue，系统提供的并发队列</p><ul><li>在使用多线程开发时，如果对队列没有特殊需求，<code>在执行异步任务时，可以直接使用全局队列</code></li><li>获取全局并发队列，最简单的是<code>dispatch_get_global_queue(0, 0)</code><ul><li>第一个参数表示<code>队列优先级</code>，默认优先级为<code>DISPATCH_QUEUE_PRIORITY_DEFAULT=0</code>，在ios9之后，已经被<code>服务质量（quality-of-service）</code>取代</li><li>第二个参数使用0</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=c1>//全局并发队列的获取方法
</span><span class=c1></span><span class=n>dispatch_queue_t</span> <span class=n>globalQueue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

<span class=c1>//优先级从高到低（对应的服务质量）依次为
</span><span class=c1></span><span class=p>-</span> <span class=nf>DISPATCH_QUEUE_PRIORITY_HIGH</span>       <span class=o>--</span> <span class=n>QOS_CLASS_USER_INITIATED</span>
<span class=o>-</span> <span class=n>DISPATCH_QUEUE_PRIORITY_DEFAULT</span>    <span class=o>--</span> <span class=n>QOS_CLASS_DEFAULT</span>
<span class=o>-</span> <span class=n>DISPATCH_QUEUE_PRIORITY_LOW</span>        <span class=o>--</span> <span class=n>QOS_CLASS_UTILITY</span>
<span class=o>-</span> <span class=n>DISPATCH_QUEUE_PRIORITY_BACKGROUND</span> <span class=o>--</span> <span class=n>QOS_CLASS_BACKGROUND</span>
</code></pre></div><h3 id=函数与队列的不同组合><a href=#函数与队列的不同组合 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>函数与队列的不同组合</h3><p><img src=https://w-md.imzsy.design/image-20201218162830254.png alt=image-20201218162830254></p><h4 id=串行队列同步函数><a href=#串行队列同步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>串行队列+同步函数</h4><p>任务按顺序的在当前线程执行，不会开辟新线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>serialSync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.xxx.my_queue&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_sync</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;串行 + 同步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// 串行 + 同步: 0 - &lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// 串行 + 同步: 1 - &lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// ...按顺序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h4 id=串行队列异步函数><a href=#串行队列异步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>串行队列+异步函数</h4><p>任务按顺序地执行，会开辟新线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>serialAsync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.xxx.my_queue&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;串行 + 异步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// 串行 + 同步: 0 - &lt;NSThread: 0x6000009b8880&gt;{number = 6, name = (null)}
</span><span class=c1>// 串行 + 同步: 1 - &lt;NSThread: 0x6000009b8880&gt;{number = 6, name = (null)}
</span><span class=c1>// ...按顺序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h4 id=并发队列同步函数><a href=#并发队列同步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>并发队列+同步函数</h4><p>任务按顺序的执行，不会开辟线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>concurrentSync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.xxx.my_queue&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_CONCURRENT</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_sync</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;并行 + 同步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// 并行 + 同步：0 - &lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// 并行 + 同步：1 - &lt;NSThread: 0x600003b64fc0&gt;{number = 1, name = main}
</span><span class=c1>// ...按顺序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h4 id=并发队列异步函数><a href=#并发队列异步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>并发队列+异步函数</h4><p>任务乱序执行，会开辟线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>concurrentAsync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.xxx.my_queue&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_CONCURRENT</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;并行 + 异步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600002a9cd40&gt;{number = 1, name = main}
</span><span class=c1>// 并行 + 异步：0 - &lt;NSThread: 0x600000de9800&gt;{number = 4, name = (null)}
</span><span class=c1>// 并行 + 异步：2 - &lt;NSThread: 0x600000df4940&gt;{number = 5, name = (null)}
</span><span class=c1>// 并行 + 异步：1 - &lt;NSThread: 0x600000dc0140&gt;{number = 3, name = (null)}
</span><span class=c1>// 并行 + 异步：3 - &lt;NSThread: 0x600000d9a980&gt;{number = 6, name = (null)}
</span><span class=c1>// 并行 + 异步：4 - &lt;NSThread: 0x600000d86380&gt;{number = 7, name = (null)}
</span><span class=c1>// ...乱序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h4 id=主队列同步函数><a href=#主队列同步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>主队列+同步函数</h4><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>mainSync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_get_main_queue</span><span class=p>();</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_sync</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主队列 + 同步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600001980d40&gt;{number = 1, name = main}
</span><span class=c1>// 崩溃...
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><p>会出现死锁，原因如下：</p><ul><li>主队列有两个任务，顺序为：<code>NSLog任务</code>，<code>同步Blcok</code></li><li>执行NSLog任务后，执行同步Block，会将任务1（即i=1时）加入到主队列，主队列顺序为：<code>NSLog任务 - 同步block - 任务1</code></li><li><code>任务1</code>的执行需要<code>等待同步block执行完毕</code>才会执行，而<code>同步block</code>的执行需要<code>等待任务1执行完毕</code>，所以就造成了<code>任务互相等待</code>的情况，即造成<code>死锁崩溃</code></li></ul><h4 id=主队列异步函数><a href=#主队列异步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>主队列+异步函数</h4><p>任务按顺序地执行，不会开辟线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>mainAsync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_get_main_queue</span><span class=p>();</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主队列 + 异步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600001980d40&gt;{number = 1, name = main}
</span><span class=c1>// 主队列 + 异步：0 -&lt;NSThread: 0x600001980d40&gt;{number = 1, name = main}
</span><span class=c1>// 主队列 + 异步：1 -&lt;NSThread: 0x600001980d40&gt;{number = 1, name = main}
</span><span class=c1>// ...按顺序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h4 id=全局队列同步函数><a href=#全局队列同步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>全局队列+同步函数</h4><p>任务按顺序地执行，不会开辟线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>globalSync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_sync</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;全局队列 + 同步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x6000037cc1c0&gt;{number = 1, name = main}
</span><span class=c1>// 全局队列 + 同步：0 - &lt;NSThread: 0x6000037cc1c0&gt;{number = 1, name = main}
</span><span class=c1>// 全局队列 + 同步：1 - &lt;NSThread: 0x6000037cc1c0&gt;{number = 1, name = main}
</span><span class=c1>// ...按顺序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>

</code></pre></div><h4 id=全局队列异步函数><a href=#全局队列异步函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>全局队列+异步函数</h4><p>任务乱序地执行，会开辟线程</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>globalAsync</span> <span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;主线程-%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_queue_t</span> <span class=n>my_queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>my_queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;全局队列 +  异步：%d - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// 主线程-&lt;NSThread: 0x600002f5c880&gt;{number = 1, name = main}
</span><span class=c1>// 全局队列 +  异步：1 - &lt;NSThread: 0x600002f047c0&gt;{number = 5, name = (null)}
</span><span class=c1>// 全局队列 +  异步：0 - &lt;NSThread: 0x600002f50300&gt;{number = 4, name = (null)}
</span><span class=c1>// 全局队列 +  异步：2 - &lt;NSThread: 0x600002f24200&gt;{number = 6, name = (null)}
</span><span class=c1>// 全局队列 +  异步：3 - &lt;NSThread: 0x600002f30400&gt;{number = 7, name = (null)}
</span><span class=c1>// ...乱序输出
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>

</code></pre></div><p><strong>总结一下</strong></p><div class=table-container><table><thead><tr><th>函数\队列</th><th>串行队列</th><th>并发队列</th><th>主队列</th><th>全局队列</th></tr></thead><tbody><tr><td>同步函数</td><td>顺序执行，不开辟线程</td><td>顺序执行，不开辟线程</td><td>死锁</td><td>顺序执行，不开辟线程</td></tr><tr><td>异步函数</td><td>顺序执行，开辟线程</td><td>乱序执行，开辟线程</td><td>顺序执行，不开辟线程</td><td>乱序执行，开辟线程</td></tr></tbody></table></div><h3 id=dispatch_after><a href=#dispatch_after class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_after</h3><p><code>dispatch_after</code>表示在某队列中的block延迟加入到队列，而不是延迟执行</p><p>例如：在主队列上延迟执行任务，延迟 1s 显示弹窗提示</p><div class=highlight><pre class=chroma><code class=language-objc data-lang=objc><span class=n>dispatch_after</span><span class=p>(</span><span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span> <span class=p>(</span><span class=n>int64_t</span><span class=p>)(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>)),</span> <span class=n>dispatch_get_main_queue</span><span class=p>(),</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;2秒后输出&#34;</span><span class=p>);</span>
<span class=p>});</span>
</code></pre></div><h3 id=dispatch_once><a href=#dispatch_once class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_once</h3><p><code>dispatch_once</code>保证在App运行期间，block中的代码只执行一次</p><p>常用于<code>单例、method-Swizzling</code></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>static</span> <span class=n>dispatch_once_t</span> <span class=n>onceToken</span><span class=p>;</span>
<span class=n>dispatch_once</span><span class=p>(</span><span class=o>&amp;</span><span class=n>onceToken</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
    <span class=c1>// 任务
</span><span class=c1></span><span class=p>});</span>
</code></pre></div><h3 id=dispatch_apply><a href=#dispatch_apply class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_apply</h3><p><code>dispatch_apply</code>将指定的Block追加到指定的队列中重复执行，并等到全部的处理执行结束——相当于线程安全的for循环</p><p>应用场景：用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性</p><ul><li>添加到串行队列中——按序执行</li><li>添加到主队列中——死锁</li><li>添加到并发队列中——乱序执行</li><li>添加到全局队列中——乱序执行</li></ul><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>test</span> <span class=p>{</span>
    <span class=cm>/**
</span><span class=cm>     param1：重复次数
</span><span class=cm>     param2：追加的队列
</span><span class=cm>     param3：执行任务
</span><span class=cm>     */</span>
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;X&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_SERIAL</span><span class=p>);</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;dispatch_apply前&#34;</span><span class=p>);</span>
    <span class=n>dispatch_apply</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>(</span><span class=n>size_t</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;dispatch_apply的线程%zu-%@&#34;</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;dispatch_apply后&#34;</span><span class=p>);</span>
<span class=p>}</span>
<span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
<span class=c1>// dispatch_apply前
</span><span class=c1>// dispatch_apply的线程0-&lt;NSThread: 0x6000019f8d40&gt;{number = 1, name = main}
</span><span class=c1>// ...是否按序输出与串行队列还是并发队列有关
</span><span class=c1>// dispatch_apply后
</span><span class=c1></span><span class=o>--------------------</span><span class=err>输出结果：</span><span class=o>-------------------</span>
</code></pre></div><h3 id=dispatch_group_t><a href=#dispatch_group_t class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_group_t</h3><p><code>dispatch_group_t</code>：调度组将任务分组执行，能监听任务组完成，并设置等待时间</p><p>常见的使用方式有两种</p><ul><li><p>使用<code>dispatch_group_async + dispatch_group_notify</code></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testGroup</span> <span class=p>{</span>
    <span class=cm>/*
</span><span class=cm>     dispatch_group_t：调度组将任务分组执行，能监听任务组完成，并设置等待时间
</span><span class=cm>  
</span><span class=cm>     应用场景：多个接口请求之后刷新页面
</span><span class=cm>     */</span>
      
    <span class=n>dispatch_group_t</span> <span class=n>group</span> <span class=o>=</span> <span class=n>dispatch_group_create</span><span class=p>();</span>
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
      
    <span class=n>dispatch_group_async</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求一完成&#34;</span><span class=p>);</span>
    <span class=p>});</span>
      
    <span class=n>dispatch_group_async</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求二完成&#34;</span><span class=p>);</span>
    <span class=p>});</span>
      
    <span class=n>dispatch_group_notify</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>dispatch_get_main_queue</span><span class=p>(),</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;刷新页面&#34;</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>}</span>
</code></pre></div></li><li><p>使用<code>dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</code></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testGroup</span> <span class=p>{</span>
    <span class=cm>/*
</span><span class=cm>     dispatch_group_enter和dispatch_group_leave成对出现，使进出组的逻辑更加清晰
</span><span class=cm>     */</span>
    <span class=n>dispatch_group_t</span> <span class=n>group</span> <span class=o>=</span> <span class=n>dispatch_group_create</span><span class=p>();</span>
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
      
    <span class=n>dispatch_group_enter</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求一完成&#34;</span><span class=p>);</span>
        <span class=n>dispatch_group_leave</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=p>});</span>
      
    <span class=n>dispatch_group_enter</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求二完成&#34;</span><span class=p>);</span>
        <span class=n>dispatch_group_leave</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=p>});</span>
      
    <span class=n>dispatch_group_notify</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>dispatch_get_main_queue</span><span class=p>(),</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;刷新界面&#34;</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>}</span>
</code></pre></div><p>在这种方式上，还可以增加超时<code>dispatch_group_wait</code></p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testGroup</span> <span class=p>{</span>
    <span class=cm>/*
</span><span class=cm>     long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
</span><span class=cm>  
</span><span class=cm>     group：需要等待的调度组
</span><span class=cm>     timeout：等待的超时时间（即等多久）
</span><span class=cm>        - 设置为DISPATCH_TIME_NOW意味着不等待直接判定调度组是否执行完毕
</span><span class=cm>        - 设置为DISPATCH_TIME_FOREVER则会阻塞当前调度组，直到调度组执行完毕
</span><span class=cm>  
</span><span class=cm>  
</span><span class=cm>     返回值：为long类型
</span><span class=cm>        - 返回值为0——在指定时间内调度组完成了任务
</span><span class=cm>        - 返回值不为0——在指定时间内调度组没有按时完成任务
</span><span class=cm>  
</span><span class=cm>     */</span>
    <span class=n>dispatch_group_t</span> <span class=n>group</span> <span class=o>=</span> <span class=n>dispatch_group_create</span><span class=p>();</span>
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
      
    <span class=n>dispatch_group_enter</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求一完成&#34;</span><span class=p>);</span>
        <span class=n>dispatch_group_leave</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=p>});</span>
      
    <span class=n>dispatch_group_enter</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;请求二完成&#34;</span><span class=p>);</span>
        <span class=n>dispatch_group_leave</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
    <span class=p>});</span>
      
<span class=c1>//    long timeout = dispatch_group_wait(group, DISPATCH_TIME_NOW);
</span><span class=c1>//    long timeout = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
</span><span class=c1></span>    <span class=kt>long</span> <span class=n>timeout</span> <span class=o>=</span> <span class=n>dispatch_group_wait</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>dispatch_time</span><span class=p>(</span><span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span> <span class=mi>1</span> <span class=o>*</span><span class=n>NSEC_PER_SEC</span><span class=p>));</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;timeout = %ld&#34;</span><span class=p>,</span> <span class=n>timeout</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>timeout</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;按时完成任务&#34;</span><span class=p>);</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;超时&#34;</span><span class=p>);</span>
    <span class=p>}</span>
      
    <span class=n>dispatch_group_notify</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>dispatch_get_main_queue</span><span class=p>(),</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;刷新界面&#34;</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>}</span>
</code></pre></div></li></ul><h3 id=栅栏函数><a href=#栅栏函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>栅栏函数</h3><p>栅栏函数能将多个任务进行分组——等栅栏前<strong>追加到队列中</strong>的任务执行完毕后，再将栅栏后的任务追加到队列中</p><p>简而言之，就是先执行<code>栅栏前任务</code>，再执行<code>栅栏任务</code>，最后执行<code>栅栏后任务</code></p><p><strong>应用场景</strong>：<code>同步锁</code></p><p>栅栏函数主要有两种：</p><ul><li><strong>dispatch_barrier_sync</strong>：前面的任务执行完毕才会来到这里</li><li><strong>dispatch_barrier_async</strong>：作用相同，但是这个会堵塞线程，影响后面的任务执行</li></ul><h4 id=串行队列使用栅栏函数><a href=#串行队列使用栅栏函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>串行队列使用栅栏函数</h4><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testBarrier</span> <span class=p>{</span>
    <span class=c1>//串行队列使用栅栏函数
</span><span class=c1></span>    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;X&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_SERIAL</span><span class=p>);</span>
    
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;开始 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;延迟2s的任务1 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;第一次结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    
    <span class=c1>//栅栏函数的作用是将队列中的任务进行分组，所以我们只要关注任务1、任务2
</span><span class=c1></span>    <span class=n>dispatch_barrier_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;------------栅栏任务------------%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;栅栏结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;延迟2s的任务2 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;第二次结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
<span class=p>}</span>
</code></pre></div><p>不使用栅栏函数</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=err>开始——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001068900</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第一次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001068900</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第二次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001068900</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>2</span><span class=n>s的任务1</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001025ec0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>延迟</span><span class=mi>1</span><span class=n>s的任务2</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001025ec0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><p>使用栅栏函数</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=err>开始——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001bcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第一次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001bcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>栅栏结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001bcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第二次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001bcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>2</span><span class=n>s的任务1</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001fcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=o>----------</span><span class=err>栅栏任务</span><span class=o>----------&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001bcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>1</span><span class=n>s的任务2</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000001fcf00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><p><strong>总结</strong></p><p>由于<code>串行队列 + 异步函数</code>，任务是按顺序执行的，所以使用栅栏函数没有意义</p><h4 id=并发队列使用栅栏函数><a href=#并发队列使用栅栏函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>并发队列使用栅栏函数</h4><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testBarrier</span> <span class=p>{</span>
    <span class=c1>//并发队列使用栅栏函数
</span><span class=c1></span>    
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;X&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_CONCURRENT</span><span class=p>);</span>
    
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;开始 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;延迟2s的任务1 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;第一次结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    
    <span class=c1>//由于并发队列异步执行任务是乱序执行完毕的，所以使用栅栏函数可以很好的控制队列内任务执行的顺序
</span><span class=c1></span>    <span class=n>dispatch_barrier_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;------------栅栏任务------------%@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;栅栏结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;延迟2s的任务2 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
    <span class=p>});</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;第二次结束 - %@&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
<span class=p>}</span>
</code></pre></div><p>不使用栅栏函数</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=err>开始——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600002384f00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第一次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600002384f00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第二次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600002384f00</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>1</span><span class=n>s的任务2</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000023ec300</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>延迟</span><span class=mi>2</span><span class=n>s的任务1</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000238c180</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>7</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><p>使用栅栏函数</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=err>开始——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000820bc0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第一次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000820bc0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>栅栏结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000820bc0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第二次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000820bc0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>2</span><span class=n>s的任务1</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000863c80</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=o>----------</span><span class=err>栅栏任务</span><span class=o>----------&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000863c80</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>延迟</span><span class=mi>1</span><span class=n>s的任务2</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000863c80</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><p><strong>总结</strong></p><p>由于<code>并发队列+异步函数</code>，任务是乱序执行的，使用栅栏函数可以控制队列内的任务执行顺序</p><h4 id=dispatch_barrier_async与dispatch_barrier_sync><a href=#dispatch_barrier_async与dispatch_barrier_sync class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>dispatch_barrier_async</code>与<code>dispatch_barrier_sync</code></h4><p>如果将案例二中的<code>dispatch_barrier_async</code>改成<code>dispatch_barrier_sync</code></p><p>那么输出变为：</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=err>开始——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001040d40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第一次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001040d40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>2</span><span class=n>s的任务1</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000100ce40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=o>----------</span><span class=err>栅栏任务</span><span class=o>----------&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001040d40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>栅栏结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001040d40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>第二次结束——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600001040d40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=n>main</span><span class=p>}</span>
<span class=err>延迟</span><span class=mi>1</span><span class=n>s的任务2</span><span class=err>——</span><span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000100ce40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><p>所以，<strong>dispatch_barrier_async可以控制队列中任务的执行顺序，而dispatch_barrier_sync不仅阻塞了队列的执行，也阻塞了线程的执行（尽量少用）</strong></p><h4 id=栅栏函数注意点><a href=#栅栏函数注意点 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>栅栏函数注意点</h4><p><code>尽量使用自定义的并发队列</code>：</p><ul><li>使用<code>全局队列</code>起不到<code>栅栏函数</code>的作用</li><li>使用<code>全局队列</code>时由于对全局队列造成堵塞，可能致使系统其他调用全局队列的地方也堵塞从而导致崩溃（并不是只有你在使用这个队列）</li></ul><p><code>栅栏函数只能控制同一并发队列</code>：比如，在使用AFNetworking做网络请求时为什么不能用栅栏函数起到同步锁堵塞的效果，因为AFNetworking内部有自己的队列</p><h3 id=dispatch_semaphore_t><a href=#dispatch_semaphore_t class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_semaphore_t</h3><p>信号量主要用于同步锁，用于控制 GCD 最大并发数</p><ul><li><code>dispatch_semaphore_create()</code>：创建信号量</li><li><code>dispatch_semaphore_wait()</code>：等待信号量，信号量减1。当信号量<code>&lt; 0</code>时会阻塞当前线程，根据传入的等待时间决定接下来的操作——如果<strong>永久等待</strong>将等到<code>信号（signal）</code>才执行下去</li><li><code>dispatch_semaphore_signal()</code>：释放信号量，信号量加1。当信号量<code>>= 0</code> 会执行wait之后的代码</li></ul><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>testSemaphore</span> <span class=p>{</span> 
    <span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;X&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_CONCURRENT</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;当前 - %d， 线程 - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
        <span class=p>});</span>
    <span class=p>}</span>
  
    <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;------------------&#34;</span><span class=p>);</span>
    <span class=c1>//利用信号量来改写
</span><span class=c1></span>    <span class=n>dispatch_semaphore_t</span> <span class=n>sem</span> <span class=o>=</span> <span class=n>dispatch_semaphore_create</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>dispatch_async</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
            <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;当前 - %d， 线程 - %@&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=p>[</span><span class=n>NSThread</span> <span class=n>currentThread</span><span class=p>]);</span>
            
            <span class=n>dispatch_semaphore_signal</span><span class=p>(</span><span class=n>sem</span><span class=p>);</span>
        <span class=p>});</span>
        <span class=n>dispatch_semaphore_wait</span><span class=p>(</span><span class=n>sem</span><span class=p>,</span> <span class=n>DISPATCH_TIME_FOREVER</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// 输出
</span><span class=c1></span><span class=err>当前</span> <span class=o>-</span> <span class=mi>0</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e140</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>4</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000431e80</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>2</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000425880</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>7</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>1</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e200</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>3</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000420f40</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>5</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000424380</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>6</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000410100</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>9</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>7</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>9</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x600000431e80</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>8</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x6000004714c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>11</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=o>------------------</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>0</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>1</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>2</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>3</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>4</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>5</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>6</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>7</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>8</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
<span class=err>当前</span> <span class=o>-</span> <span class=mi>9</span><span class=err>，</span> <span class=err>线程</span> <span class=o>-</span> <span class=o>&lt;</span><span class=nl>NSThread</span><span class=p>:</span> <span class=mh>0x60000043e1c0</span><span class=o>&gt;</span><span class=p>{</span><span class=n>number</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=n>null</span><span class=p>)}</span>
</code></pre></div><h3 id=dispatch_source><a href=#dispatch_source class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>dispatch_source</h3><p>应用场景：<code>GCDTimer</code></p><h4 id=定义及使用><a href=#定义及使用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>定义及使用</h4><p><code>dispatch_source</code>是一种基本的数据类型，可以用来监听一些底层的系统事件</p><ul><li><code>Timer Dispatch Source</code>：定时器事件源，用来生成周期性的通知或回调</li><li><code>Signal Dispatch Source</code>：监听信号事件源，当有UNIX信号发生时会通知</li><li><code>Descriptor Dispatch Source</code>：监听文件或socket事件源，当文件或socket数据发生变化时会通知</li><li><code>Process Dispatch Source</code>：监听进程事件源，与进程相关的事件通知</li><li><code>Mach port Dispatch Source</code>：监听Mach端口事件源</li><li><code>Custom Dispatch Source</code>：监听自定义事件源</li></ul><p>主要使用的API：</p><ul><li><code>dispatch_source_create</code>: 创建事件源</li><li><code>dispatch_source_set_event_handler</code>: 设置数据源回调</li><li><code>dispatch_source_merge_data</code>: 设置事件源数据</li><li><code>dispatch_source_get_data</code>： 获取事件源数据</li><li><code>dispatch_resume</code>: 继续</li><li><code>dispatch_suspend</code>: 挂起</li><li><code>dispatch_cancle</code>: 取消</li></ul><h4 id=自定义定时器><a href=#自定义定时器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>自定义定时器</h4><p>在iOS开发中一般使用<code>NSTimer</code>来处理定时逻辑，但<code>NSTimer</code>是依赖<code>Runloop</code>的，而<code>Runloop</code>可以运行在不同的模式下</p><p>如果<code>NSTimer</code>添加在一种模式下，当<code>Runloop</code>运行在其他模式下的时候，定时器就会不起作用</p><p>如果<code>Runloop</code>在阻塞状态，<code>NSTimer</code>触发时间就会推迟到下一个<code>Runloop</code>周期</p><p>因此<code>NSTimer</code>在计时上会有误差，并不是特别精确，而GCD定时器不依赖<code>Runloop</code>，计时精度要高很多</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>strong</span><span class=p>)</span> <span class=n>dispatch_source_t</span> <span class=n>timer</span><span class=p>;</span>
<span class=c1>//1.创建队列
</span><span class=c1></span><span class=n>dispatch_queue_t</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=n>DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=c1>//2.创建timer
</span><span class=c1></span><span class=n>_timer</span> <span class=o>=</span> <span class=n>dispatch_source_create</span><span class=p>(</span><span class=n>DISPATCH_SOURCE_TYPE_TIMER</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>queue</span><span class=p>);</span>
<span class=c1>//3.设置timer首次执行时间，间隔，精确度
</span><span class=c1></span><span class=n>dispatch_source_set_timer</span><span class=p>(</span><span class=n>_timer</span><span class=p>,</span> <span class=n>DISPATCH_TIME_NOW</span><span class=p>,</span> <span class=mf>2.0</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>,</span> <span class=mf>0.1</span> <span class=o>*</span> <span class=n>NSEC_PER_SEC</span><span class=p>);</span>
<span class=c1>//4.设置timer事件回调
</span><span class=c1></span><span class=n>dispatch_source_set_event_handler</span><span class=p>(</span><span class=n>_timer</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
    <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;GCDTimer&#34;</span><span class=p>);</span>
<span class=p>});</span>
<span class=c1>//5.默认是挂起状态，需要手动激活
</span><span class=c1></span><span class=n>dispatch_resume</span><span class=p>(</span><span class=n>_timer</span><span class=p>);</span>
</code></pre></div><p>使用<code>dispatch_source</code>自定义定时器注意点：</p><ul><li><p><code>GCDTimer</code>需要<code>强持有</code>，否则出了作用域立即释放，也就没有了事件回调</p></li><li><p><code>GCDTimer</code>默认是挂起状态，需要手动激活</p></li><li><p><code>GCDTimer</code>没有<code>repeat</code>，需要封装来增加标志位控制</p></li><li><p><code>GCDTimer</code>如果存在循环引用，使用<code>weak+strong</code>或者提前调用<code>dispatch_source_cancel</code>取消timer</p></li><li><p><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡</p></li><li><p><code>source</code>在<code>挂起状态</code>下，如果直接设置<code>source = nil</code>或者重新创建<code>source</code>都会造成<code>crash</code></p><p>正确的方式是在<code>激活状态</code>下调用<code>dispatch_source_cancel(source)</code>释放当前的<code>source</code></p></li></ul><h3 id=gcd实现多读单写><a href=#gcd实现多读单写 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>GCD实现多读单写</h3><blockquote><p>比如在内存中维护一份数据，有多处地方可能会同时操作这块数据，怎么保证数据安全？</p></blockquote><p>想要达到上面的需求，要满足以下三点：</p><ul><li>读写互斥</li><li>写写互斥</li><li>读读并发</li></ul><p>先来看一下具体实现</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=k>@interface</span> <span class=nc>Person</span> : <span class=nc>NSObject</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>strong</span><span class=p>)</span> <span class=n>dispatch_queue_t</span> <span class=n>concurrentQueue</span><span class=p>;</span>

<span class=k>@property</span> <span class=p>(</span><span class=k>nonatomic</span><span class=p>,</span> <span class=k>copy</span><span class=p>)</span> <span class=n>NSMutableDictionary</span> <span class=o>*</span><span class=n>dict</span><span class=p>;</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>setSafeObject:</span><span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nv>object</span> <span class=nf>forKey:</span><span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nv>key</span><span class=p>;</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nf>safeObjectForKey:</span><span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nv>key</span><span class=p>;</span>

<span class=k>@end</span>

<span class=k>@implementation</span> <span class=nc>Person</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>instancetype</span><span class=p>)</span><span class=nf>init</span>
<span class=p>{</span>
    <span class=nb>self</span> <span class=o>=</span> <span class=p>[</span><span class=nb>super</span> <span class=n>init</span><span class=p>];</span>
    <span class=k>if</span> <span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_concurrentQueue</span> <span class=o>=</span> <span class=n>dispatch_queue_create</span><span class=p>(</span><span class=s>&#34;com.person.Queue&#34;</span><span class=p>,</span> <span class=n>DISPATCH_QUEUE_CONCURRENT</span><span class=p>);</span>
        
        <span class=n>_dict</span> <span class=o>=</span> <span class=p>[</span><span class=n>NSMutableDictionary</span> <span class=n>dictionary</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>self</span><span class=p>;</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>setSafeObject:</span><span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nv>object</span> <span class=nf>forKey:</span><span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nv>key</span> <span class=p>{</span>
    <span class=n>key</span> <span class=o>=</span> <span class=p>[</span><span class=n>key</span> <span class=k>copy</span><span class=p>];</span>
    <span class=n>dispatch_barrier_async</span><span class=p>(</span><span class=n>_concurrentQueue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=p>[</span><span class=nb>self</span><span class=o>-&gt;</span><span class=n>_dict</span> <span class=nl>setObject</span><span class=p>:</span><span class=n>object</span> <span class=nl>forKey</span><span class=p>:</span><span class=n>key</span><span class=p>];</span>
    <span class=p>});</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nf>safeObjectForKey:</span><span class=p>(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=nv>key</span> <span class=p>{</span>
    <span class=k>__block</span> <span class=n>NSString</span> <span class=o>*</span><span class=n>temp</span><span class=p>;</span>
    <span class=n>dispatch_async</span><span class=p>(</span><span class=n>_concurrentQueue</span><span class=p>,</span> <span class=o>^</span><span class=p>{</span>
        <span class=n>temp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>self</span><span class=o>-&gt;</span><span class=n>_dict</span> <span class=nl>objectForKey</span><span class=p>:</span><span class=n>key</span><span class=p>];</span>
    <span class=p>});</span>
    <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>@end</span>
</code></pre></div><ul><li><p>首先，要维系一个 GCD 队列，尽量不要使用全局队列（在全局队列中使用栅栏函数有坑点）</p></li><li><p>考虑性能、死锁、堵塞的因素，这里不使用串行队列，选择用自定义并发队列</p></li><li><p>对于读操作<code>safeObjectForKey</code>，由于多线程影响，这里不能使用异步函数</p><ul><li>例如，线程 2 获取 <code>name</code>，线程 3 获取 <code>age</code>，如果异步并发，那么就会混乱</li><li>允许多个任务同时加入，但是读操作需要同步返回，因此选择<code>同步函数</code>，<strong>读读并发</strong></li></ul></li><li><p>写操作<code>setSafeObject:forKey:</code></p><p>先对 key 进行 copy，关于为什么需要 copy，可以参考文献：</p><blockquote><p>函数调用者可以自由传递一个 <code>NSMutableString</code> 的 <code>key</code>，并且能够在函数返回后修改它。因此我们必须对传入的字符串使用 <code>copy</code> 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 <code>NSString</code>），调用 <code>copy</code> 基本上是空操作</p></blockquote><p>这里选择使用栅栏函数<code>dispatch_barrier_async</code>，分析如下</p><ul><li>栅栏函数：相当于同步锁，保证栅栏之前的任务执行在栅栏之后，确保<strong>写写互斥</strong></li><li>如果用异步函数，并发队列+异步函数，会产生混乱</li><li>如果用同步函数，由于读操作已经使用了同步函数，那么就可能存在：在写的时候，需要等待读操作完成才能执行，无法保证<strong>读写并发</strong></li></ul></li></ul><h3 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>总结</h3><p>GCD 的 API 是相对比较多的，本来梳理了常见的应用</p><p>下一篇将探索 GCD 的底层原理</p></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>