<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>iOS底层原理探索-alloc流程分析 | Dev - jw</title><link rel=stylesheet href=../css/meme.min.ae509b8259cb6c090411be6371211f6bb00631055ec9b68a994f27bb5f5f5f76.css><script src=../js/meme.min.3a56ecbb4ec7b23a805fc0116d4dac9095813dfd877cd8379675a8bdac538ffe.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Dev - jw"><meta name=description content="首先，我们抛出几个问题，带着这些问题去探索 alloc 流程，可以加深我们对 alloc 流程的理解 alloc 究竟做……"><link rel="shortcut icon" href=../favicon.ico type=image/x-icon><link rel=mask-icon href=../icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=../icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Dev - jw"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Dev - jw"><meta name=msapplication-starturl content="../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../icons/mstile-150x150.png"><link rel=manifest href=../manifest.json><link rel=canonical href=https://dev.hjw.best/alloc/><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","datePublished":"2020-09-05T11:29:07+08:00","dateModified":"2021-03-31T15:42:56+08:00","url":"https://dev.hjw.best/alloc/","name":"iOS底层原理探索-alloc流程分析","description":"首先，我们抛出几个问题，带着这些问题去探索 alloc 流程，可以加深我们对 alloc 流程的理解 alloc 究竟做……","image":"https://dev.hjw.best/favicon.ico","license":"Copyright","publisher":{"@type":"Organization","name":"Dev - jw","logo":{"@type":"ImageObject","url":"https://dev.hjw.best/favicon.ico"},"url":"https://dev.hjw.best/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://dev.hjw.best/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="iOS底层原理探索-alloc流程分析"><meta property="og:description" content="首先，我们抛出几个问题，带着这些问题去探索 alloc 流程，可以加深我们对 alloc 流程的理解 alloc 究竟做……"><meta property="og:url" content="https://dev.hjw.best/alloc/"><meta property="og:site_name" content="Dev - jw"><meta property="og:locale" content="zh"><meta property="og:image" content="https://dev.hjw.best/favicon.ico"><meta property="og:type" content="website"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript><meta name=baidu-site-verification content="5nzYjT6RG7"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=../ class=brand>Dev - jw</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=../about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=default data-type=posts data-toc-num=true><h1 class="post-title p-name">iOS底层原理探索-alloc流程分析</h1><div class=post-meta><time datetime=2020-09-05T11:29:07+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020-09-05</time></div><div class="post-body e-content"><p>首先，我们抛出几个问题，带着这些问题去探索 alloc 流程，可以加深我们对 alloc 流程的理解</p><ul><li>alloc 究竟做了什么</li><li><code>NSObject</code>类和继承 <code>NSObject</code> 类的alloc流程有什么区别</li><li>alloc 的过程中是如何计算对象开辟内存的大小？影响因素是什么</li><li>alloc、init、new 的区别是什么</li></ul><p><strong>准备工作</strong></p><p>在开始之前，我们需要先对<strong>objc源码</strong>进行配置，并编译。参考这篇文章：『<a href=https://juejin.im/post/6844903959161733133 target=_blank rel=noopener>objc源码编译调试</a>』</p><h3 id=alloc-流程分析><a href=#alloc-流程分析 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>alloc 流程分析</h3><p><strong>alloc流程图</strong></p><p><img src=https://w-md.imzsy.design/image-20200909151920112.png alt=image-20200909151920112></p><p>通过 alloc 流程图，我们可以得出：调用 <code>alloc</code> 的时候，会先来到 <code>objc_alloc</code> 方法。</p><blockquote><p>这里有个疑问：</p><p>明明调用的是 alloc 方法，为什么会进到 objc_alloc 方法中呢？</p></blockquote><p>这是因为在 <code>llvm</code> 中，对一些特殊的入口进行了修饰，比如：调用 alloc 方法，实际会调用 objc_alloc 方法。</p><p><strong>llvm 对于特殊入口alloc的修饰处理</strong></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>static</span> <span class=n>Optional</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>::</span><span class=n>Value</span> <span class=o>*&gt;</span>
<span class=n>tryGenerateSpecializedMessageSend</span><span class=p>(</span><span class=n>CodeGenFunction</span> <span class=o>&amp;</span><span class=n>CGF</span><span class=p>,</span> <span class=n>QualType</span> <span class=n>ResultType</span><span class=p>,</span>
                                  <span class=n>llvm</span><span class=o>::</span><span class=n>Value</span> <span class=o>*</span><span class=n>Receiver</span><span class=p>,</span>
                                  <span class=k>const</span> <span class=n>CallArgList</span><span class=o>&amp;</span> <span class=n>Args</span><span class=p>,</span> <span class=n>Selector</span> <span class=n>Sel</span><span class=p>,</span>
                                  <span class=k>const</span> <span class=n>ObjCMethodDecl</span> <span class=o>*</span><span class=n>method</span><span class=p>,</span>
                                  <span class=kt>bool</span> <span class=n>isClassMessage</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=o>&amp;</span><span class=n>CGM</span> <span class=o>=</span> <span class=n>CGF</span><span class=p>.</span><span class=n>CGM</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CGM</span><span class=p>.</span><span class=n>getCodeGenOpts</span><span class=p>().</span><span class=n>ObjCConvertMessagesToRuntimeCalls</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>None</span><span class=p>;</span>

  <span class=k>auto</span> <span class=o>&amp;</span><span class=n>Runtime</span> <span class=o>=</span> <span class=n>CGM</span><span class=p>.</span><span class=n>getLangOpts</span><span class=p>().</span><span class=n>ObjCRuntime</span><span class=p>;</span>
  <span class=k>switch</span> <span class=p>(</span><span class=n>Sel</span><span class=p>.</span><span class=n>getMethodFamily</span><span class=p>())</span> <span class=p>{</span>
  <span class=k>case</span> <span class=nl>OMF_alloc</span><span class=p>:</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>isClassMessage</span> <span class=o>&amp;&amp;</span>
        <span class=n>Runtime</span><span class=p>.</span><span class=n>shouldUseRuntimeFunctionsForAlloc</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
        <span class=n>ResultType</span><span class=o>-&gt;</span><span class=n>isObjCObjectPointerType</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// [Foo alloc] -&gt; objc_alloc(Foo) or
</span><span class=c1></span>        <span class=c1>// [self alloc] -&gt; objc_alloc(self)
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>Sel</span><span class=p>.</span><span class=n>isUnarySelector</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>Sel</span><span class=p>.</span><span class=n>getNameForSlot</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;alloc&#34;</span><span class=p>)</span>
          <span class=c1>// 调用下面的转换方法
</span><span class=c1></span>          <span class=k>return</span> <span class=n>CGF</span><span class=p>.</span><span class=n>EmitObjCAlloc</span><span class=p>(</span><span class=n>Receiver</span><span class=p>,</span> <span class=n>CGF</span><span class=p>.</span><span class=n>ConvertType</span><span class=p>(</span><span class=n>ResultType</span><span class=p>));</span>
        <span class=c1>// [Foo allocWithZone:nil] -&gt; objc_allocWithZone(Foo) or
</span><span class=c1></span>        <span class=c1>// [self allocWithZone:nil] -&gt; objc_allocWithZone(self)
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>Sel</span><span class=p>.</span><span class=n>isKeywordSelector</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>Sel</span><span class=p>.</span><span class=n>getNumArgs</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span>
            <span class=n>Args</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>Args</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>getType</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>isPointerType</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
            <span class=n>Sel</span><span class=p>.</span><span class=n>getNameForSlot</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;allocWithZone&#34;</span><span class=p>)</span> <span class=p>{</span>
          <span class=k>const</span> <span class=n>llvm</span><span class=o>::</span><span class=n>Value</span><span class=o>*</span> <span class=n>arg</span> <span class=o>=</span> <span class=n>Args</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>getKnownRValue</span><span class=p>().</span><span class=n>getScalarVal</span><span class=p>();</span>
          <span class=k>if</span> <span class=p>(</span><span class=n>isa</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>::</span><span class=n>ConstantPointerNull</span><span class=o>&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>))</span>
            <span class=k>return</span> <span class=n>CGF</span><span class=p>.</span><span class=n>EmitObjCAllocWithZone</span><span class=p>(</span><span class=n>Receiver</span><span class=p>,</span>
                                             <span class=n>CGF</span><span class=p>.</span><span class=n>ConvertType</span><span class=p>(</span><span class=n>ResultType</span><span class=p>));</span>
          <span class=k>return</span> <span class=n>None</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>break</span><span class=p>;</span>
    <span class=p>...</span>
<span class=p>}</span>
  
<span class=n>llvm</span><span class=o>::</span><span class=n>Value</span> <span class=o>*</span><span class=n>CodeGenFunction</span><span class=o>::</span><span class=n>EmitObjCAlloc</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>Value</span> <span class=o>*</span><span class=n>value</span><span class=p>,</span>
                                            <span class=n>llvm</span><span class=o>::</span><span class=n>Type</span> <span class=o>*</span><span class=n>resultType</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nf>emitObjCValueOperation</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>resultType</span><span class=p>,</span>
                                <span class=n>CGM</span><span class=p>.</span><span class=n>getObjCEntrypoints</span><span class=p>().</span><span class=n>objc_alloc</span><span class=p>,</span>
                                <span class=s>&#34;objc_alloc&#34;</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>我们通过打印调用堆栈信息，可以发现 <code>NSObject</code>类和继承 <code>NSObject</code> 类并不相同</p><ul><li><p><code>NSObject</code> 的 alloc 流程：</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>* thread <span class=c1>#1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 4.2</span>
  * frame <span class=c1>#0: 0x000000010031c5be libobjc.A.dylib`objc_alloc [inlined] callAlloc(cls=NSObject, checkNil=true, allocWithZone=false) at NSObject.mm:1704:9</span>
    frame <span class=c1>#1: 0x000000010031c5be libobjc.A.dylib`objc_alloc(cls=NSObject) at NSObject.mm:1730</span>
    frame <span class=c1>#2: 0x0000000100000e9b ObjcTest`main(argc=1, argv=0x00007ffeefbff5d0) at main.m:33:25 [opt]</span>
    frame <span class=c1>#3: 0x00007fff6824fcc9 libdyld.dylib`start + 1</span>
</code></pre></div></li><li><p>继承 <code>NSObject</code> 类的 alloc 流程：</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>* thread <span class=c1>#1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 4.1</span>
  * frame <span class=c1>#0: 0x00000001002c1c8e libobjc.A.dylib`_objc_rootAlloc [inlined] callAlloc(cls=Person, checkNil=false, allocWithZone=true) at NSObject.mm:1704:9</span>
    frame <span class=c1>#1: 0x00000001002c1c8e libobjc.A.dylib`_objc_rootAlloc(cls=Person) at NSObject.mm:1723</span>
    frame <span class=c1>#2: 0x000000010031e409 libobjc.A.dylib`+[NSObject alloc](self=Person, _cmd=&#34;alloc&#34;) at NSObject.mm:2321:12</span>
    frame <span class=c1>#3: 0x000000010031c665 libobjc.A.dylib`objc_alloc [inlined] callAlloc(cls=Person, checkNil=true, allocWithZone=false) at NSObject.mm:1714:12</span>
    frame <span class=c1>#4: 0x000000010031c5be libobjc.A.dylib`objc_alloc(cls=Person) at NSObject.mm:1730</span>
    frame <span class=c1>#5: 0x0000000100000eab ObjcTest`main(argc=1, argv=0x00007ffeefbff5d0) at main.m:35:26 [opt]</span>
    frame <span class=c1>#6: 0x00007fff6824fcc9 libdyld.dylib`start + 1</span>
</code></pre></div></li></ul><p>上面的堆栈信息，也可以验证调用 alloc 方法，先会进到 objc_alloc。</p><p>但是，这里有一个新的问题：<strong>为什么继承 NSObject 的会调用两次 alloc 方法？</strong></p><h3 id=核心函数理解><a href=#核心函数理解 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>核心函数理解</h3><ul><li><code>callAlloc</code></li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Call [cls alloc] or [cls allocWithZone:nil], with appropriate 
</span><span class=c1>// shortcutting optimizations.
</span><span class=c1></span><span class=k>static</span> <span class=n>ALWAYS_INLINE</span> <span class=n>id</span>
<span class=nf>callAlloc</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>checkNil</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>allocWithZone</span><span class=o>=</span><span class=nb>false</span><span class=p>)</span>
<span class=p>{</span>
<span class=cp>#if __OBJC2__    
</span><span class=cp></span>  	<span class=c1>// 希望编译器进行优化——这里表示cls大概率是有值的，编译器可以不用每次都读取 return nil 指令
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>slowpath</span><span class=p>(</span><span class=n>checkNil</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>cls</span><span class=p>))</span> <span class=k>return</span> <span class=n>nil</span><span class=p>;</span>
 		<span class=c1>// fastpath(x)表示x很可能不为0，
</span><span class=c1></span>    <span class=c1>// cls-&gt;ISA()-&gt;hasCustomAWZ() 表示 当前类是否有自定义 +allocWithZone 实现
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>fastpath</span><span class=p>(</span><span class=o>!</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>ISA</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>hasCustomAWZ</span><span class=p>()))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>_objc_rootAllocWithZone</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>nil</span><span class=p>);</span>
    <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span>
    <span class=c1>// No shortcuts available.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>allocWithZone</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>((</span><span class=n>id</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>id</span><span class=p>,</span> <span class=n>SEL</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>_NSZone</span> <span class=o>*</span><span class=p>))</span><span class=n>objc_msgSend</span><span class=p>)(</span><span class=n>cls</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=nl>allocWithZone</span><span class=p>:),</span> <span class=n>nil</span><span class=p>);</span>
    <span class=p>}</span>
  	<span class=c1>// 调用 alloc
</span><span class=c1></span>    <span class=k>return</span> <span class=p>((</span><span class=n>id</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>id</span><span class=p>,</span> <span class=n>SEL</span><span class=p>))</span><span class=n>objc_msgSend</span><span class=p>)(</span><span class=n>cls</span><span class=p>,</span> <span class=err>@</span><span class=n>selector</span><span class=p>(</span><span class=n>alloc</span><span class=p>));</span>
<span class=p>}</span>

</code></pre></div><p><strong>slowpath & fastpath</strong></p><p>这两个都是 objc 源码中定义的宏，其中的<code>__builtin_expect</code>指令是由<code>gcc</code>引入的，</p><ul><li><p>目的：编译器可以对代码进行优化，以减少指令跳转带来的性能下降。即性能优化</p></li><li><p>作用：<code>允许程序员将最有可能执行的分支告诉编译器</code></p></li><li><p>指令的写法为：<code>__builtin_expect(EXP, N)</code>，表示 <code>EXP==N的概率很大</code></p></li></ul><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// fastpath(x)表示x很可能不为0
</span><span class=c1></span><span class=cp>#define fastpath(x) (__builtin_expect(bool(x), 1))
</span><span class=cp></span><span class=c1>// slowpath(x)表示x很可能为0
</span><span class=c1></span><span class=cp>#define slowpath(x) (__builtin_expect(bool(x), 0))
</span></code></pre></div><ul><li><p><code>fastpath</code>定义为<code>__builtin_expect((x),1)</code>表示 <code>x 的值为真的可能性更大</code></p><ul><li>即执行<code>if</code> 里面语句的机会更大</li></ul></li><li><p><code>slowpath</code>定义为<code>__builtin_expect((x),0)</code>表示 <code>x 的值为假的可能性更大</code></p><ul><li>即执行 <code>else</code> 里面语句的机会更大</li></ul></li></ul><blockquote><p>在日常的开发中，也可以通过设置来<code>优化编译器</code>，达到<code>性能优化</code>的目的，设置的路径为：<code>Build Setting</code> --> <code>Optimization Level</code> --> <code>Debug</code> --> 将<code>None</code> 改为 <code>fastest</code> 或者 <code>smallest</code></p></blockquote><p><strong>为什么继承 NSObject 的会调用两次 alloc 方法？</strong></p><p>现在，我们来回答上面的问题，在进入 <code>callAlloc</code> 方法中，</p><ul><li>当 cls 为 NSObject 时，会进入到调用<code>_objc_rootAllocWithZone</code>方法的语句</li><li>当 cls 为 继承 NSObject 的类时<ul><li><p>第一次进入 <code>callAlloc</code> 方法</p><p>并不会进入到调用<code>_objc_rootAllocWithZone</code>方法，</p><p>来到<code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc))</code>语句，</p><p>对应堆栈信息中的 <code>objc_alloc [inlined] callAlloc(cls=Person, checkNil=true, allocWithZone=false) at NSObject.mm:1714:12</code></p></li><li><p>第二次进入 <code>callAlloc</code> 方法，会进入到调用<code>_objc_rootAllocWithZone</code>方法的语句</p></li></ul></li></ul><blockquote><p>当继承 NSObject 的类 alloc 时，</p><ol><li>先进入 <code>objc_alloc -> callAlloc</code>，这是第一次进入<code>callAlloc</code>方法，会向系统发生 alloc 消息</li><li><code>alloc->callAlloc->_objc_rootAllocWithZone</code>，这是第二次进入<code>callAlloc</code>方法，也就是上面提及的 alloc 流程</li></ol></blockquote><h5 id=_class_createinstancefromzone><a href=#_class_createinstancefromzone class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>_class_createInstanceFromZone</code></h5><p><img src=https://w-md.imzsy.design/image-20200909102959562.png alt=image-20200909102959562></p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=cm>/***********************************************************************
</span><span class=cm>* class_createInstance
</span><span class=cm>* fixme
</span><span class=cm>* Locking: none
</span><span class=cm>*
</span><span class=cm>* Note: this function has been carefully written so that the fastpath
</span><span class=cm>* takes no branch.
</span><span class=cm>**********************************************************************/</span>
<span class=k>static</span> <span class=n>ALWAYS_INLINE</span> <span class=n>id</span>
<span class=nf>_class_createInstanceFromZone</span><span class=p>(</span><span class=n>Class</span> <span class=n>cls</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>extraBytes</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>zone</span><span class=p>,</span>
                              <span class=kt>int</span> <span class=n>construct_flags</span> <span class=o>=</span> <span class=n>OBJECT_CONSTRUCT_NONE</span><span class=p>,</span>
                              <span class=kt>bool</span> <span class=n>cxxConstruct</span> <span class=o>=</span> <span class=nb>true</span><span class=p>,</span>
                              <span class=n>size_t</span> <span class=o>*</span><span class=n>outAllocatedSize</span> <span class=o>=</span> <span class=n>nil</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>cls</span><span class=o>-&gt;</span><span class=n>isRealized</span><span class=p>());</span>

    <span class=c1>// Read class&#39;s info bits all at once for performance
</span><span class=c1></span>  	<span class=c1>// hasCxxCtor()是判断当前class或者superclass是否有.cxx_construct 构造方法的实现
</span><span class=c1></span>    <span class=kt>bool</span> <span class=n>hasCxxCtor</span> <span class=o>=</span> <span class=n>cxxConstruct</span> <span class=o>&amp;&amp;</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>hasCxxCtor</span><span class=p>();</span>
  
    <span class=c1>// hasCxxDtor()是判断判断当前class或者superclass是否有.cxx_destruct 析构方法的实现
</span><span class=c1></span>    <span class=kt>bool</span> <span class=n>hasCxxDtor</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>hasCxxDtor</span><span class=p>();</span>
  
  	<span class=c1>// anAllocNonpointer()是具体标记某个类是否支持优化的isa
</span><span class=c1></span>    <span class=kt>bool</span> <span class=n>fast</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>canAllocNonpointer</span><span class=p>();</span>
    <span class=n>size_t</span> <span class=n>size</span><span class=p>;</span>

  	<span class=c1>// instanceSize()获取类的大小（传入额外字节的大小）
</span><span class=c1></span>    <span class=n>size</span> <span class=o>=</span> <span class=n>cls</span><span class=o>-&gt;</span><span class=n>instanceSize</span><span class=p>(</span><span class=n>extraBytes</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>outAllocatedSize</span><span class=p>)</span> <span class=o>*</span><span class=n>outAllocatedSize</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>

    <span class=n>id</span> <span class=n>obj</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>zone</span><span class=p>)</span> <span class=p>{</span>
      	<span class=c1>// 开辟内存
</span><span class=c1></span>        <span class=n>obj</span> <span class=o>=</span> <span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=n>malloc_zone_calloc</span><span class=p>((</span><span class=n>malloc_zone_t</span> <span class=o>*</span><span class=p>)</span><span class=n>zone</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 开辟内存
</span><span class=c1></span>        <span class=n>obj</span> <span class=o>=</span> <span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=n>calloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>slowpath</span><span class=p>(</span><span class=o>!</span><span class=n>obj</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>construct_flags</span> <span class=o>&amp;</span> <span class=n>OBJECT_CONSTRUCT_CALL_BADALLOC</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>_objc_callBadAllocHandler</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>nil</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>zone</span> <span class=o>&amp;&amp;</span> <span class=n>fast</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// 初始化isa，将类与 isa 关联
</span><span class=c1></span>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>initInstanceIsa</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=n>hasCxxDtor</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// Use raw pointer isa on the assumption that they might be
</span><span class=c1></span>        <span class=c1>// doing something weird with the zone or RR.
</span><span class=c1></span>          
      	<span class=c1>// 初始化isa
</span><span class=c1></span>				<span class=n>obj</span><span class=o>-&gt;</span><span class=n>initIsa</span><span class=p>(</span><span class=n>cls</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>fastpath</span><span class=p>(</span><span class=o>!</span><span class=n>hasCxxCtor</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>obj</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>construct_flags</span> <span class=o>|=</span> <span class=n>OBJECT_CONSTRUCT_FREE_ONFAILURE</span><span class=p>;</span>
  	<span class=c1>// 便利构造
</span><span class=c1></span>    <span class=k>return</span> <span class=n>object_cxxConstructFromClass</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>cls</span><span class=p>,</span> <span class=n>construct_flags</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>这个方法是整个 alloc 流程中的关键点，实现的主要功能如下：</p><ol><li><code>instanceSize</code>: 计算对象所需要开辟的内存空间</li><li><code>calloc</code>: 向系统申请开辟内存</li><li><code>initInstanceIsa: 初始化 </code>isa<code>指针，并将</code>isa<code>与当前</code>cls` 类进行关联</li></ol><h3 id=内存字节对齐><a href=#内存字节对齐 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>内存字节对齐</h3><p>计算一个对象所需要开辟的内存大小的流程如下</p><ul><li>进入<code>instanceSize</code>方法，根据缓存进行快速计算内存</li><li>进入<code>fastInstanceSize</code>方法<ul><li><code>_flags</code> ：存储对象的属性所占用的内存大小，根据对象的属性进行改变</li><li><code>FAST_CACHE_ALLOC_MASK</code>：存储实例的字节对齐大小+<code>ALLOC_DELTA16</code>的位与实例大小占用的位相同，因此，使用遮罩操作提前大小</li></ul></li><li>接着进入<code>align16</code>方法，进行 <strong>16字节内存对齐</strong></li></ul><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++>
<span class=c1>// 16 字节对齐算法
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=n>size_t</span> <span class=nf>align16</span><span class=p>(</span><span class=n>size_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>size_t</span><span class=p>(</span><span class=mi>15</span><span class=p>))</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>size_t</span><span class=p>(</span><span class=mi>15</span><span class=p>);</span>
<span class=p>}</span>

<span class=c1>// 获取类的大小
</span><span class=c1></span><span class=n>size_t</span> <span class=nf>instanceSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>extraBytes</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
  	<span class=c1>// 从源码779.1版本，新增加的判断
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>fastpath</span><span class=p>(</span><span class=n>cache</span><span class=p>.</span><span class=n>hasFastInstanceSize</span><span class=p>(</span><span class=n>extraBytes</span><span class=p>)))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>cache</span><span class=p>.</span><span class=n>fastInstanceSize</span><span class=p>(</span><span class=n>extraBytes</span><span class=p>);</span>
    <span class=p>}</span>
	
  	<span class=c1>// 779.1 以下的 8 字节对齐
</span><span class=c1></span>    <span class=n>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=n>alignedInstanceSize</span><span class=p>()</span> <span class=o>+</span> <span class=n>extraBytes</span><span class=p>;</span>
    <span class=c1>// CF requires all objects be at least 16 bytes.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>&lt;</span> <span class=mi>16</span><span class=p>)</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>size</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>size_t</span> <span class=nf>fastInstanceSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>extra</span><span class=p>)</span> <span class=k>const</span>
<span class=p>{</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>hasFastInstanceSize</span><span class=p>(</span><span class=n>extra</span><span class=p>));</span>
    <span class=c1>// gcc的内建函数 __builtin_constant_p 用于判断一个值是否为编译时常数，如果参数EXP 的值是常数，函数返回 1，否则返回 0
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>__builtin_constant_p</span><span class=p>(</span><span class=n>extra</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>extra</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>FAST_CACHE_ALLOC_MASK16</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=n>_flags</span> <span class=o>&amp;</span> <span class=n>FAST_CACHE_ALLOC_MASK</span><span class=p>;</span>
        <span class=c1>// remove the FAST_CACHE_ALLOC_DELTA16 that was added
</span><span class=c1></span>        <span class=c1>// by setFastInstanceSize              
</span><span class=c1></span>        <span class=k>return</span> <span class=n>align16</span><span class=p>(</span><span class=n>size</span> <span class=o>+</span> <span class=n>extra</span> <span class=o>-</span> <span class=n>FAST_CACHE_ALLOC_DELTA16</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// 8 字节对齐
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>uint32_t</span> <span class=nf>word_align</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>WORD_MASK</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>WORD_MASK</span><span class=p>;</span>
<span class=p>}</span>


<span class=kt>uint32_t</span> <span class=nf>unalignedInstanceSize</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
    <span class=n>ASSERT</span><span class=p>(</span><span class=n>isRealized</span><span class=p>());</span>
    <span class=c1>// 获取这个类所有属性内存的大小
</span><span class=c1></span>    <span class=k>return</span> <span class=n>data</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>ro</span><span class=o>-&gt;</span><span class=n>instanceSize</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// 获取类所需要的内存大小
</span><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>alignedInstanceSize</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>word_align</span><span class=p>(</span><span class=n>unalignedInstanceSize</span><span class=p>());</span>
<span class=p>}</span>

</code></pre></div><blockquote><p>从 779.1 版本开始，苹果对 cache 进行了优化，更快速去获取类的内存大小</p></blockquote><p><strong>字节对齐算法解析</strong></p><pre><code>假如： x = 9,

 x + 15 = 9 + 15 = 24
 15 二进制 ：0000 1111 = 15 （8+4+2+1）
 ~15 : 1111 0000
 24二进制为  : 0001 1000
  
 1111 0000
 0001 1000
---------------
 0001 0000 = 16

 所以 x = 16    也就是 16的倍数对齐，即 16 字节对齐

</code></pre><p>总结：<strong>对象大小为 16 字节，必定是 16 的倍数</strong></p><p>提出有个疑问：为什么要进行 16 字节对齐呢？</p><ul><li>通常内存是由一个个字节组成的，cpu在存取数据时，并不是以字节为单位存储，而是以<code>块</code>为单位存取，块的大小为内存存取力度。频繁存取字节未对齐的数据，会极大降低cpu的性能，所以可以通过<code>减少存取次数</code>来<code>降低cpu的开销</code></li><li>16字节对齐，是由于在一个对象中，第一个属性<code>isa</code>占<code>8</code>字节，当然一个对象肯定还有其他属性，当无属性时，会预留8字节，即16字节对齐，如果不预留，相当于这个对象的isa和其他对象的isa紧挨着，容易造成访问混乱</li><li>16字节对齐后，可以<code>加快CPU读取速度</code>，同时使<code>访问更安全</code>，不会产生访问混乱的情况</li></ul><p>这是<strong>空间换时间</strong>的做法。</p><h3 id=init--new><a href=#init--new class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>init & new</h3><p>通过源码可以发现，<code>init</code>实际什么也没做，只是返回了<code>强转的 self</code></p><p>这是采用工厂设计模式，提供给开发者一个接口</p><div class=highlight><pre class=chroma><code class=language-objective-c data-lang=objective-c><span class=c1>// Replaced by CF (throws an NSException)
</span><span class=c1></span><span class=p>+</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nf>init</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nb>self</span><span class=p>;</span>
<span class=p>}</span>

<span class=p>-</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nf>init</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>_objc_rootInit</span><span class=p>(</span><span class=nb>self</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>id</span>
<span class=nf>_objc_rootInit</span><span class=p>(</span><span class=kt>id</span> <span class=n>obj</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// In practice, it will be hard to rely on this function.
</span><span class=c1></span>    <span class=c1>// Many classes do not properly chain -init calls.
</span><span class=c1></span>    <span class=k>return</span> <span class=n>obj</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></div><blockquote><p>重写子类时</p><p>self = [super init]</p><p>这样写的好处是，子类先继承父类的属性，再判断是否为空，为空则直接返回nil</p></blockquote><p><strong>对于 new</strong></p><p>内部实现相当于：先执行 alloc，再执行 init</p><p>所以，在初始化代码上，可能会比较简洁。但是一般在开发中并不推荐直接使用 new。</p><blockquote><p>因为扩展性则不高，当我们重写 init 方法做一些自定义操作，用 new 初始化可能会无法走到自定义的部分</p></blockquote><div class=highlight><pre class=chroma><code class=language-objc data-lang=objc><span class=c1>// 先调用alloc，再init
</span><span class=c1></span><span class=p>+</span> <span class=p>(</span><span class=kt>id</span><span class=p>)</span><span class=nf>new</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>[</span><span class=n>callAlloc</span><span class=p>(</span><span class=nb>self</span><span class=p>,</span> <span class=nb>false</span><span class=cm>/*checkNil*/</span><span class=p>)</span> <span class=n>init</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></div></div></article><div class=post-tags><a href=../tags/ios/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>iOS</a></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2019–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Dev - jw</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},options:{renderActions:{addMenu:[0,'','']}},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){var a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script><script>let mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>